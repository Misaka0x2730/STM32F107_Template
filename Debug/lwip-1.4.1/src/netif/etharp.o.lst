   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"etharp.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	ethbroadcast
  19              		.section	.rodata
  20              		.align	2
  23              	ethbroadcast:
  24 0000 FF       		.byte	-1
  25 0001 FF       		.byte	-1
  26 0002 FF       		.byte	-1
  27 0003 FF       		.byte	-1
  28 0004 FF       		.byte	-1
  29 0005 FF       		.byte	-1
  30              		.global	ethzero
  31 0006 0000     		.align	2
  34              	ethzero:
  35 0008 00000000 		.space	6
  35      0000
  36              		.bss
  37              		.align	2
  38              	arp_table:
  39 0000 00000000 		.space	200
  39      00000000 
  39      00000000 
  39      00000000 
  39      00000000 
  40              	etharp_cached_entry:
  41 00c8 00       		.space	1
  42              		.section	.text.free_etharp_q,"ax",%progbits
  43              		.align	2
  44              		.thumb
  45              		.thumb_func
  47              	free_etharp_q:
  48              	.LFB0:
  49              		.file 1 "../lwip-1.4.1/src/netif/etharp.c"
   1:../lwip-1.4.1/src/netif/etharp.c **** /**
   2:../lwip-1.4.1/src/netif/etharp.c ****  * @file
   3:../lwip-1.4.1/src/netif/etharp.c ****  * Address Resolution Protocol module for IP over Ethernet
   4:../lwip-1.4.1/src/netif/etharp.c ****  *
   5:../lwip-1.4.1/src/netif/etharp.c ****  * Functionally, ARP is divided into two parts. The first maps an IP address
   6:../lwip-1.4.1/src/netif/etharp.c ****  * to a physical address when sending a packet, and the second part answers
   7:../lwip-1.4.1/src/netif/etharp.c ****  * requests from other machines for our physical address.
   8:../lwip-1.4.1/src/netif/etharp.c ****  *
   9:../lwip-1.4.1/src/netif/etharp.c ****  * This implementation complies with RFC 826 (Ethernet ARP). It supports
  10:../lwip-1.4.1/src/netif/etharp.c ****  * Gratuitious ARP from RFC3220 (IP Mobility Support for IPv4) section 4.6
  11:../lwip-1.4.1/src/netif/etharp.c ****  * if an interface calls etharp_gratuitous(our_netif) upon address change.
  12:../lwip-1.4.1/src/netif/etharp.c ****  */
  13:../lwip-1.4.1/src/netif/etharp.c **** 
  14:../lwip-1.4.1/src/netif/etharp.c **** /*
  15:../lwip-1.4.1/src/netif/etharp.c ****  * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
  16:../lwip-1.4.1/src/netif/etharp.c ****  * Copyright (c) 2003-2004 Leon Woestenberg <leon.woestenberg@axon.tv>
  17:../lwip-1.4.1/src/netif/etharp.c ****  * Copyright (c) 2003-2004 Axon Digital Design B.V., The Netherlands.
  18:../lwip-1.4.1/src/netif/etharp.c ****  * All rights reserved.
  19:../lwip-1.4.1/src/netif/etharp.c ****  *
  20:../lwip-1.4.1/src/netif/etharp.c ****  * Redistribution and use in source and binary forms, with or without modification,
  21:../lwip-1.4.1/src/netif/etharp.c ****  * are permitted provided that the following conditions are met:
  22:../lwip-1.4.1/src/netif/etharp.c ****  *
  23:../lwip-1.4.1/src/netif/etharp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  24:../lwip-1.4.1/src/netif/etharp.c ****  *    this list of conditions and the following disclaimer.
  25:../lwip-1.4.1/src/netif/etharp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  26:../lwip-1.4.1/src/netif/etharp.c ****  *    this list of conditions and the following disclaimer in the documentation
  27:../lwip-1.4.1/src/netif/etharp.c ****  *    and/or other materials provided with the distribution.
  28:../lwip-1.4.1/src/netif/etharp.c ****  * 3. The name of the author may not be used to endorse or promote products
  29:../lwip-1.4.1/src/netif/etharp.c ****  *    derived from this software without specific prior written permission.
  30:../lwip-1.4.1/src/netif/etharp.c ****  *
  31:../lwip-1.4.1/src/netif/etharp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  32:../lwip-1.4.1/src/netif/etharp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../lwip-1.4.1/src/netif/etharp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  34:../lwip-1.4.1/src/netif/etharp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  35:../lwip-1.4.1/src/netif/etharp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  36:../lwip-1.4.1/src/netif/etharp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  37:../lwip-1.4.1/src/netif/etharp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  38:../lwip-1.4.1/src/netif/etharp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  39:../lwip-1.4.1/src/netif/etharp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  40:../lwip-1.4.1/src/netif/etharp.c ****  * OF SUCH DAMAGE.
  41:../lwip-1.4.1/src/netif/etharp.c ****  *
  42:../lwip-1.4.1/src/netif/etharp.c ****  * This file is part of the lwIP TCP/IP stack.
  43:../lwip-1.4.1/src/netif/etharp.c ****  *
  44:../lwip-1.4.1/src/netif/etharp.c ****  */
  45:../lwip-1.4.1/src/netif/etharp.c ****  
  46:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/opt.h"
  47:../lwip-1.4.1/src/netif/etharp.c **** 
  48:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_ARP || LWIP_ETHERNET
  49:../lwip-1.4.1/src/netif/etharp.c **** 
  50:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/ip_addr.h"
  51:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/def.h"
  52:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/ip.h"
  53:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/stats.h"
  54:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/snmp.h"
  55:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/dhcp.h"
  56:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/autoip.h"
  57:../lwip-1.4.1/src/netif/etharp.c **** #include "netif/etharp.h"
  58:../lwip-1.4.1/src/netif/etharp.c **** #include "lwip/mem.h"
  59:../lwip-1.4.1/src/netif/etharp.c **** 
  60:../lwip-1.4.1/src/netif/etharp.c **** #if PPPOE_SUPPORT
  61:../lwip-1.4.1/src/netif/etharp.c **** #include "netif/ppp_oe.h"
  62:../lwip-1.4.1/src/netif/etharp.c **** #endif /* PPPOE_SUPPORT */
  63:../lwip-1.4.1/src/netif/etharp.c **** 
  64:../lwip-1.4.1/src/netif/etharp.c **** #include <string.h>
  65:../lwip-1.4.1/src/netif/etharp.c **** 
  66:../lwip-1.4.1/src/netif/etharp.c **** const struct eth_addr ethbroadcast = {{0xff,0xff,0xff,0xff,0xff,0xff}};
  67:../lwip-1.4.1/src/netif/etharp.c **** const struct eth_addr ethzero = {{0,0,0,0,0,0}};
  68:../lwip-1.4.1/src/netif/etharp.c **** 
  69:../lwip-1.4.1/src/netif/etharp.c **** /** The 24-bit IANA multicast OUI is 01-00-5e: */
  70:../lwip-1.4.1/src/netif/etharp.c **** #define LL_MULTICAST_ADDR_0 0x01
  71:../lwip-1.4.1/src/netif/etharp.c **** #define LL_MULTICAST_ADDR_1 0x00
  72:../lwip-1.4.1/src/netif/etharp.c **** #define LL_MULTICAST_ADDR_2 0x5e
  73:../lwip-1.4.1/src/netif/etharp.c **** 
  74:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_ARP /* don't build if not configured for use in lwipopts.h */
  75:../lwip-1.4.1/src/netif/etharp.c **** 
  76:../lwip-1.4.1/src/netif/etharp.c **** /** the time an ARP entry stays valid after its last update,
  77:../lwip-1.4.1/src/netif/etharp.c ****  *  for ARP_TMR_INTERVAL = 5000, this is
  78:../lwip-1.4.1/src/netif/etharp.c ****  *  (240 * 5) seconds = 20 minutes.
  79:../lwip-1.4.1/src/netif/etharp.c ****  */
  80:../lwip-1.4.1/src/netif/etharp.c **** #define ARP_MAXAGE              240
  81:../lwip-1.4.1/src/netif/etharp.c **** /** Re-request a used ARP entry 1 minute before it would expire to prevent
  82:../lwip-1.4.1/src/netif/etharp.c ****  *  breaking a steadily used connection because the ARP entry timed out. */
  83:../lwip-1.4.1/src/netif/etharp.c **** #define ARP_AGE_REREQUEST_USED  (ARP_MAXAGE - 12)
  84:../lwip-1.4.1/src/netif/etharp.c **** 
  85:../lwip-1.4.1/src/netif/etharp.c **** /** the time an ARP entry stays pending after first request,
  86:../lwip-1.4.1/src/netif/etharp.c ****  *  for ARP_TMR_INTERVAL = 5000, this is
  87:../lwip-1.4.1/src/netif/etharp.c ****  *  (2 * 5) seconds = 10 seconds.
  88:../lwip-1.4.1/src/netif/etharp.c ****  * 
  89:../lwip-1.4.1/src/netif/etharp.c ****  *  @internal Keep this number at least 2, otherwise it might
  90:../lwip-1.4.1/src/netif/etharp.c ****  *  run out instantly if the timeout occurs directly after a request.
  91:../lwip-1.4.1/src/netif/etharp.c ****  */
  92:../lwip-1.4.1/src/netif/etharp.c **** #define ARP_MAXPENDING 2
  93:../lwip-1.4.1/src/netif/etharp.c **** 
  94:../lwip-1.4.1/src/netif/etharp.c **** #define HWTYPE_ETHERNET 1
  95:../lwip-1.4.1/src/netif/etharp.c **** 
  96:../lwip-1.4.1/src/netif/etharp.c **** enum etharp_state {
  97:../lwip-1.4.1/src/netif/etharp.c ****   ETHARP_STATE_EMPTY = 0,
  98:../lwip-1.4.1/src/netif/etharp.c ****   ETHARP_STATE_PENDING,
  99:../lwip-1.4.1/src/netif/etharp.c ****   ETHARP_STATE_STABLE,
 100:../lwip-1.4.1/src/netif/etharp.c ****   ETHARP_STATE_STABLE_REREQUESTING
 101:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 102:../lwip-1.4.1/src/netif/etharp.c ****   ,ETHARP_STATE_STATIC
 103:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 104:../lwip-1.4.1/src/netif/etharp.c **** };
 105:../lwip-1.4.1/src/netif/etharp.c **** 
 106:../lwip-1.4.1/src/netif/etharp.c **** struct etharp_entry {
 107:../lwip-1.4.1/src/netif/etharp.c **** #if ARP_QUEUEING
 108:../lwip-1.4.1/src/netif/etharp.c ****   /** Pointer to queue of pending outgoing packets on this ARP entry. */
 109:../lwip-1.4.1/src/netif/etharp.c ****   struct etharp_q_entry *q;
 110:../lwip-1.4.1/src/netif/etharp.c **** #else /* ARP_QUEUEING */
 111:../lwip-1.4.1/src/netif/etharp.c ****   /** Pointer to a single pending outgoing packet on this ARP entry. */
 112:../lwip-1.4.1/src/netif/etharp.c ****   struct pbuf *q;
 113:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ARP_QUEUEING */
 114:../lwip-1.4.1/src/netif/etharp.c ****   ip_addr_t ipaddr;
 115:../lwip-1.4.1/src/netif/etharp.c ****   struct netif *netif;
 116:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_addr ethaddr;
 117:../lwip-1.4.1/src/netif/etharp.c ****   u8_t state;
 118:../lwip-1.4.1/src/netif/etharp.c ****   u8_t ctime;
 119:../lwip-1.4.1/src/netif/etharp.c **** };
 120:../lwip-1.4.1/src/netif/etharp.c **** 
 121:../lwip-1.4.1/src/netif/etharp.c **** static struct etharp_entry arp_table[ARP_TABLE_SIZE];
 122:../lwip-1.4.1/src/netif/etharp.c **** 
 123:../lwip-1.4.1/src/netif/etharp.c **** #if !LWIP_NETIF_HWADDRHINT
 124:../lwip-1.4.1/src/netif/etharp.c **** static u8_t etharp_cached_entry;
 125:../lwip-1.4.1/src/netif/etharp.c **** #endif /* !LWIP_NETIF_HWADDRHINT */
 126:../lwip-1.4.1/src/netif/etharp.c **** 
 127:../lwip-1.4.1/src/netif/etharp.c **** /** Try hard to create a new entry - we want the IP address to appear in
 128:../lwip-1.4.1/src/netif/etharp.c ****     the cache (even if this means removing an active entry or so). */
 129:../lwip-1.4.1/src/netif/etharp.c **** #define ETHARP_FLAG_TRY_HARD     1
 130:../lwip-1.4.1/src/netif/etharp.c **** #define ETHARP_FLAG_FIND_ONLY    2
 131:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 132:../lwip-1.4.1/src/netif/etharp.c **** #define ETHARP_FLAG_STATIC_ENTRY 4
 133:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 134:../lwip-1.4.1/src/netif/etharp.c **** 
 135:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 136:../lwip-1.4.1/src/netif/etharp.c **** #define ETHARP_SET_HINT(netif, hint)  if (((netif) != NULL) && ((netif)->addr_hint != NULL))  \
 137:../lwip-1.4.1/src/netif/etharp.c ****                                       *((netif)->addr_hint) = (hint);
 138:../lwip-1.4.1/src/netif/etharp.c **** #else /* LWIP_NETIF_HWADDRHINT */
 139:../lwip-1.4.1/src/netif/etharp.c **** #define ETHARP_SET_HINT(netif, hint)  (etharp_cached_entry = (hint))
 140:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 141:../lwip-1.4.1/src/netif/etharp.c **** 
 142:../lwip-1.4.1/src/netif/etharp.c **** 
 143:../lwip-1.4.1/src/netif/etharp.c **** /* Some checks, instead of etharp_init(): */
 144:../lwip-1.4.1/src/netif/etharp.c **** #if (LWIP_ARP && (ARP_TABLE_SIZE > 0x7f))
 145:../lwip-1.4.1/src/netif/etharp.c ****   #error "ARP_TABLE_SIZE must fit in an s8_t, you have to reduce it in your lwipopts.h"
 146:../lwip-1.4.1/src/netif/etharp.c **** #endif
 147:../lwip-1.4.1/src/netif/etharp.c **** 
 148:../lwip-1.4.1/src/netif/etharp.c **** 
 149:../lwip-1.4.1/src/netif/etharp.c **** #if ARP_QUEUEING
 150:../lwip-1.4.1/src/netif/etharp.c **** /**
 151:../lwip-1.4.1/src/netif/etharp.c ****  * Free a complete queue of etharp entries
 152:../lwip-1.4.1/src/netif/etharp.c ****  *
 153:../lwip-1.4.1/src/netif/etharp.c ****  * @param q a qeueue of etharp_q_entry's to free
 154:../lwip-1.4.1/src/netif/etharp.c ****  */
 155:../lwip-1.4.1/src/netif/etharp.c **** static void
 156:../lwip-1.4.1/src/netif/etharp.c **** free_etharp_q(struct etharp_q_entry *q)
 157:../lwip-1.4.1/src/netif/etharp.c **** {
  50              		.loc 1 157 0
  51              		.cfi_startproc
  52              		@ args = 0, pretend = 0, frame = 16
  53              		@ frame_needed = 1, uses_anonymous_args = 0
  54 0000 80B5     		push	{r7, lr}
  55              		.cfi_def_cfa_offset 8
  56              		.cfi_offset 7, -8
  57              		.cfi_offset 14, -4
  58 0002 84B0     		sub	sp, sp, #16
  59              		.cfi_def_cfa_offset 24
  60 0004 00AF     		add	r7, sp, #0
  61              		.cfi_def_cfa_register 7
  62 0006 7860     		str	r0, [r7, #4]
 158:../lwip-1.4.1/src/netif/etharp.c ****   struct etharp_q_entry *r;
 159:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 160:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("q->p != NULL", q->p != NULL);
 161:../lwip-1.4.1/src/netif/etharp.c ****   while (q) {
  63              		.loc 1 161 0
  64 0008 0DE0     		b	.L2
  65              	.L3:
 162:../lwip-1.4.1/src/netif/etharp.c ****     r = q;
  66              		.loc 1 162 0
  67 000a 7B68     		ldr	r3, [r7, #4]
  68 000c FB60     		str	r3, [r7, #12]
 163:../lwip-1.4.1/src/netif/etharp.c ****     q = q->next;
  69              		.loc 1 163 0
  70 000e 7B68     		ldr	r3, [r7, #4]
  71 0010 1B68     		ldr	r3, [r3]
  72 0012 7B60     		str	r3, [r7, #4]
 164:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_ASSERT("r->p != NULL", (r->p != NULL));
 165:../lwip-1.4.1/src/netif/etharp.c ****     pbuf_free(r->p);
  73              		.loc 1 165 0
  74 0014 FB68     		ldr	r3, [r7, #12]
  75 0016 5B68     		ldr	r3, [r3, #4]
  76 0018 1846     		mov	r0, r3
  77 001a FFF7FEFF 		bl	pbuf_free
 166:../lwip-1.4.1/src/netif/etharp.c ****     memp_free(MEMP_ARP_QUEUE, r);
  78              		.loc 1 166 0
  79 001e 0720     		movs	r0, #7
  80 0020 F968     		ldr	r1, [r7, #12]
  81 0022 FFF7FEFF 		bl	memp_free
  82              	.L2:
 161:../lwip-1.4.1/src/netif/etharp.c ****     r = q;
  83              		.loc 1 161 0
  84 0026 7B68     		ldr	r3, [r7, #4]
  85 0028 002B     		cmp	r3, #0
  86 002a EED1     		bne	.L3
 167:../lwip-1.4.1/src/netif/etharp.c ****   }
 168:../lwip-1.4.1/src/netif/etharp.c **** }
  87              		.loc 1 168 0
  88 002c 1037     		adds	r7, r7, #16
  89              		.cfi_def_cfa_offset 8
  90 002e BD46     		mov	sp, r7
  91              		.cfi_def_cfa_register 13
  92              		@ sp needed
  93 0030 80BD     		pop	{r7, pc}
  94              		.cfi_endproc
  95              	.LFE0:
  97 0032 00BF     		.section	.text.etharp_free_entry,"ax",%progbits
  98              		.align	2
  99              		.thumb
 100              		.thumb_func
 102              	etharp_free_entry:
 103              	.LFB1:
 169:../lwip-1.4.1/src/netif/etharp.c **** #else /* ARP_QUEUEING */
 170:../lwip-1.4.1/src/netif/etharp.c **** 
 171:../lwip-1.4.1/src/netif/etharp.c **** /** Compatibility define: free the queued pbuf */
 172:../lwip-1.4.1/src/netif/etharp.c **** #define free_etharp_q(q) pbuf_free(q)
 173:../lwip-1.4.1/src/netif/etharp.c **** 
 174:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ARP_QUEUEING */
 175:../lwip-1.4.1/src/netif/etharp.c **** 
 176:../lwip-1.4.1/src/netif/etharp.c **** /** Clean up ARP table entries */
 177:../lwip-1.4.1/src/netif/etharp.c **** static void
 178:../lwip-1.4.1/src/netif/etharp.c **** etharp_free_entry(int i)
 179:../lwip-1.4.1/src/netif/etharp.c **** {
 104              		.loc 1 179 0
 105              		.cfi_startproc
 106              		@ args = 0, pretend = 0, frame = 8
 107              		@ frame_needed = 1, uses_anonymous_args = 0
 108 0000 80B5     		push	{r7, lr}
 109              		.cfi_def_cfa_offset 8
 110              		.cfi_offset 7, -8
 111              		.cfi_offset 14, -4
 112 0002 82B0     		sub	sp, sp, #8
 113              		.cfi_def_cfa_offset 16
 114 0004 00AF     		add	r7, sp, #0
 115              		.cfi_def_cfa_register 7
 116 0006 7860     		str	r0, [r7, #4]
 180:../lwip-1.4.1/src/netif/etharp.c ****   /* remove from SNMP ARP index tree */
 181:../lwip-1.4.1/src/netif/etharp.c ****   snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
 182:../lwip-1.4.1/src/netif/etharp.c ****   /* and empty packet queue */
 183:../lwip-1.4.1/src/netif/etharp.c ****   if (arp_table[i].q != NULL) {
 117              		.loc 1 183 0
 118 0008 4149     		ldr	r1, .L6
 119 000a 7A68     		ldr	r2, [r7, #4]
 120 000c 1346     		mov	r3, r2
 121 000e 9B00     		lsls	r3, r3, #2
 122 0010 1344     		add	r3, r3, r2
 123 0012 9B00     		lsls	r3, r3, #2
 124 0014 0B44     		add	r3, r3, r1
 125 0016 1B68     		ldr	r3, [r3]
 126 0018 002B     		cmp	r3, #0
 127 001a 13D0     		beq	.L5
 184:../lwip-1.4.1/src/netif/etharp.c ****     /* remove all queued packets */
 185:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u1
 186:../lwip-1.4.1/src/netif/etharp.c ****     free_etharp_q(arp_table[i].q);
 128              		.loc 1 186 0
 129 001c 3C49     		ldr	r1, .L6
 130 001e 7A68     		ldr	r2, [r7, #4]
 131 0020 1346     		mov	r3, r2
 132 0022 9B00     		lsls	r3, r3, #2
 133 0024 1344     		add	r3, r3, r2
 134 0026 9B00     		lsls	r3, r3, #2
 135 0028 0B44     		add	r3, r3, r1
 136 002a 1B68     		ldr	r3, [r3]
 137 002c 1846     		mov	r0, r3
 138 002e FFF7FEFF 		bl	free_etharp_q
 187:../lwip-1.4.1/src/netif/etharp.c ****     arp_table[i].q = NULL;
 139              		.loc 1 187 0
 140 0032 3749     		ldr	r1, .L6
 141 0034 7A68     		ldr	r2, [r7, #4]
 142 0036 1346     		mov	r3, r2
 143 0038 9B00     		lsls	r3, r3, #2
 144 003a 1344     		add	r3, r3, r2
 145 003c 9B00     		lsls	r3, r3, #2
 146 003e 0B44     		add	r3, r3, r1
 147 0040 0022     		movs	r2, #0
 148 0042 1A60     		str	r2, [r3]
 149              	.L5:
 188:../lwip-1.4.1/src/netif/etharp.c ****   }
 189:../lwip-1.4.1/src/netif/etharp.c ****   /* recycle entry for re-use */
 190:../lwip-1.4.1/src/netif/etharp.c ****   arp_table[i].state = ETHARP_STATE_EMPTY;
 150              		.loc 1 190 0
 151 0044 3249     		ldr	r1, .L6
 152 0046 7A68     		ldr	r2, [r7, #4]
 153 0048 1346     		mov	r3, r2
 154 004a 9B00     		lsls	r3, r3, #2
 155 004c 1344     		add	r3, r3, r2
 156 004e 9B00     		lsls	r3, r3, #2
 157 0050 0B44     		add	r3, r3, r1
 158 0052 1033     		adds	r3, r3, #16
 159 0054 0022     		movs	r2, #0
 160 0056 9A70     		strb	r2, [r3, #2]
 191:../lwip-1.4.1/src/netif/etharp.c **** #ifdef LWIP_DEBUG
 192:../lwip-1.4.1/src/netif/etharp.c ****   /* for debugging, clean out the complete entry */
 193:../lwip-1.4.1/src/netif/etharp.c ****   arp_table[i].ctime = 0;
 161              		.loc 1 193 0
 162 0058 2D49     		ldr	r1, .L6
 163 005a 7A68     		ldr	r2, [r7, #4]
 164 005c 1346     		mov	r3, r2
 165 005e 9B00     		lsls	r3, r3, #2
 166 0060 1344     		add	r3, r3, r2
 167 0062 9B00     		lsls	r3, r3, #2
 168 0064 0B44     		add	r3, r3, r1
 169 0066 1033     		adds	r3, r3, #16
 170 0068 0022     		movs	r2, #0
 171 006a DA70     		strb	r2, [r3, #3]
 194:../lwip-1.4.1/src/netif/etharp.c ****   arp_table[i].netif = NULL;
 172              		.loc 1 194 0
 173 006c 2849     		ldr	r1, .L6
 174 006e 7A68     		ldr	r2, [r7, #4]
 175 0070 1346     		mov	r3, r2
 176 0072 9B00     		lsls	r3, r3, #2
 177 0074 1344     		add	r3, r3, r2
 178 0076 9B00     		lsls	r3, r3, #2
 179 0078 0B44     		add	r3, r3, r1
 180 007a 0833     		adds	r3, r3, #8
 181 007c 0022     		movs	r2, #0
 182 007e 1A60     		str	r2, [r3]
 195:../lwip-1.4.1/src/netif/etharp.c ****   ip_addr_set_zero(&arp_table[i].ipaddr);
 183              		.loc 1 195 0
 184 0080 2349     		ldr	r1, .L6
 185 0082 7A68     		ldr	r2, [r7, #4]
 186 0084 1346     		mov	r3, r2
 187 0086 9B00     		lsls	r3, r3, #2
 188 0088 1344     		add	r3, r3, r2
 189 008a 9B00     		lsls	r3, r3, #2
 190 008c 0B44     		add	r3, r3, r1
 191 008e 0022     		movs	r2, #0
 192 0090 5A60     		str	r2, [r3, #4]
 196:../lwip-1.4.1/src/netif/etharp.c ****   arp_table[i].ethaddr = ethzero;
 193              		.loc 1 196 0
 194 0092 1F49     		ldr	r1, .L6
 195 0094 7A68     		ldr	r2, [r7, #4]
 196 0096 1346     		mov	r3, r2
 197 0098 9B00     		lsls	r3, r3, #2
 198 009a 1344     		add	r3, r3, r2
 199 009c 9B00     		lsls	r3, r3, #2
 200 009e 0B44     		add	r3, r3, r1
 201 00a0 0833     		adds	r3, r3, #8
 202 00a2 0022     		movs	r2, #0
 203 00a4 1A71     		strb	r2, [r3, #4]
 204 00a6 1A49     		ldr	r1, .L6
 205 00a8 7A68     		ldr	r2, [r7, #4]
 206 00aa 1346     		mov	r3, r2
 207 00ac 9B00     		lsls	r3, r3, #2
 208 00ae 1344     		add	r3, r3, r2
 209 00b0 9B00     		lsls	r3, r3, #2
 210 00b2 0B44     		add	r3, r3, r1
 211 00b4 0933     		adds	r3, r3, #9
 212 00b6 0022     		movs	r2, #0
 213 00b8 1A71     		strb	r2, [r3, #4]
 214 00ba 1549     		ldr	r1, .L6
 215 00bc 7A68     		ldr	r2, [r7, #4]
 216 00be 1346     		mov	r3, r2
 217 00c0 9B00     		lsls	r3, r3, #2
 218 00c2 1344     		add	r3, r3, r2
 219 00c4 9B00     		lsls	r3, r3, #2
 220 00c6 0B44     		add	r3, r3, r1
 221 00c8 0A33     		adds	r3, r3, #10
 222 00ca 0022     		movs	r2, #0
 223 00cc 1A71     		strb	r2, [r3, #4]
 224 00ce 1049     		ldr	r1, .L6
 225 00d0 7A68     		ldr	r2, [r7, #4]
 226 00d2 1346     		mov	r3, r2
 227 00d4 9B00     		lsls	r3, r3, #2
 228 00d6 1344     		add	r3, r3, r2
 229 00d8 9B00     		lsls	r3, r3, #2
 230 00da 0B44     		add	r3, r3, r1
 231 00dc 0B33     		adds	r3, r3, #11
 232 00de 0022     		movs	r2, #0
 233 00e0 1A71     		strb	r2, [r3, #4]
 234 00e2 0B49     		ldr	r1, .L6
 235 00e4 7A68     		ldr	r2, [r7, #4]
 236 00e6 1346     		mov	r3, r2
 237 00e8 9B00     		lsls	r3, r3, #2
 238 00ea 1344     		add	r3, r3, r2
 239 00ec 9B00     		lsls	r3, r3, #2
 240 00ee 0B44     		add	r3, r3, r1
 241 00f0 0C33     		adds	r3, r3, #12
 242 00f2 0022     		movs	r2, #0
 243 00f4 1A71     		strb	r2, [r3, #4]
 244 00f6 0649     		ldr	r1, .L6
 245 00f8 7A68     		ldr	r2, [r7, #4]
 246 00fa 1346     		mov	r3, r2
 247 00fc 9B00     		lsls	r3, r3, #2
 248 00fe 1344     		add	r3, r3, r2
 249 0100 9B00     		lsls	r3, r3, #2
 250 0102 0B44     		add	r3, r3, r1
 251 0104 0D33     		adds	r3, r3, #13
 252 0106 0022     		movs	r2, #0
 253 0108 1A71     		strb	r2, [r3, #4]
 197:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_DEBUG */
 198:../lwip-1.4.1/src/netif/etharp.c **** }
 254              		.loc 1 198 0
 255 010a 0837     		adds	r7, r7, #8
 256              		.cfi_def_cfa_offset 8
 257 010c BD46     		mov	sp, r7
 258              		.cfi_def_cfa_register 13
 259              		@ sp needed
 260 010e 80BD     		pop	{r7, pc}
 261              	.L7:
 262              		.align	2
 263              	.L6:
 264 0110 00000000 		.word	arp_table
 265              		.cfi_endproc
 266              	.LFE1:
 268              		.section	.text.etharp_tmr,"ax",%progbits
 269              		.align	2
 270              		.global	etharp_tmr
 271              		.thumb
 272              		.thumb_func
 274              	etharp_tmr:
 275              	.LFB2:
 199:../lwip-1.4.1/src/netif/etharp.c **** 
 200:../lwip-1.4.1/src/netif/etharp.c **** /**
 201:../lwip-1.4.1/src/netif/etharp.c ****  * Clears expired entries in the ARP table.
 202:../lwip-1.4.1/src/netif/etharp.c ****  *
 203:../lwip-1.4.1/src/netif/etharp.c ****  * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 204:../lwip-1.4.1/src/netif/etharp.c ****  * in order to expire entries in the ARP table.
 205:../lwip-1.4.1/src/netif/etharp.c ****  */
 206:../lwip-1.4.1/src/netif/etharp.c **** void
 207:../lwip-1.4.1/src/netif/etharp.c **** etharp_tmr(void)
 208:../lwip-1.4.1/src/netif/etharp.c **** {
 276              		.loc 1 208 0
 277              		.cfi_startproc
 278              		@ args = 0, pretend = 0, frame = 8
 279              		@ frame_needed = 1, uses_anonymous_args = 0
 280 0000 80B5     		push	{r7, lr}
 281              		.cfi_def_cfa_offset 8
 282              		.cfi_offset 7, -8
 283              		.cfi_offset 14, -4
 284 0002 82B0     		sub	sp, sp, #8
 285              		.cfi_def_cfa_offset 16
 286 0004 00AF     		add	r7, sp, #0
 287              		.cfi_def_cfa_register 7
 209:../lwip-1.4.1/src/netif/etharp.c ****   u8_t i;
 210:../lwip-1.4.1/src/netif/etharp.c **** 
 211:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
 212:../lwip-1.4.1/src/netif/etharp.c ****   /* remove expired entries from the ARP table */
 213:../lwip-1.4.1/src/netif/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 288              		.loc 1 213 0
 289 0006 0023     		movs	r3, #0
 290 0008 FB71     		strb	r3, [r7, #7]
 291 000a 63E0     		b	.L9
 292              	.L14:
 293              	.LBB2:
 214:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 294              		.loc 1 214 0
 295 000c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 296 000e 3449     		ldr	r1, .L15
 297 0010 1346     		mov	r3, r2
 298 0012 9B00     		lsls	r3, r3, #2
 299 0014 1344     		add	r3, r3, r2
 300 0016 9B00     		lsls	r3, r3, #2
 301 0018 0B44     		add	r3, r3, r1
 302 001a 1033     		adds	r3, r3, #16
 303 001c 9B78     		ldrb	r3, [r3, #2]
 304 001e BB71     		strb	r3, [r7, #6]
 215:../lwip-1.4.1/src/netif/etharp.c ****     if (state != ETHARP_STATE_EMPTY
 305              		.loc 1 215 0
 306 0020 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 307 0022 002B     		cmp	r3, #0
 308 0024 53D0     		beq	.L10
 216:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 217:../lwip-1.4.1/src/netif/etharp.c ****       && (state != ETHARP_STATE_STATIC)
 218:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 219:../lwip-1.4.1/src/netif/etharp.c ****       ) {
 220:../lwip-1.4.1/src/netif/etharp.c ****       arp_table[i].ctime++;
 309              		.loc 1 220 0
 310 0026 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 311 0028 2D49     		ldr	r1, .L15
 312 002a 1346     		mov	r3, r2
 313 002c 9B00     		lsls	r3, r3, #2
 314 002e 1344     		add	r3, r3, r2
 315 0030 9B00     		lsls	r3, r3, #2
 316 0032 0B44     		add	r3, r3, r1
 317 0034 1033     		adds	r3, r3, #16
 318 0036 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 319 0038 0133     		adds	r3, r3, #1
 320 003a D8B2     		uxtb	r0, r3
 321 003c 2849     		ldr	r1, .L15
 322 003e 1346     		mov	r3, r2
 323 0040 9B00     		lsls	r3, r3, #2
 324 0042 1344     		add	r3, r3, r2
 325 0044 9B00     		lsls	r3, r3, #2
 326 0046 0B44     		add	r3, r3, r1
 327 0048 1033     		adds	r3, r3, #16
 328 004a 0246     		mov	r2, r0
 329 004c DA70     		strb	r2, [r3, #3]
 221:../lwip-1.4.1/src/netif/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 330              		.loc 1 221 0
 331 004e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 332 0050 2349     		ldr	r1, .L15
 333 0052 1346     		mov	r3, r2
 334 0054 9B00     		lsls	r3, r3, #2
 335 0056 1344     		add	r3, r3, r2
 336 0058 9B00     		lsls	r3, r3, #2
 337 005a 0B44     		add	r3, r3, r1
 338 005c 1033     		adds	r3, r3, #16
 339 005e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 340 0060 EF2B     		cmp	r3, #239
 341 0062 15D8     		bhi	.L11
 222:../lwip-1.4.1/src/netif/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 342              		.loc 1 222 0 discriminator 1
 343 0064 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 344 0066 1E49     		ldr	r1, .L15
 345 0068 1346     		mov	r3, r2
 346 006a 9B00     		lsls	r3, r3, #2
 347 006c 1344     		add	r3, r3, r2
 348 006e 9B00     		lsls	r3, r3, #2
 349 0070 0B44     		add	r3, r3, r1
 350 0072 1033     		adds	r3, r3, #16
 351 0074 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 221:../lwip-1.4.1/src/netif/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 352              		.loc 1 221 0 discriminator 1
 353 0076 012B     		cmp	r3, #1
 354 0078 0FD1     		bne	.L12
 223:../lwip-1.4.1/src/netif/etharp.c ****            (arp_table[i].ctime >= ARP_MAXPENDING))) {
 355              		.loc 1 223 0
 356 007a FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 357 007c 1849     		ldr	r1, .L15
 358 007e 1346     		mov	r3, r2
 359 0080 9B00     		lsls	r3, r3, #2
 360 0082 1344     		add	r3, r3, r2
 361 0084 9B00     		lsls	r3, r3, #2
 362 0086 0B44     		add	r3, r3, r1
 363 0088 1033     		adds	r3, r3, #16
 364 008a DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 222:../lwip-1.4.1/src/netif/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 365              		.loc 1 222 0
 366 008c 012B     		cmp	r3, #1
 367 008e 04D9     		bls	.L12
 368              	.L11:
 224:../lwip-1.4.1/src/netif/etharp.c ****         /* pending or stable entry has become old! */
 225:../lwip-1.4.1/src/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
 226:../lwip-1.4.1/src/netif/etharp.c ****              arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
 227:../lwip-1.4.1/src/netif/etharp.c ****         /* clean up entries that have just been expired */
 228:../lwip-1.4.1/src/netif/etharp.c ****         etharp_free_entry(i);
 369              		.loc 1 228 0
 370 0090 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 371 0092 1846     		mov	r0, r3
 372 0094 FFF7FEFF 		bl	etharp_free_entry
 373 0098 14E0     		b	.L13
 374              	.L12:
 229:../lwip-1.4.1/src/netif/etharp.c ****       }
 230:../lwip-1.4.1/src/netif/etharp.c ****       else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 375              		.loc 1 230 0
 376 009a FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 377 009c 1049     		ldr	r1, .L15
 378 009e 1346     		mov	r3, r2
 379 00a0 9B00     		lsls	r3, r3, #2
 380 00a2 1344     		add	r3, r3, r2
 381 00a4 9B00     		lsls	r3, r3, #2
 382 00a6 0B44     		add	r3, r3, r1
 383 00a8 1033     		adds	r3, r3, #16
 384 00aa 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 385 00ac 032B     		cmp	r3, #3
 386 00ae 09D1     		bne	.L13
 231:../lwip-1.4.1/src/netif/etharp.c ****         /* Reset state to stable, so that the next transmitted packet will
 232:../lwip-1.4.1/src/netif/etharp.c ****            re-send an ARP request. */
 233:../lwip-1.4.1/src/netif/etharp.c ****         arp_table[i].state = ETHARP_STATE_STABLE;
 387              		.loc 1 233 0
 388 00b0 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 389 00b2 0B49     		ldr	r1, .L15
 390 00b4 1346     		mov	r3, r2
 391 00b6 9B00     		lsls	r3, r3, #2
 392 00b8 1344     		add	r3, r3, r2
 393 00ba 9B00     		lsls	r3, r3, #2
 394 00bc 0B44     		add	r3, r3, r1
 395 00be 1033     		adds	r3, r3, #16
 396 00c0 0222     		movs	r2, #2
 397 00c2 9A70     		strb	r2, [r3, #2]
 398              	.L13:
 234:../lwip-1.4.1/src/netif/etharp.c ****       }
 235:../lwip-1.4.1/src/netif/etharp.c **** #if ARP_QUEUEING
 236:../lwip-1.4.1/src/netif/etharp.c ****       /* still pending entry? (not expired) */
 237:../lwip-1.4.1/src/netif/etharp.c ****       if (arp_table[i].state == ETHARP_STATE_PENDING) {
 399              		.loc 1 237 0
 400 00c4 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 401 00c6 1346     		mov	r3, r2
 402 00c8 9B00     		lsls	r3, r3, #2
 403 00ca 1344     		add	r3, r3, r2
 404 00cc 9B00     		lsls	r3, r3, #2
 405              	.L10:
 406              	.LBE2:
 213:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 407              		.loc 1 213 0 discriminator 2
 408 00ce FB79     		ldrb	r3, [r7, #7]
 409 00d0 0133     		adds	r3, r3, #1
 410 00d2 FB71     		strb	r3, [r7, #7]
 411              	.L9:
 213:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 412              		.loc 1 213 0 is_stmt 0 discriminator 1
 413 00d4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 414 00d6 092B     		cmp	r3, #9
 415 00d8 98D9     		bls	.L14
 238:../lwip-1.4.1/src/netif/etharp.c ****         /* resend an ARP query here? */
 239:../lwip-1.4.1/src/netif/etharp.c ****       }
 240:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ARP_QUEUEING */
 241:../lwip-1.4.1/src/netif/etharp.c ****     }
 242:../lwip-1.4.1/src/netif/etharp.c ****   }
 243:../lwip-1.4.1/src/netif/etharp.c **** }
 416              		.loc 1 243 0 is_stmt 1
 417 00da 0837     		adds	r7, r7, #8
 418              		.cfi_def_cfa_offset 8
 419 00dc BD46     		mov	sp, r7
 420              		.cfi_def_cfa_register 13
 421              		@ sp needed
 422 00de 80BD     		pop	{r7, pc}
 423              	.L16:
 424              		.align	2
 425              	.L15:
 426 00e0 00000000 		.word	arp_table
 427              		.cfi_endproc
 428              	.LFE2:
 430              		.section	.text.etharp_find_entry,"ax",%progbits
 431              		.align	2
 432              		.thumb
 433              		.thumb_func
 435              	etharp_find_entry:
 436              	.LFB3:
 244:../lwip-1.4.1/src/netif/etharp.c **** 
 245:../lwip-1.4.1/src/netif/etharp.c **** /**
 246:../lwip-1.4.1/src/netif/etharp.c ****  * Search the ARP table for a matching or new entry.
 247:../lwip-1.4.1/src/netif/etharp.c ****  * 
 248:../lwip-1.4.1/src/netif/etharp.c ****  * If an IP address is given, return a pending or stable ARP entry that matches
 249:../lwip-1.4.1/src/netif/etharp.c ****  * the address. If no match is found, create a new entry with this address set,
 250:../lwip-1.4.1/src/netif/etharp.c ****  * but in state ETHARP_EMPTY. The caller must check and possibly change the
 251:../lwip-1.4.1/src/netif/etharp.c ****  * state of the returned entry.
 252:../lwip-1.4.1/src/netif/etharp.c ****  * 
 253:../lwip-1.4.1/src/netif/etharp.c ****  * If ipaddr is NULL, return a initialized new entry in state ETHARP_EMPTY.
 254:../lwip-1.4.1/src/netif/etharp.c ****  * 
 255:../lwip-1.4.1/src/netif/etharp.c ****  * In all cases, attempt to create new entries from an empty entry. If no
 256:../lwip-1.4.1/src/netif/etharp.c ****  * empty entries are available and ETHARP_FLAG_TRY_HARD flag is set, recycle
 257:../lwip-1.4.1/src/netif/etharp.c ****  * old entries. Heuristic choose the least important entry for recycling.
 258:../lwip-1.4.1/src/netif/etharp.c ****  *
 259:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr IP address to find in ARP cache, or to add if not found.
 260:../lwip-1.4.1/src/netif/etharp.c ****  * @param flags @see definition of ETHARP_FLAG_*
 261:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif netif related to this address (used for NETIF_HWADDRHINT)
 262:../lwip-1.4.1/src/netif/etharp.c ****  *  
 263:../lwip-1.4.1/src/netif/etharp.c ****  * @return The ARP entry index that matched or is created, ERR_MEM if no
 264:../lwip-1.4.1/src/netif/etharp.c ****  * entry is found or could be recycled.
 265:../lwip-1.4.1/src/netif/etharp.c ****  */
 266:../lwip-1.4.1/src/netif/etharp.c **** static s8_t
 267:../lwip-1.4.1/src/netif/etharp.c **** etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
 268:../lwip-1.4.1/src/netif/etharp.c **** {
 437              		.loc 1 268 0
 438              		.cfi_startproc
 439              		@ args = 0, pretend = 0, frame = 24
 440              		@ frame_needed = 1, uses_anonymous_args = 0
 441 0000 80B5     		push	{r7, lr}
 442              		.cfi_def_cfa_offset 8
 443              		.cfi_offset 7, -8
 444              		.cfi_offset 14, -4
 445 0002 86B0     		sub	sp, sp, #24
 446              		.cfi_def_cfa_offset 32
 447 0004 00AF     		add	r7, sp, #0
 448              		.cfi_def_cfa_register 7
 449 0006 7860     		str	r0, [r7, #4]
 450 0008 0B46     		mov	r3, r1
 451 000a FB70     		strb	r3, [r7, #3]
 269:../lwip-1.4.1/src/netif/etharp.c ****   s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 452              		.loc 1 269 0
 453 000c 0A23     		movs	r3, #10
 454 000e FB75     		strb	r3, [r7, #23]
 455 0010 0A23     		movs	r3, #10
 456 0012 BB75     		strb	r3, [r7, #22]
 270:../lwip-1.4.1/src/netif/etharp.c ****   s8_t empty = ARP_TABLE_SIZE;
 457              		.loc 1 270 0
 458 0014 0A23     		movs	r3, #10
 459 0016 7B75     		strb	r3, [r7, #21]
 271:../lwip-1.4.1/src/netif/etharp.c ****   u8_t i = 0, age_pending = 0, age_stable = 0;
 460              		.loc 1 271 0
 461 0018 0023     		movs	r3, #0
 462 001a 3B75     		strb	r3, [r7, #20]
 463 001c 0023     		movs	r3, #0
 464 001e FB74     		strb	r3, [r7, #19]
 465 0020 0023     		movs	r3, #0
 466 0022 BB74     		strb	r3, [r7, #18]
 272:../lwip-1.4.1/src/netif/etharp.c ****   /* oldest entry with packets on queue */
 273:../lwip-1.4.1/src/netif/etharp.c ****   s8_t old_queue = ARP_TABLE_SIZE;
 467              		.loc 1 273 0
 468 0024 0A23     		movs	r3, #10
 469 0026 7B74     		strb	r3, [r7, #17]
 274:../lwip-1.4.1/src/netif/etharp.c ****   /* its age */
 275:../lwip-1.4.1/src/netif/etharp.c ****   u8_t age_queue = 0;
 470              		.loc 1 275 0
 471 0028 0023     		movs	r3, #0
 472 002a 3B74     		strb	r3, [r7, #16]
 276:../lwip-1.4.1/src/netif/etharp.c **** 
 277:../lwip-1.4.1/src/netif/etharp.c ****   /**
 278:../lwip-1.4.1/src/netif/etharp.c ****    * a) do a search through the cache, remember candidates
 279:../lwip-1.4.1/src/netif/etharp.c ****    * b) select candidate entry
 280:../lwip-1.4.1/src/netif/etharp.c ****    * c) create new entry
 281:../lwip-1.4.1/src/netif/etharp.c ****    */
 282:../lwip-1.4.1/src/netif/etharp.c **** 
 283:../lwip-1.4.1/src/netif/etharp.c ****   /* a) in a single search sweep, do all of this
 284:../lwip-1.4.1/src/netif/etharp.c ****    * 1) remember the first empty entry (if any)
 285:../lwip-1.4.1/src/netif/etharp.c ****    * 2) remember the oldest stable entry (if any)
 286:../lwip-1.4.1/src/netif/etharp.c ****    * 3) remember the oldest pending entry without queued packets (if any)
 287:../lwip-1.4.1/src/netif/etharp.c ****    * 4) remember the oldest pending entry with queued packets (if any)
 288:../lwip-1.4.1/src/netif/etharp.c ****    * 5) search for a matching IP entry, either pending or stable
 289:../lwip-1.4.1/src/netif/etharp.c ****    *    until 5 matches, or all entries are searched for.
 290:../lwip-1.4.1/src/netif/etharp.c ****    */
 291:../lwip-1.4.1/src/netif/etharp.c **** 
 292:../lwip-1.4.1/src/netif/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 473              		.loc 1 292 0
 474 002c 0023     		movs	r3, #0
 475 002e 3B75     		strb	r3, [r7, #20]
 476 0030 84E0     		b	.L18
 477              	.L27:
 478              	.LBB3:
 293:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 479              		.loc 1 293 0
 480 0032 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 481 0034 7049     		ldr	r1, .L38
 482 0036 1346     		mov	r3, r2
 483 0038 9B00     		lsls	r3, r3, #2
 484 003a 1344     		add	r3, r3, r2
 485 003c 9B00     		lsls	r3, r3, #2
 486 003e 0B44     		add	r3, r3, r1
 487 0040 1033     		adds	r3, r3, #16
 488 0042 9B78     		ldrb	r3, [r3, #2]
 489 0044 FB73     		strb	r3, [r7, #15]
 294:../lwip-1.4.1/src/netif/etharp.c ****     /* no empty entry found yet and now we do find one? */
 295:../lwip-1.4.1/src/netif/etharp.c ****     if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 490              		.loc 1 295 0
 491 0046 97F91530 		ldrsb	r3, [r7, #21]
 492 004a 0A2B     		cmp	r3, #10
 493 004c 05D1     		bne	.L19
 494              		.loc 1 295 0 is_stmt 0 discriminator 1
 495 004e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 496 0050 002B     		cmp	r3, #0
 497 0052 02D1     		bne	.L19
 296:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
 297:../lwip-1.4.1/src/netif/etharp.c ****       /* remember first empty entry */
 298:../lwip-1.4.1/src/netif/etharp.c ****       empty = i;
 498              		.loc 1 298 0 is_stmt 1
 499 0054 3B7D     		ldrb	r3, [r7, #20]
 500 0056 7B75     		strb	r3, [r7, #21]
 501 0058 6DE0     		b	.L20
 502              	.L19:
 299:../lwip-1.4.1/src/netif/etharp.c ****     } else if (state != ETHARP_STATE_EMPTY) {
 503              		.loc 1 299 0
 504 005a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 505 005c 002B     		cmp	r3, #0
 506 005e 6AD0     		beq	.L20
 300:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 301:../lwip-1.4.1/src/netif/etharp.c ****         state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 302:../lwip-1.4.1/src/netif/etharp.c ****       /* if given, does IP address match IP address in ARP entry? */
 303:../lwip-1.4.1/src/netif/etharp.c ****       if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 507              		.loc 1 303 0
 508 0060 7B68     		ldr	r3, [r7, #4]
 509 0062 002B     		cmp	r3, #0
 510 0064 0DD0     		beq	.L21
 511              		.loc 1 303 0 is_stmt 0 discriminator 1
 512 0066 7B68     		ldr	r3, [r7, #4]
 513 0068 1968     		ldr	r1, [r3]
 514 006a 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 515 006c 6248     		ldr	r0, .L38
 516 006e 1346     		mov	r3, r2
 517 0070 9B00     		lsls	r3, r3, #2
 518 0072 1344     		add	r3, r3, r2
 519 0074 9B00     		lsls	r3, r3, #2
 520 0076 0344     		add	r3, r3, r0
 521 0078 5B68     		ldr	r3, [r3, #4]
 522 007a 9942     		cmp	r1, r3
 523 007c 01D1     		bne	.L21
 304:../lwip-1.4.1/src/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_
 305:../lwip-1.4.1/src/netif/etharp.c ****         /* found exact IP address match, simply bail out */
 306:../lwip-1.4.1/src/netif/etharp.c ****         return i;
 524              		.loc 1 306 0 is_stmt 1
 525 007e 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 526 0080 B4E0     		b	.L22
 527              	.L21:
 307:../lwip-1.4.1/src/netif/etharp.c ****       }
 308:../lwip-1.4.1/src/netif/etharp.c ****       /* pending entry? */
 309:../lwip-1.4.1/src/netif/etharp.c ****       if (state == ETHARP_STATE_PENDING) {
 528              		.loc 1 309 0
 529 0082 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 530 0084 012B     		cmp	r3, #1
 531 0086 3BD1     		bne	.L23
 310:../lwip-1.4.1/src/netif/etharp.c ****         /* pending with queued packets? */
 311:../lwip-1.4.1/src/netif/etharp.c ****         if (arp_table[i].q != NULL) {
 532              		.loc 1 311 0
 533 0088 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 534 008a 5B49     		ldr	r1, .L38
 535 008c 1346     		mov	r3, r2
 536 008e 9B00     		lsls	r3, r3, #2
 537 0090 1344     		add	r3, r3, r2
 538 0092 9B00     		lsls	r3, r3, #2
 539 0094 0B44     		add	r3, r3, r1
 540 0096 1B68     		ldr	r3, [r3]
 541 0098 002B     		cmp	r3, #0
 542 009a 18D0     		beq	.L24
 312:../lwip-1.4.1/src/netif/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 543              		.loc 1 312 0
 544 009c 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 545 009e 5649     		ldr	r1, .L38
 546 00a0 1346     		mov	r3, r2
 547 00a2 9B00     		lsls	r3, r3, #2
 548 00a4 1344     		add	r3, r3, r2
 549 00a6 9B00     		lsls	r3, r3, #2
 550 00a8 0B44     		add	r3, r3, r1
 551 00aa 1033     		adds	r3, r3, #16
 552 00ac DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 553 00ae 3A7C     		ldrb	r2, [r7, #16]	@ zero_extendqisi2
 554 00b0 9A42     		cmp	r2, r3
 555 00b2 40D8     		bhi	.L20
 313:../lwip-1.4.1/src/netif/etharp.c ****             old_queue = i;
 556              		.loc 1 313 0
 557 00b4 3B7D     		ldrb	r3, [r7, #20]
 558 00b6 7B74     		strb	r3, [r7, #17]
 314:../lwip-1.4.1/src/netif/etharp.c ****             age_queue = arp_table[i].ctime;
 559              		.loc 1 314 0
 560 00b8 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 561 00ba 4F49     		ldr	r1, .L38
 562 00bc 1346     		mov	r3, r2
 563 00be 9B00     		lsls	r3, r3, #2
 564 00c0 1344     		add	r3, r3, r2
 565 00c2 9B00     		lsls	r3, r3, #2
 566 00c4 0B44     		add	r3, r3, r1
 567 00c6 1033     		adds	r3, r3, #16
 568 00c8 DB78     		ldrb	r3, [r3, #3]
 569 00ca 3B74     		strb	r3, [r7, #16]
 570 00cc 33E0     		b	.L20
 571              	.L24:
 315:../lwip-1.4.1/src/netif/etharp.c ****           }
 316:../lwip-1.4.1/src/netif/etharp.c ****         } else
 317:../lwip-1.4.1/src/netif/etharp.c ****         /* pending without queued packets? */
 318:../lwip-1.4.1/src/netif/etharp.c ****         {
 319:../lwip-1.4.1/src/netif/etharp.c ****           if (arp_table[i].ctime >= age_pending) {
 572              		.loc 1 319 0
 573 00ce 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 574 00d0 4949     		ldr	r1, .L38
 575 00d2 1346     		mov	r3, r2
 576 00d4 9B00     		lsls	r3, r3, #2
 577 00d6 1344     		add	r3, r3, r2
 578 00d8 9B00     		lsls	r3, r3, #2
 579 00da 0B44     		add	r3, r3, r1
 580 00dc 1033     		adds	r3, r3, #16
 581 00de DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 582 00e0 FA7C     		ldrb	r2, [r7, #19]	@ zero_extendqisi2
 583 00e2 9A42     		cmp	r2, r3
 584 00e4 27D8     		bhi	.L20
 320:../lwip-1.4.1/src/netif/etharp.c ****             old_pending = i;
 585              		.loc 1 320 0
 586 00e6 3B7D     		ldrb	r3, [r7, #20]
 587 00e8 FB75     		strb	r3, [r7, #23]
 321:../lwip-1.4.1/src/netif/etharp.c ****             age_pending = arp_table[i].ctime;
 588              		.loc 1 321 0
 589 00ea 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 590 00ec 4249     		ldr	r1, .L38
 591 00ee 1346     		mov	r3, r2
 592 00f0 9B00     		lsls	r3, r3, #2
 593 00f2 1344     		add	r3, r3, r2
 594 00f4 9B00     		lsls	r3, r3, #2
 595 00f6 0B44     		add	r3, r3, r1
 596 00f8 1033     		adds	r3, r3, #16
 597 00fa DB78     		ldrb	r3, [r3, #3]
 598 00fc FB74     		strb	r3, [r7, #19]
 599 00fe 1AE0     		b	.L20
 600              	.L23:
 322:../lwip-1.4.1/src/netif/etharp.c ****           }
 323:../lwip-1.4.1/src/netif/etharp.c ****         }
 324:../lwip-1.4.1/src/netif/etharp.c ****       /* stable entry? */
 325:../lwip-1.4.1/src/netif/etharp.c ****       } else if (state >= ETHARP_STATE_STABLE) {
 601              		.loc 1 325 0
 602 0100 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 603 0102 012B     		cmp	r3, #1
 604 0104 17D9     		bls	.L20
 326:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 327:../lwip-1.4.1/src/netif/etharp.c ****         /* don't record old_stable for static entries since they never expire */
 328:../lwip-1.4.1/src/netif/etharp.c ****         if (state < ETHARP_STATE_STATIC)
 329:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 330:../lwip-1.4.1/src/netif/etharp.c ****         {
 331:../lwip-1.4.1/src/netif/etharp.c ****           /* remember entry with oldest stable entry in oldest, its age in maxtime */
 332:../lwip-1.4.1/src/netif/etharp.c ****           if (arp_table[i].ctime >= age_stable) {
 605              		.loc 1 332 0
 606 0106 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 607 0108 3B49     		ldr	r1, .L38
 608 010a 1346     		mov	r3, r2
 609 010c 9B00     		lsls	r3, r3, #2
 610 010e 1344     		add	r3, r3, r2
 611 0110 9B00     		lsls	r3, r3, #2
 612 0112 0B44     		add	r3, r3, r1
 613 0114 1033     		adds	r3, r3, #16
 614 0116 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 615 0118 BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 616 011a 9A42     		cmp	r2, r3
 617 011c 0BD8     		bhi	.L20
 333:../lwip-1.4.1/src/netif/etharp.c ****             old_stable = i;
 618              		.loc 1 333 0
 619 011e 3B7D     		ldrb	r3, [r7, #20]
 620 0120 BB75     		strb	r3, [r7, #22]
 334:../lwip-1.4.1/src/netif/etharp.c ****             age_stable = arp_table[i].ctime;
 621              		.loc 1 334 0
 622 0122 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 623 0124 3449     		ldr	r1, .L38
 624 0126 1346     		mov	r3, r2
 625 0128 9B00     		lsls	r3, r3, #2
 626 012a 1344     		add	r3, r3, r2
 627 012c 9B00     		lsls	r3, r3, #2
 628 012e 0B44     		add	r3, r3, r1
 629 0130 1033     		adds	r3, r3, #16
 630 0132 DB78     		ldrb	r3, [r3, #3]
 631 0134 BB74     		strb	r3, [r7, #18]
 632              	.L20:
 633              	.LBE3:
 292:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 634              		.loc 1 292 0 discriminator 2
 635 0136 3B7D     		ldrb	r3, [r7, #20]
 636 0138 0133     		adds	r3, r3, #1
 637 013a 3B75     		strb	r3, [r7, #20]
 638              	.L18:
 292:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 639              		.loc 1 292 0 is_stmt 0 discriminator 1
 640 013c 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 641 013e 092B     		cmp	r3, #9
 642 0140 7FF677AF 		bls	.L27
 335:../lwip-1.4.1/src/netif/etharp.c ****           }
 336:../lwip-1.4.1/src/netif/etharp.c ****         }
 337:../lwip-1.4.1/src/netif/etharp.c ****       }
 338:../lwip-1.4.1/src/netif/etharp.c ****     }
 339:../lwip-1.4.1/src/netif/etharp.c ****   }
 340:../lwip-1.4.1/src/netif/etharp.c ****   /* { we have no match } => try to create a new entry */
 341:../lwip-1.4.1/src/netif/etharp.c ****    
 342:../lwip-1.4.1/src/netif/etharp.c ****   /* don't create new entry, only search? */
 343:../lwip-1.4.1/src/netif/etharp.c ****   if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 643              		.loc 1 343 0 is_stmt 1
 644 0144 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 645 0146 03F00203 		and	r3, r3, #2
 646 014a 002B     		cmp	r3, #0
 647 014c 08D1     		bne	.L28
 648              		.loc 1 343 0 is_stmt 0 discriminator 1
 649 014e 97F91530 		ldrsb	r3, [r7, #21]
 650 0152 0A2B     		cmp	r3, #10
 651 0154 06D1     		bne	.L29
 344:../lwip-1.4.1/src/netif/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 345:../lwip-1.4.1/src/netif/etharp.c ****       ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 652              		.loc 1 345 0 is_stmt 1
 653 0156 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 654 0158 03F00103 		and	r3, r3, #1
 655 015c 002B     		cmp	r3, #0
 656 015e 01D1     		bne	.L29
 657              	.L28:
 346:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not al
 347:../lwip-1.4.1/src/netif/etharp.c ****     return (s8_t)ERR_MEM;
 658              		.loc 1 347 0
 659 0160 FF23     		movs	r3, #255
 660 0162 43E0     		b	.L22
 661              	.L29:
 348:../lwip-1.4.1/src/netif/etharp.c ****   }
 349:../lwip-1.4.1/src/netif/etharp.c ****   
 350:../lwip-1.4.1/src/netif/etharp.c ****   /* b) choose the least destructive entry to recycle:
 351:../lwip-1.4.1/src/netif/etharp.c ****    * 1) empty entry
 352:../lwip-1.4.1/src/netif/etharp.c ****    * 2) oldest stable entry
 353:../lwip-1.4.1/src/netif/etharp.c ****    * 3) oldest pending entry without queued packets
 354:../lwip-1.4.1/src/netif/etharp.c ****    * 4) oldest pending entry with queued packets
 355:../lwip-1.4.1/src/netif/etharp.c ****    * 
 356:../lwip-1.4.1/src/netif/etharp.c ****    * { ETHARP_FLAG_TRY_HARD is set at this point }
 357:../lwip-1.4.1/src/netif/etharp.c ****    */ 
 358:../lwip-1.4.1/src/netif/etharp.c **** 
 359:../lwip-1.4.1/src/netif/etharp.c ****   /* 1) empty entry available? */
 360:../lwip-1.4.1/src/netif/etharp.c ****   if (empty < ARP_TABLE_SIZE) {
 662              		.loc 1 360 0
 663 0164 97F91530 		ldrsb	r3, [r7, #21]
 664 0168 092B     		cmp	r3, #9
 665 016a 02DC     		bgt	.L30
 361:../lwip-1.4.1/src/netif/etharp.c ****     i = empty;
 666              		.loc 1 361 0
 667 016c 7B7D     		ldrb	r3, [r7, #21]
 668 016e 3B75     		strb	r3, [r7, #20]
 669 0170 1FE0     		b	.L37
 670              	.L30:
 362:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\
 363:../lwip-1.4.1/src/netif/etharp.c ****   } else {
 364:../lwip-1.4.1/src/netif/etharp.c ****     /* 2) found recyclable stable entry? */
 365:../lwip-1.4.1/src/netif/etharp.c ****     if (old_stable < ARP_TABLE_SIZE) {
 671              		.loc 1 365 0
 672 0172 97F91630 		ldrsb	r3, [r7, #22]
 673 0176 092B     		cmp	r3, #9
 674 0178 07DC     		bgt	.L32
 366:../lwip-1.4.1/src/netif/etharp.c ****       /* recycle oldest stable*/
 367:../lwip-1.4.1/src/netif/etharp.c ****       i = old_stable;
 675              		.loc 1 367 0
 676 017a BB7D     		ldrb	r3, [r7, #22]
 677 017c 3B75     		strb	r3, [r7, #20]
 368:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry
 369:../lwip-1.4.1/src/netif/etharp.c ****       /* no queued packets should exist on stable entries */
 370:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 678              		.loc 1 370 0
 679 017e 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 680 0180 1346     		mov	r3, r2
 681 0182 9B00     		lsls	r3, r3, #2
 682 0184 1344     		add	r3, r3, r2
 683 0186 9B00     		lsls	r3, r3, #2
 684 0188 0FE0     		b	.L33
 685              	.L32:
 371:../lwip-1.4.1/src/netif/etharp.c ****     /* 3) found recyclable pending entry without queued packets? */
 372:../lwip-1.4.1/src/netif/etharp.c ****     } else if (old_pending < ARP_TABLE_SIZE) {
 686              		.loc 1 372 0
 687 018a 97F91730 		ldrsb	r3, [r7, #23]
 688 018e 092B     		cmp	r3, #9
 689 0190 02DC     		bgt	.L34
 373:../lwip-1.4.1/src/netif/etharp.c ****       /* recycle oldest pending */
 374:../lwip-1.4.1/src/netif/etharp.c ****       i = old_pending;
 690              		.loc 1 374 0
 691 0192 FB7D     		ldrb	r3, [r7, #23]
 692 0194 3B75     		strb	r3, [r7, #20]
 693 0196 08E0     		b	.L33
 694              	.L34:
 375:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entr
 376:../lwip-1.4.1/src/netif/etharp.c ****     /* 4) found recyclable pending entry with queued packets? */
 377:../lwip-1.4.1/src/netif/etharp.c ****     } else if (old_queue < ARP_TABLE_SIZE) {
 695              		.loc 1 377 0
 696 0198 97F91130 		ldrsb	r3, [r7, #17]
 697 019c 092B     		cmp	r3, #9
 698 019e 02DC     		bgt	.L35
 378:../lwip-1.4.1/src/netif/etharp.c ****       /* recycle oldest pending (queued packets are free in etharp_free_entry) */
 379:../lwip-1.4.1/src/netif/etharp.c ****       i = old_queue;
 699              		.loc 1 379 0
 700 01a0 7B7C     		ldrb	r3, [r7, #17]
 701 01a2 3B75     		strb	r3, [r7, #20]
 702 01a4 01E0     		b	.L33
 703              	.L35:
 380:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entr
 381:../lwip-1.4.1/src/netif/etharp.c ****       /* no empty or recyclable entries found */
 382:../lwip-1.4.1/src/netif/etharp.c ****     } else {
 383:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entrie
 384:../lwip-1.4.1/src/netif/etharp.c ****       return (s8_t)ERR_MEM;
 704              		.loc 1 384 0
 705 01a6 FF23     		movs	r3, #255
 706 01a8 20E0     		b	.L22
 707              	.L33:
 385:../lwip-1.4.1/src/netif/etharp.c ****     }
 386:../lwip-1.4.1/src/netif/etharp.c **** 
 387:../lwip-1.4.1/src/netif/etharp.c ****     /* { empty or recyclable entry found } */
 388:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 389:../lwip-1.4.1/src/netif/etharp.c ****     etharp_free_entry(i);
 708              		.loc 1 389 0
 709 01aa 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 710 01ac 1846     		mov	r0, r3
 711 01ae FFF7FEFF 		bl	etharp_free_entry
 712              	.L37:
 390:../lwip-1.4.1/src/netif/etharp.c ****   }
 391:../lwip-1.4.1/src/netif/etharp.c **** 
 392:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 393:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 713              		.loc 1 393 0
 714 01b2 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 715 01b4 1346     		mov	r3, r2
 716 01b6 9B00     		lsls	r3, r3, #2
 717 01b8 1344     		add	r3, r3, r2
 718 01ba 9B00     		lsls	r3, r3, #2
 394:../lwip-1.4.1/src/netif/etharp.c ****     arp_table[i].state == ETHARP_STATE_EMPTY);
 395:../lwip-1.4.1/src/netif/etharp.c **** 
 396:../lwip-1.4.1/src/netif/etharp.c ****   /* IP address given? */
 397:../lwip-1.4.1/src/netif/etharp.c ****   if (ipaddr != NULL) {
 719              		.loc 1 397 0
 720 01bc 7B68     		ldr	r3, [r7, #4]
 721 01be 002B     		cmp	r3, #0
 722 01c0 09D0     		beq	.L36
 398:../lwip-1.4.1/src/netif/etharp.c ****     /* set IP address */
 399:../lwip-1.4.1/src/netif/etharp.c ****     ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 723              		.loc 1 399 0
 724 01c2 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 725 01c4 7B68     		ldr	r3, [r7, #4]
 726 01c6 1968     		ldr	r1, [r3]
 727 01c8 0B48     		ldr	r0, .L38
 728 01ca 1346     		mov	r3, r2
 729 01cc 9B00     		lsls	r3, r3, #2
 730 01ce 1344     		add	r3, r3, r2
 731 01d0 9B00     		lsls	r3, r3, #2
 732 01d2 0344     		add	r3, r3, r0
 733 01d4 5960     		str	r1, [r3, #4]
 734              	.L36:
 400:../lwip-1.4.1/src/netif/etharp.c ****   }
 401:../lwip-1.4.1/src/netif/etharp.c ****   arp_table[i].ctime = 0;
 735              		.loc 1 401 0
 736 01d6 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 737 01d8 0749     		ldr	r1, .L38
 738 01da 1346     		mov	r3, r2
 739 01dc 9B00     		lsls	r3, r3, #2
 740 01de 1344     		add	r3, r3, r2
 741 01e0 9B00     		lsls	r3, r3, #2
 742 01e2 0B44     		add	r3, r3, r1
 743 01e4 1033     		adds	r3, r3, #16
 744 01e6 0022     		movs	r2, #0
 745 01e8 DA70     		strb	r2, [r3, #3]
 402:../lwip-1.4.1/src/netif/etharp.c ****   return (err_t)i;
 746              		.loc 1 402 0
 747 01ea 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 748              	.L22:
 749 01ec 5BB2     		sxtb	r3, r3
 403:../lwip-1.4.1/src/netif/etharp.c **** }
 750              		.loc 1 403 0
 751 01ee 1846     		mov	r0, r3
 752 01f0 1837     		adds	r7, r7, #24
 753              		.cfi_def_cfa_offset 8
 754 01f2 BD46     		mov	sp, r7
 755              		.cfi_def_cfa_register 13
 756              		@ sp needed
 757 01f4 80BD     		pop	{r7, pc}
 758              	.L39:
 759 01f6 00BF     		.align	2
 760              	.L38:
 761 01f8 00000000 		.word	arp_table
 762              		.cfi_endproc
 763              	.LFE3:
 765              		.section	.text.etharp_send_ip,"ax",%progbits
 766              		.align	2
 767              		.thumb
 768              		.thumb_func
 770              	etharp_send_ip:
 771              	.LFB4:
 404:../lwip-1.4.1/src/netif/etharp.c **** 
 405:../lwip-1.4.1/src/netif/etharp.c **** /**
 406:../lwip-1.4.1/src/netif/etharp.c ****  * Send an IP packet on the network using netif->linkoutput
 407:../lwip-1.4.1/src/netif/etharp.c ****  * The ethernet header is filled in before sending.
 408:../lwip-1.4.1/src/netif/etharp.c ****  *
 409:../lwip-1.4.1/src/netif/etharp.c ****  * @params netif the lwIP network interface on which to send the packet
 410:../lwip-1.4.1/src/netif/etharp.c ****  * @params p the packet to send, p->payload pointing to the (uninitialized) ethernet header
 411:../lwip-1.4.1/src/netif/etharp.c ****  * @params src the source MAC address to be copied into the ethernet header
 412:../lwip-1.4.1/src/netif/etharp.c ****  * @params dst the destination MAC address to be copied into the ethernet header
 413:../lwip-1.4.1/src/netif/etharp.c ****  * @return ERR_OK if the packet was sent, any other err_t on failure
 414:../lwip-1.4.1/src/netif/etharp.c ****  */
 415:../lwip-1.4.1/src/netif/etharp.c **** static err_t
 416:../lwip-1.4.1/src/netif/etharp.c **** etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
 417:../lwip-1.4.1/src/netif/etharp.c **** {
 772              		.loc 1 417 0
 773              		.cfi_startproc
 774              		@ args = 0, pretend = 0, frame = 24
 775              		@ frame_needed = 1, uses_anonymous_args = 0
 776 0000 80B5     		push	{r7, lr}
 777              		.cfi_def_cfa_offset 8
 778              		.cfi_offset 7, -8
 779              		.cfi_offset 14, -4
 780 0002 86B0     		sub	sp, sp, #24
 781              		.cfi_def_cfa_offset 32
 782 0004 00AF     		add	r7, sp, #0
 783              		.cfi_def_cfa_register 7
 784 0006 F860     		str	r0, [r7, #12]
 785 0008 B960     		str	r1, [r7, #8]
 786 000a 7A60     		str	r2, [r7, #4]
 787 000c 3B60     		str	r3, [r7]
 418:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 788              		.loc 1 418 0
 789 000e BB68     		ldr	r3, [r7, #8]
 790 0010 5B68     		ldr	r3, [r3, #4]
 791 0012 7B61     		str	r3, [r7, #20]
 419:../lwip-1.4.1/src/netif/etharp.c **** 
 420:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 421:../lwip-1.4.1/src/netif/etharp.c ****               (netif->hwaddr_len == ETHARP_HWADDR_LEN));
 422:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR32_COPY(&ethhdr->dest, dst);
 792              		.loc 1 422 0
 793 0014 7B69     		ldr	r3, [r7, #20]
 794 0016 1846     		mov	r0, r3
 795 0018 3968     		ldr	r1, [r7]
 796 001a 0622     		movs	r2, #6
 797 001c FFF7FEFF 		bl	memcpy
 423:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->src, src);
 798              		.loc 1 423 0
 799 0020 7B69     		ldr	r3, [r7, #20]
 800 0022 0633     		adds	r3, r3, #6
 801 0024 1846     		mov	r0, r3
 802 0026 7968     		ldr	r1, [r7, #4]
 803 0028 0622     		movs	r2, #6
 804 002a FFF7FEFF 		bl	memcpy
 424:../lwip-1.4.1/src/netif/etharp.c ****   ethhdr->type = PP_HTONS(ETHTYPE_IP);
 805              		.loc 1 424 0
 806 002e 7B69     		ldr	r3, [r7, #20]
 807 0030 0022     		movs	r2, #0
 808 0032 42F00802 		orr	r2, r2, #8
 809 0036 1A73     		strb	r2, [r3, #12]
 810 0038 0022     		movs	r2, #0
 811 003a 5A73     		strb	r2, [r3, #13]
 425:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
 426:../lwip-1.4.1/src/netif/etharp.c ****   /* send the packet */
 427:../lwip-1.4.1/src/netif/etharp.c ****   return netif->linkoutput(netif, p);
 812              		.loc 1 427 0
 813 003c FB68     		ldr	r3, [r7, #12]
 814 003e 9B69     		ldr	r3, [r3, #24]
 815 0040 F868     		ldr	r0, [r7, #12]
 816 0042 B968     		ldr	r1, [r7, #8]
 817 0044 9847     		blx	r3
 818 0046 0346     		mov	r3, r0
 428:../lwip-1.4.1/src/netif/etharp.c **** }
 819              		.loc 1 428 0
 820 0048 1846     		mov	r0, r3
 821 004a 1837     		adds	r7, r7, #24
 822              		.cfi_def_cfa_offset 8
 823 004c BD46     		mov	sp, r7
 824              		.cfi_def_cfa_register 13
 825              		@ sp needed
 826 004e 80BD     		pop	{r7, pc}
 827              		.cfi_endproc
 828              	.LFE4:
 830              		.section	.text.etharp_update_arp_entry,"ax",%progbits
 831              		.align	2
 832              		.thumb
 833              		.thumb_func
 835              	etharp_update_arp_entry:
 836              	.LFB5:
 429:../lwip-1.4.1/src/netif/etharp.c **** 
 430:../lwip-1.4.1/src/netif/etharp.c **** /**
 431:../lwip-1.4.1/src/netif/etharp.c ****  * Update (or insert) a IP/MAC address pair in the ARP cache.
 432:../lwip-1.4.1/src/netif/etharp.c ****  *
 433:../lwip-1.4.1/src/netif/etharp.c ****  * If a pending entry is resolved, any queued packets will be sent
 434:../lwip-1.4.1/src/netif/etharp.c ****  * at this point.
 435:../lwip-1.4.1/src/netif/etharp.c ****  * 
 436:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif netif related to this entry (used for NETIF_ADDRHINT)
 437:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr IP address of the inserted ARP entry.
 438:../lwip-1.4.1/src/netif/etharp.c ****  * @param ethaddr Ethernet address of the inserted ARP entry.
 439:../lwip-1.4.1/src/netif/etharp.c ****  * @param flags @see definition of ETHARP_FLAG_*
 440:../lwip-1.4.1/src/netif/etharp.c ****  *
 441:../lwip-1.4.1/src/netif/etharp.c ****  * @return
 442:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_OK Succesfully updated ARP cache.
 443:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_MEM If we could not add a new ARP entry when ETHARP_FLAG_TRY_HARD was set.
 444:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 445:../lwip-1.4.1/src/netif/etharp.c ****  *
 446:../lwip-1.4.1/src/netif/etharp.c ****  * @see pbuf_free()
 447:../lwip-1.4.1/src/netif/etharp.c ****  */
 448:../lwip-1.4.1/src/netif/etharp.c **** static err_t
 449:../lwip-1.4.1/src/netif/etharp.c **** etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flag
 450:../lwip-1.4.1/src/netif/etharp.c **** {
 837              		.loc 1 450 0
 838              		.cfi_startproc
 839              		@ args = 0, pretend = 0, frame = 32
 840              		@ frame_needed = 1, uses_anonymous_args = 0
 841 0000 80B5     		push	{r7, lr}
 842              		.cfi_def_cfa_offset 8
 843              		.cfi_offset 7, -8
 844              		.cfi_offset 14, -4
 845 0002 88B0     		sub	sp, sp, #32
 846              		.cfi_def_cfa_offset 40
 847 0004 00AF     		add	r7, sp, #0
 848              		.cfi_def_cfa_register 7
 849 0006 F860     		str	r0, [r7, #12]
 850 0008 B960     		str	r1, [r7, #8]
 851 000a 7A60     		str	r2, [r7, #4]
 852 000c FB70     		strb	r3, [r7, #3]
 451:../lwip-1.4.1/src/netif/etharp.c ****   s8_t i;
 452:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
 453:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 454:../lwip-1.4.1/src/netif/etharp.c ****     ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
 455:../lwip-1.4.1/src/netif/etharp.c ****     ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
 456:../lwip-1.4.1/src/netif/etharp.c ****     ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
 457:../lwip-1.4.1/src/netif/etharp.c ****   /* non-unicast address? */
 458:../lwip-1.4.1/src/netif/etharp.c ****   if (ip_addr_isany(ipaddr) ||
 853              		.loc 1 458 0
 854 000e BB68     		ldr	r3, [r7, #8]
 855 0010 002B     		cmp	r3, #0
 856 0012 12D0     		beq	.L43
 857              		.loc 1 458 0 is_stmt 0 discriminator 1
 858 0014 BB68     		ldr	r3, [r7, #8]
 859 0016 1B68     		ldr	r3, [r3]
 860 0018 002B     		cmp	r3, #0
 861 001a 0ED0     		beq	.L43
 459:../lwip-1.4.1/src/netif/etharp.c ****       ip_addr_isbroadcast(ipaddr, netif) ||
 862              		.loc 1 459 0 is_stmt 1 discriminator 2
 863 001c BB68     		ldr	r3, [r7, #8]
 864 001e 1B68     		ldr	r3, [r3]
 865 0020 1846     		mov	r0, r3
 866 0022 F968     		ldr	r1, [r7, #12]
 867 0024 FFF7FEFF 		bl	ip4_addr_isbroadcast
 868 0028 0346     		mov	r3, r0
 458:../lwip-1.4.1/src/netif/etharp.c ****       ip_addr_isbroadcast(ipaddr, netif) ||
 869              		.loc 1 458 0 discriminator 2
 870 002a 002B     		cmp	r3, #0
 871 002c 05D1     		bne	.L43
 460:../lwip-1.4.1/src/netif/etharp.c ****       ip_addr_ismulticast(ipaddr)) {
 872              		.loc 1 460 0
 873 002e BB68     		ldr	r3, [r7, #8]
 874 0030 1B68     		ldr	r3, [r3]
 875 0032 03F0F003 		and	r3, r3, #240
 459:../lwip-1.4.1/src/netif/etharp.c ****       ip_addr_isbroadcast(ipaddr, netif) ||
 876              		.loc 1 459 0
 877 0036 E02B     		cmp	r3, #224
 878 0038 01D1     		bne	.L44
 879              	.L43:
 461:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast 
 462:../lwip-1.4.1/src/netif/etharp.c ****     return ERR_ARG;
 880              		.loc 1 462 0
 881 003a F223     		movs	r3, #242
 882 003c 70E0     		b	.L45
 883              	.L44:
 463:../lwip-1.4.1/src/netif/etharp.c ****   }
 464:../lwip-1.4.1/src/netif/etharp.c ****   /* find or create ARP entry */
 465:../lwip-1.4.1/src/netif/etharp.c ****   i = etharp_find_entry(ipaddr, flags);
 884              		.loc 1 465 0
 885 003e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 886 0040 B868     		ldr	r0, [r7, #8]
 887 0042 1946     		mov	r1, r3
 888 0044 FFF7FEFF 		bl	etharp_find_entry
 889 0048 0346     		mov	r3, r0
 890 004a FB77     		strb	r3, [r7, #31]
 466:../lwip-1.4.1/src/netif/etharp.c ****   /* bail out if no entry could be found */
 467:../lwip-1.4.1/src/netif/etharp.c ****   if (i < 0) {
 891              		.loc 1 467 0
 892 004c 97F91F30 		ldrsb	r3, [r7, #31]
 893 0050 002B     		cmp	r3, #0
 894 0052 01DA     		bge	.L46
 468:../lwip-1.4.1/src/netif/etharp.c ****     return (err_t)i;
 895              		.loc 1 468 0
 896 0054 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 897 0056 63E0     		b	.L45
 898              	.L46:
 469:../lwip-1.4.1/src/netif/etharp.c ****   }
 470:../lwip-1.4.1/src/netif/etharp.c **** 
 471:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 472:../lwip-1.4.1/src/netif/etharp.c ****   if (flags & ETHARP_FLAG_STATIC_ENTRY) {
 473:../lwip-1.4.1/src/netif/etharp.c ****     /* record static type */
 474:../lwip-1.4.1/src/netif/etharp.c ****     arp_table[i].state = ETHARP_STATE_STATIC;
 475:../lwip-1.4.1/src/netif/etharp.c ****   } else
 476:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 477:../lwip-1.4.1/src/netif/etharp.c ****   {
 478:../lwip-1.4.1/src/netif/etharp.c ****     /* mark it stable */
 479:../lwip-1.4.1/src/netif/etharp.c ****     arp_table[i].state = ETHARP_STATE_STABLE;
 899              		.loc 1 479 0
 900 0058 97F91F20 		ldrsb	r2, [r7, #31]
 901 005c 3349     		ldr	r1, .L49
 902 005e 1346     		mov	r3, r2
 903 0060 9B00     		lsls	r3, r3, #2
 904 0062 1344     		add	r3, r3, r2
 905 0064 9B00     		lsls	r3, r3, #2
 906 0066 0B44     		add	r3, r3, r1
 907 0068 1033     		adds	r3, r3, #16
 908 006a 0222     		movs	r2, #2
 909 006c 9A70     		strb	r2, [r3, #2]
 480:../lwip-1.4.1/src/netif/etharp.c ****   }
 481:../lwip-1.4.1/src/netif/etharp.c **** 
 482:../lwip-1.4.1/src/netif/etharp.c ****   /* record network interface */
 483:../lwip-1.4.1/src/netif/etharp.c ****   arp_table[i].netif = netif;
 910              		.loc 1 483 0
 911 006e 97F91F20 		ldrsb	r2, [r7, #31]
 912 0072 2E49     		ldr	r1, .L49
 913 0074 1346     		mov	r3, r2
 914 0076 9B00     		lsls	r3, r3, #2
 915 0078 1344     		add	r3, r3, r2
 916 007a 9B00     		lsls	r3, r3, #2
 917 007c 0B44     		add	r3, r3, r1
 918 007e 0833     		adds	r3, r3, #8
 919 0080 FA68     		ldr	r2, [r7, #12]
 920 0082 1A60     		str	r2, [r3]
 484:../lwip-1.4.1/src/netif/etharp.c ****   /* insert in SNMP ARP index tree */
 485:../lwip-1.4.1/src/netif/etharp.c ****   snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
 486:../lwip-1.4.1/src/netif/etharp.c **** 
 487:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16
 488:../lwip-1.4.1/src/netif/etharp.c ****   /* update address */
 489:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 921              		.loc 1 489 0
 922 0084 97F91F20 		ldrsb	r2, [r7, #31]
 923 0088 1346     		mov	r3, r2
 924 008a 9B00     		lsls	r3, r3, #2
 925 008c 1344     		add	r3, r3, r2
 926 008e 9B00     		lsls	r3, r3, #2
 927 0090 0833     		adds	r3, r3, #8
 928 0092 264A     		ldr	r2, .L49
 929 0094 1344     		add	r3, r3, r2
 930 0096 0433     		adds	r3, r3, #4
 931 0098 7A68     		ldr	r2, [r7, #4]
 932 009a 1168     		ldr	r1, [r2]	@ unaligned
 933 009c 1960     		str	r1, [r3]	@ unaligned
 934 009e 9288     		ldrh	r2, [r2, #4]	@ unaligned
 935 00a0 9A80     		strh	r2, [r3, #4]	@ unaligned
 490:../lwip-1.4.1/src/netif/etharp.c ****   /* reset time stamp */
 491:../lwip-1.4.1/src/netif/etharp.c ****   arp_table[i].ctime = 0;
 936              		.loc 1 491 0
 937 00a2 97F91F20 		ldrsb	r2, [r7, #31]
 938 00a6 2149     		ldr	r1, .L49
 939 00a8 1346     		mov	r3, r2
 940 00aa 9B00     		lsls	r3, r3, #2
 941 00ac 1344     		add	r3, r3, r2
 942 00ae 9B00     		lsls	r3, r3, #2
 943 00b0 0B44     		add	r3, r3, r1
 944 00b2 1033     		adds	r3, r3, #16
 945 00b4 0022     		movs	r2, #0
 946 00b6 DA70     		strb	r2, [r3, #3]
 492:../lwip-1.4.1/src/netif/etharp.c ****   /* this is where we will send out queued packets! */
 493:../lwip-1.4.1/src/netif/etharp.c **** #if ARP_QUEUEING
 494:../lwip-1.4.1/src/netif/etharp.c ****   while (arp_table[i].q != NULL) {
 947              		.loc 1 494 0
 948 00b8 26E0     		b	.L47
 949              	.L48:
 950              	.LBB4:
 495:../lwip-1.4.1/src/netif/etharp.c ****     struct pbuf *p;
 496:../lwip-1.4.1/src/netif/etharp.c ****     /* remember remainder of queue */
 497:../lwip-1.4.1/src/netif/etharp.c ****     struct etharp_q_entry *q = arp_table[i].q;
 951              		.loc 1 497 0
 952 00ba 97F91F20 		ldrsb	r2, [r7, #31]
 953 00be 1B49     		ldr	r1, .L49
 954 00c0 1346     		mov	r3, r2
 955 00c2 9B00     		lsls	r3, r3, #2
 956 00c4 1344     		add	r3, r3, r2
 957 00c6 9B00     		lsls	r3, r3, #2
 958 00c8 0B44     		add	r3, r3, r1
 959 00ca 1B68     		ldr	r3, [r3]
 960 00cc BB61     		str	r3, [r7, #24]
 498:../lwip-1.4.1/src/netif/etharp.c ****     /* pop first item off the queue */
 499:../lwip-1.4.1/src/netif/etharp.c ****     arp_table[i].q = q->next;
 961              		.loc 1 499 0
 962 00ce 97F91F20 		ldrsb	r2, [r7, #31]
 963 00d2 BB69     		ldr	r3, [r7, #24]
 964 00d4 1968     		ldr	r1, [r3]
 965 00d6 1548     		ldr	r0, .L49
 966 00d8 1346     		mov	r3, r2
 967 00da 9B00     		lsls	r3, r3, #2
 968 00dc 1344     		add	r3, r3, r2
 969 00de 9B00     		lsls	r3, r3, #2
 970 00e0 0344     		add	r3, r3, r0
 971 00e2 1960     		str	r1, [r3]
 500:../lwip-1.4.1/src/netif/etharp.c ****     /* get the packet pointer */
 501:../lwip-1.4.1/src/netif/etharp.c ****     p = q->p;
 972              		.loc 1 501 0
 973 00e4 BB69     		ldr	r3, [r7, #24]
 974 00e6 5B68     		ldr	r3, [r3, #4]
 975 00e8 7B61     		str	r3, [r7, #20]
 502:../lwip-1.4.1/src/netif/etharp.c ****     /* now queue entry can be freed */
 503:../lwip-1.4.1/src/netif/etharp.c ****     memp_free(MEMP_ARP_QUEUE, q);
 976              		.loc 1 503 0
 977 00ea 0720     		movs	r0, #7
 978 00ec B969     		ldr	r1, [r7, #24]
 979 00ee FFF7FEFF 		bl	memp_free
 504:../lwip-1.4.1/src/netif/etharp.c **** #else /* ARP_QUEUEING */
 505:../lwip-1.4.1/src/netif/etharp.c ****   if (arp_table[i].q != NULL) {
 506:../lwip-1.4.1/src/netif/etharp.c ****     struct pbuf *p = arp_table[i].q;
 507:../lwip-1.4.1/src/netif/etharp.c ****     arp_table[i].q = NULL;
 508:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ARP_QUEUEING */
 509:../lwip-1.4.1/src/netif/etharp.c ****     /* send the queued IP packet */
 510:../lwip-1.4.1/src/netif/etharp.c ****     etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 980              		.loc 1 510 0
 981 00f2 FB68     		ldr	r3, [r7, #12]
 982 00f4 2333     		adds	r3, r3, #35
 983 00f6 F868     		ldr	r0, [r7, #12]
 984 00f8 7969     		ldr	r1, [r7, #20]
 985 00fa 1A46     		mov	r2, r3
 986 00fc 7B68     		ldr	r3, [r7, #4]
 987 00fe FFF7FEFF 		bl	etharp_send_ip
 511:../lwip-1.4.1/src/netif/etharp.c ****     /* free the queued IP packet */
 512:../lwip-1.4.1/src/netif/etharp.c ****     pbuf_free(p);
 988              		.loc 1 512 0
 989 0102 7869     		ldr	r0, [r7, #20]
 990 0104 FFF7FEFF 		bl	pbuf_free
 991              	.L47:
 992              	.LBE4:
 494:../lwip-1.4.1/src/netif/etharp.c ****     struct pbuf *p;
 993              		.loc 1 494 0
 994 0108 97F91F20 		ldrsb	r2, [r7, #31]
 995 010c 0749     		ldr	r1, .L49
 996 010e 1346     		mov	r3, r2
 997 0110 9B00     		lsls	r3, r3, #2
 998 0112 1344     		add	r3, r3, r2
 999 0114 9B00     		lsls	r3, r3, #2
 1000 0116 0B44     		add	r3, r3, r1
 1001 0118 1B68     		ldr	r3, [r3]
 1002 011a 002B     		cmp	r3, #0
 1003 011c CDD1     		bne	.L48
 513:../lwip-1.4.1/src/netif/etharp.c ****   }
 514:../lwip-1.4.1/src/netif/etharp.c ****   return ERR_OK;
 1004              		.loc 1 514 0
 1005 011e 0023     		movs	r3, #0
 1006              	.L45:
 1007 0120 5BB2     		sxtb	r3, r3
 515:../lwip-1.4.1/src/netif/etharp.c **** }
 1008              		.loc 1 515 0
 1009 0122 1846     		mov	r0, r3
 1010 0124 2037     		adds	r7, r7, #32
 1011              		.cfi_def_cfa_offset 8
 1012 0126 BD46     		mov	sp, r7
 1013              		.cfi_def_cfa_register 13
 1014              		@ sp needed
 1015 0128 80BD     		pop	{r7, pc}
 1016              	.L50:
 1017 012a 00BF     		.align	2
 1018              	.L49:
 1019 012c 00000000 		.word	arp_table
 1020              		.cfi_endproc
 1021              	.LFE5:
 1023              		.section	.text.etharp_cleanup_netif,"ax",%progbits
 1024              		.align	2
 1025              		.global	etharp_cleanup_netif
 1026              		.thumb
 1027              		.thumb_func
 1029              	etharp_cleanup_netif:
 1030              	.LFB6:
 516:../lwip-1.4.1/src/netif/etharp.c **** 
 517:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 518:../lwip-1.4.1/src/netif/etharp.c **** /** Add a new static entry to the ARP table. If an entry exists for the
 519:../lwip-1.4.1/src/netif/etharp.c ****  * specified IP address, this entry is overwritten.
 520:../lwip-1.4.1/src/netif/etharp.c ****  * If packets are queued for the specified IP address, they are sent out.
 521:../lwip-1.4.1/src/netif/etharp.c ****  *
 522:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr IP address for the new static entry
 523:../lwip-1.4.1/src/netif/etharp.c ****  * @param ethaddr ethernet address for the new static entry
 524:../lwip-1.4.1/src/netif/etharp.c ****  * @return @see return values of etharp_add_static_entry
 525:../lwip-1.4.1/src/netif/etharp.c ****  */
 526:../lwip-1.4.1/src/netif/etharp.c **** err_t
 527:../lwip-1.4.1/src/netif/etharp.c **** etharp_add_static_entry(ip_addr_t *ipaddr, struct eth_addr *ethaddr)
 528:../lwip-1.4.1/src/netif/etharp.c **** {
 529:../lwip-1.4.1/src/netif/etharp.c ****   struct netif *netif;
 530:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_add_static_entry: %"U16_F".%"U16_F".%"U16_F".
 531:../lwip-1.4.1/src/netif/etharp.c ****     ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
 532:../lwip-1.4.1/src/netif/etharp.c ****     ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
 533:../lwip-1.4.1/src/netif/etharp.c ****     ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
 534:../lwip-1.4.1/src/netif/etharp.c **** 
 535:../lwip-1.4.1/src/netif/etharp.c ****   netif = ip_route(ipaddr);
 536:../lwip-1.4.1/src/netif/etharp.c ****   if (netif == NULL) {
 537:../lwip-1.4.1/src/netif/etharp.c ****     return ERR_RTE;
 538:../lwip-1.4.1/src/netif/etharp.c ****   }
 539:../lwip-1.4.1/src/netif/etharp.c **** 
 540:../lwip-1.4.1/src/netif/etharp.c ****   return etharp_update_arp_entry(netif, ipaddr, ethaddr, ETHARP_FLAG_TRY_HARD | ETHARP_FLAG_STATIC_
 541:../lwip-1.4.1/src/netif/etharp.c **** }
 542:../lwip-1.4.1/src/netif/etharp.c **** 
 543:../lwip-1.4.1/src/netif/etharp.c **** /** Remove a static entry from the ARP table previously added with a call to
 544:../lwip-1.4.1/src/netif/etharp.c ****  * etharp_add_static_entry.
 545:../lwip-1.4.1/src/netif/etharp.c ****  *
 546:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr IP address of the static entry to remove
 547:../lwip-1.4.1/src/netif/etharp.c ****  * @return ERR_OK: entry removed
 548:../lwip-1.4.1/src/netif/etharp.c ****  *         ERR_MEM: entry wasn't found
 549:../lwip-1.4.1/src/netif/etharp.c ****  *         ERR_ARG: entry wasn't a static entry but a dynamic one
 550:../lwip-1.4.1/src/netif/etharp.c ****  */
 551:../lwip-1.4.1/src/netif/etharp.c **** err_t
 552:../lwip-1.4.1/src/netif/etharp.c **** etharp_remove_static_entry(ip_addr_t *ipaddr)
 553:../lwip-1.4.1/src/netif/etharp.c **** {
 554:../lwip-1.4.1/src/netif/etharp.c ****   s8_t i;
 555:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_remove_static_entry: %"U16_F".%"U16_F".%"U16_
 556:../lwip-1.4.1/src/netif/etharp.c ****     ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
 557:../lwip-1.4.1/src/netif/etharp.c **** 
 558:../lwip-1.4.1/src/netif/etharp.c ****   /* find or create ARP entry */
 559:../lwip-1.4.1/src/netif/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
 560:../lwip-1.4.1/src/netif/etharp.c ****   /* bail out if no entry could be found */
 561:../lwip-1.4.1/src/netif/etharp.c ****   if (i < 0) {
 562:../lwip-1.4.1/src/netif/etharp.c ****     return (err_t)i;
 563:../lwip-1.4.1/src/netif/etharp.c ****   }
 564:../lwip-1.4.1/src/netif/etharp.c **** 
 565:../lwip-1.4.1/src/netif/etharp.c ****   if (arp_table[i].state != ETHARP_STATE_STATIC) {
 566:../lwip-1.4.1/src/netif/etharp.c ****     /* entry wasn't a static entry, cannot remove it */
 567:../lwip-1.4.1/src/netif/etharp.c ****     return ERR_ARG;
 568:../lwip-1.4.1/src/netif/etharp.c ****   }
 569:../lwip-1.4.1/src/netif/etharp.c ****   /* entry found, free it */
 570:../lwip-1.4.1/src/netif/etharp.c ****   etharp_free_entry(i);
 571:../lwip-1.4.1/src/netif/etharp.c ****   return ERR_OK;
 572:../lwip-1.4.1/src/netif/etharp.c **** }
 573:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 574:../lwip-1.4.1/src/netif/etharp.c **** 
 575:../lwip-1.4.1/src/netif/etharp.c **** /**
 576:../lwip-1.4.1/src/netif/etharp.c ****  * Remove all ARP table entries of the specified netif.
 577:../lwip-1.4.1/src/netif/etharp.c ****  *
 578:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif points to a network interface
 579:../lwip-1.4.1/src/netif/etharp.c ****  */
 580:../lwip-1.4.1/src/netif/etharp.c **** void etharp_cleanup_netif(struct netif *netif)
 581:../lwip-1.4.1/src/netif/etharp.c **** {
 1031              		.loc 1 581 0
 1032              		.cfi_startproc
 1033              		@ args = 0, pretend = 0, frame = 16
 1034              		@ frame_needed = 1, uses_anonymous_args = 0
 1035 0000 80B5     		push	{r7, lr}
 1036              		.cfi_def_cfa_offset 8
 1037              		.cfi_offset 7, -8
 1038              		.cfi_offset 14, -4
 1039 0002 84B0     		sub	sp, sp, #16
 1040              		.cfi_def_cfa_offset 24
 1041 0004 00AF     		add	r7, sp, #0
 1042              		.cfi_def_cfa_register 7
 1043 0006 7860     		str	r0, [r7, #4]
 582:../lwip-1.4.1/src/netif/etharp.c ****   u8_t i;
 583:../lwip-1.4.1/src/netif/etharp.c **** 
 584:../lwip-1.4.1/src/netif/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 1044              		.loc 1 584 0
 1045 0008 0023     		movs	r3, #0
 1046 000a FB73     		strb	r3, [r7, #15]
 1047 000c 1FE0     		b	.L52
 1048              	.L54:
 1049              	.LBB5:
 585:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 1050              		.loc 1 585 0
 1051 000e FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 1052 0010 1249     		ldr	r1, .L55
 1053 0012 1346     		mov	r3, r2
 1054 0014 9B00     		lsls	r3, r3, #2
 1055 0016 1344     		add	r3, r3, r2
 1056 0018 9B00     		lsls	r3, r3, #2
 1057 001a 0B44     		add	r3, r3, r1
 1058 001c 1033     		adds	r3, r3, #16
 1059 001e 9B78     		ldrb	r3, [r3, #2]
 1060 0020 BB73     		strb	r3, [r7, #14]
 586:../lwip-1.4.1/src/netif/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 1061              		.loc 1 586 0
 1062 0022 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 1063 0024 002B     		cmp	r3, #0
 1064 0026 0FD0     		beq	.L53
 1065              		.loc 1 586 0 is_stmt 0 discriminator 1
 1066 0028 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 1067 002a 0C49     		ldr	r1, .L55
 1068 002c 1346     		mov	r3, r2
 1069 002e 9B00     		lsls	r3, r3, #2
 1070 0030 1344     		add	r3, r3, r2
 1071 0032 9B00     		lsls	r3, r3, #2
 1072 0034 0B44     		add	r3, r3, r1
 1073 0036 0833     		adds	r3, r3, #8
 1074 0038 1A68     		ldr	r2, [r3]
 1075 003a 7B68     		ldr	r3, [r7, #4]
 1076 003c 9A42     		cmp	r2, r3
 1077 003e 03D1     		bne	.L53
 587:../lwip-1.4.1/src/netif/etharp.c ****       etharp_free_entry(i);
 1078              		.loc 1 587 0 is_stmt 1
 1079 0040 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1080 0042 1846     		mov	r0, r3
 1081 0044 FFF7FEFF 		bl	etharp_free_entry
 1082              	.L53:
 1083              	.LBE5:
 584:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 1084              		.loc 1 584 0 discriminator 2
 1085 0048 FB7B     		ldrb	r3, [r7, #15]
 1086 004a 0133     		adds	r3, r3, #1
 1087 004c FB73     		strb	r3, [r7, #15]
 1088              	.L52:
 584:../lwip-1.4.1/src/netif/etharp.c ****     u8_t state = arp_table[i].state;
 1089              		.loc 1 584 0 is_stmt 0 discriminator 1
 1090 004e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1091 0050 092B     		cmp	r3, #9
 1092 0052 DCD9     		bls	.L54
 588:../lwip-1.4.1/src/netif/etharp.c ****     }
 589:../lwip-1.4.1/src/netif/etharp.c ****   }
 590:../lwip-1.4.1/src/netif/etharp.c **** }
 1093              		.loc 1 590 0 is_stmt 1
 1094 0054 1037     		adds	r7, r7, #16
 1095              		.cfi_def_cfa_offset 8
 1096 0056 BD46     		mov	sp, r7
 1097              		.cfi_def_cfa_register 13
 1098              		@ sp needed
 1099 0058 80BD     		pop	{r7, pc}
 1100              	.L56:
 1101 005a 00BF     		.align	2
 1102              	.L55:
 1103 005c 00000000 		.word	arp_table
 1104              		.cfi_endproc
 1105              	.LFE6:
 1107              		.section	.text.etharp_find_addr,"ax",%progbits
 1108              		.align	2
 1109              		.global	etharp_find_addr
 1110              		.thumb
 1111              		.thumb_func
 1113              	etharp_find_addr:
 1114              	.LFB7:
 591:../lwip-1.4.1/src/netif/etharp.c **** 
 592:../lwip-1.4.1/src/netif/etharp.c **** /**
 593:../lwip-1.4.1/src/netif/etharp.c ****  * Finds (stable) ethernet/IP address pair from ARP table
 594:../lwip-1.4.1/src/netif/etharp.c ****  * using interface and IP address index.
 595:../lwip-1.4.1/src/netif/etharp.c ****  * @note the addresses in the ARP table are in network order!
 596:../lwip-1.4.1/src/netif/etharp.c ****  *
 597:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif points to interface index
 598:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr points to the (network order) IP address index
 599:../lwip-1.4.1/src/netif/etharp.c ****  * @param eth_ret points to return pointer
 600:../lwip-1.4.1/src/netif/etharp.c ****  * @param ip_ret points to return pointer
 601:../lwip-1.4.1/src/netif/etharp.c ****  * @return table index if found, -1 otherwise
 602:../lwip-1.4.1/src/netif/etharp.c ****  */
 603:../lwip-1.4.1/src/netif/etharp.c **** s8_t
 604:../lwip-1.4.1/src/netif/etharp.c **** etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
 605:../lwip-1.4.1/src/netif/etharp.c ****          struct eth_addr **eth_ret, ip_addr_t **ip_ret)
 606:../lwip-1.4.1/src/netif/etharp.c **** {
 1115              		.loc 1 606 0
 1116              		.cfi_startproc
 1117              		@ args = 0, pretend = 0, frame = 24
 1118              		@ frame_needed = 1, uses_anonymous_args = 0
 1119 0000 80B5     		push	{r7, lr}
 1120              		.cfi_def_cfa_offset 8
 1121              		.cfi_offset 7, -8
 1122              		.cfi_offset 14, -4
 1123 0002 86B0     		sub	sp, sp, #24
 1124              		.cfi_def_cfa_offset 32
 1125 0004 00AF     		add	r7, sp, #0
 1126              		.cfi_def_cfa_register 7
 1127 0006 F860     		str	r0, [r7, #12]
 1128 0008 B960     		str	r1, [r7, #8]
 1129 000a 7A60     		str	r2, [r7, #4]
 1130 000c 3B60     		str	r3, [r7]
 607:../lwip-1.4.1/src/netif/etharp.c ****   s8_t i;
 608:../lwip-1.4.1/src/netif/etharp.c **** 
 609:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
 610:../lwip-1.4.1/src/netif/etharp.c ****     eth_ret != NULL && ip_ret != NULL);
 611:../lwip-1.4.1/src/netif/etharp.c **** 
 612:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_UNUSED_ARG(netif);
 613:../lwip-1.4.1/src/netif/etharp.c **** 
 614:../lwip-1.4.1/src/netif/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
 1131              		.loc 1 614 0
 1132 000e B868     		ldr	r0, [r7, #8]
 1133 0010 0221     		movs	r1, #2
 1134 0012 FFF7FEFF 		bl	etharp_find_entry
 1135 0016 0346     		mov	r3, r0
 1136 0018 FB75     		strb	r3, [r7, #23]
 615:../lwip-1.4.1/src/netif/etharp.c ****   if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 1137              		.loc 1 615 0
 1138 001a 97F91730 		ldrsb	r3, [r7, #23]
 1139 001e 002B     		cmp	r3, #0
 1140 0020 24DB     		blt	.L58
 1141              		.loc 1 615 0 is_stmt 0 discriminator 1
 1142 0022 97F91720 		ldrsb	r2, [r7, #23]
 1143 0026 1449     		ldr	r1, .L60
 1144 0028 1346     		mov	r3, r2
 1145 002a 9B00     		lsls	r3, r3, #2
 1146 002c 1344     		add	r3, r3, r2
 1147 002e 9B00     		lsls	r3, r3, #2
 1148 0030 0B44     		add	r3, r3, r1
 1149 0032 1033     		adds	r3, r3, #16
 1150 0034 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1151 0036 012B     		cmp	r3, #1
 1152 0038 18D9     		bls	.L58
 616:../lwip-1.4.1/src/netif/etharp.c ****       *eth_ret = &arp_table[i].ethaddr;
 1153              		.loc 1 616 0 is_stmt 1
 1154 003a 97F91720 		ldrsb	r2, [r7, #23]
 1155 003e 1346     		mov	r3, r2
 1156 0040 9B00     		lsls	r3, r3, #2
 1157 0042 1344     		add	r3, r3, r2
 1158 0044 9B00     		lsls	r3, r3, #2
 1159 0046 0833     		adds	r3, r3, #8
 1160 0048 0B4A     		ldr	r2, .L60
 1161 004a 1344     		add	r3, r3, r2
 1162 004c 1A1D     		adds	r2, r3, #4
 1163 004e 7B68     		ldr	r3, [r7, #4]
 1164 0050 1A60     		str	r2, [r3]
 617:../lwip-1.4.1/src/netif/etharp.c ****       *ip_ret = &arp_table[i].ipaddr;
 1165              		.loc 1 617 0
 1166 0052 97F91720 		ldrsb	r2, [r7, #23]
 1167 0056 1346     		mov	r3, r2
 1168 0058 9B00     		lsls	r3, r3, #2
 1169 005a 1344     		add	r3, r3, r2
 1170 005c 9B00     		lsls	r3, r3, #2
 1171 005e 064A     		ldr	r2, .L60
 1172 0060 1344     		add	r3, r3, r2
 1173 0062 1A1D     		adds	r2, r3, #4
 1174 0064 3B68     		ldr	r3, [r7]
 1175 0066 1A60     		str	r2, [r3]
 618:../lwip-1.4.1/src/netif/etharp.c ****       return i;
 1176              		.loc 1 618 0
 1177 0068 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1178 006a 00E0     		b	.L59
 1179              	.L58:
 619:../lwip-1.4.1/src/netif/etharp.c ****   }
 620:../lwip-1.4.1/src/netif/etharp.c ****   return -1;
 1180              		.loc 1 620 0
 1181 006c FF23     		movs	r3, #255
 1182              	.L59:
 1183 006e 5BB2     		sxtb	r3, r3
 621:../lwip-1.4.1/src/netif/etharp.c **** }
 1184              		.loc 1 621 0
 1185 0070 1846     		mov	r0, r3
 1186 0072 1837     		adds	r7, r7, #24
 1187              		.cfi_def_cfa_offset 8
 1188 0074 BD46     		mov	sp, r7
 1189              		.cfi_def_cfa_register 13
 1190              		@ sp needed
 1191 0076 80BD     		pop	{r7, pc}
 1192              	.L61:
 1193              		.align	2
 1194              	.L60:
 1195 0078 00000000 		.word	arp_table
 1196              		.cfi_endproc
 1197              	.LFE7:
 1199              		.section	.text.etharp_ip_input,"ax",%progbits
 1200              		.align	2
 1201              		.thumb
 1202              		.thumb_func
 1204              	etharp_ip_input:
 1205              	.LFB8:
 622:../lwip-1.4.1/src/netif/etharp.c **** 
 623:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_TRUST_IP_MAC
 624:../lwip-1.4.1/src/netif/etharp.c **** /**
 625:../lwip-1.4.1/src/netif/etharp.c ****  * Updates the ARP table using the given IP packet.
 626:../lwip-1.4.1/src/netif/etharp.c ****  *
 627:../lwip-1.4.1/src/netif/etharp.c ****  * Uses the incoming IP packet's source address to update the
 628:../lwip-1.4.1/src/netif/etharp.c ****  * ARP cache for the local network. The function does not alter
 629:../lwip-1.4.1/src/netif/etharp.c ****  * or free the packet. This function must be called before the
 630:../lwip-1.4.1/src/netif/etharp.c ****  * packet p is passed to the IP layer.
 631:../lwip-1.4.1/src/netif/etharp.c ****  *
 632:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif The lwIP network interface on which the IP packet pbuf arrived.
 633:../lwip-1.4.1/src/netif/etharp.c ****  * @param p The IP packet that arrived on netif.
 634:../lwip-1.4.1/src/netif/etharp.c ****  *
 635:../lwip-1.4.1/src/netif/etharp.c ****  * @return NULL
 636:../lwip-1.4.1/src/netif/etharp.c ****  *
 637:../lwip-1.4.1/src/netif/etharp.c ****  * @see pbuf_free()
 638:../lwip-1.4.1/src/netif/etharp.c ****  */
 639:../lwip-1.4.1/src/netif/etharp.c **** static void
 640:../lwip-1.4.1/src/netif/etharp.c **** etharp_ip_input(struct netif *netif, struct pbuf *p)
 641:../lwip-1.4.1/src/netif/etharp.c **** {
 1206              		.loc 1 641 0
 1207              		.cfi_startproc
 1208              		@ args = 0, pretend = 0, frame = 24
 1209              		@ frame_needed = 1, uses_anonymous_args = 0
 1210 0000 80B5     		push	{r7, lr}
 1211              		.cfi_def_cfa_offset 8
 1212              		.cfi_offset 7, -8
 1213              		.cfi_offset 14, -4
 1214 0002 86B0     		sub	sp, sp, #24
 1215              		.cfi_def_cfa_offset 32
 1216 0004 00AF     		add	r7, sp, #0
 1217              		.cfi_def_cfa_register 7
 1218 0006 7860     		str	r0, [r7, #4]
 1219 0008 3960     		str	r1, [r7]
 642:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_hdr *ethhdr;
 643:../lwip-1.4.1/src/netif/etharp.c ****   struct ip_hdr *iphdr;
 644:../lwip-1.4.1/src/netif/etharp.c ****   ip_addr_t iphdr_src;
 645:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 1220              		.loc 1 645 0
 1221 000a 7B68     		ldr	r3, [r7, #4]
 1222 000c 002B     		cmp	r3, #0
 1223 000e 00D1     		bne	.L63
 1224 0010 1CE0     		b	.L62
 1225              	.L63:
 646:../lwip-1.4.1/src/netif/etharp.c **** 
 647:../lwip-1.4.1/src/netif/etharp.c ****   /* Only insert an entry if the source IP address of the
 648:../lwip-1.4.1/src/netif/etharp.c ****      incoming IP packet comes from a host on the local network. */
 649:../lwip-1.4.1/src/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 1226              		.loc 1 649 0
 1227 0012 3B68     		ldr	r3, [r7]
 1228 0014 5B68     		ldr	r3, [r3, #4]
 1229 0016 7B61     		str	r3, [r7, #20]
 650:../lwip-1.4.1/src/netif/etharp.c ****   iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 1230              		.loc 1 650 0
 1231 0018 7B69     		ldr	r3, [r7, #20]
 1232 001a 0E33     		adds	r3, r3, #14
 1233 001c 3B61     		str	r3, [r7, #16]
 651:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_VLAN
 652:../lwip-1.4.1/src/netif/etharp.c ****   if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
 653:../lwip-1.4.1/src/netif/etharp.c ****     iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
 654:../lwip-1.4.1/src/netif/etharp.c ****   }
 655:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_VLAN */
 656:../lwip-1.4.1/src/netif/etharp.c **** 
 657:../lwip-1.4.1/src/netif/etharp.c ****   ip_addr_copy(iphdr_src, iphdr->src);
 1234              		.loc 1 657 0
 1235 001e 3B69     		ldr	r3, [r7, #16]
 1236 0020 DB68     		ldr	r3, [r3, #12]	@ unaligned
 1237 0022 FB60     		str	r3, [r7, #12]
 658:../lwip-1.4.1/src/netif/etharp.c **** 
 659:../lwip-1.4.1/src/netif/etharp.c ****   /* source is not on the local network? */
 660:../lwip-1.4.1/src/netif/etharp.c ****   if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
 1238              		.loc 1 660 0
 1239 0024 FA68     		ldr	r2, [r7, #12]
 1240 0026 7B68     		ldr	r3, [r7, #4]
 1241 0028 5B68     		ldr	r3, [r3, #4]
 1242 002a 5A40     		eors	r2, r2, r3
 1243 002c 7B68     		ldr	r3, [r7, #4]
 1244 002e 9B68     		ldr	r3, [r3, #8]
 1245 0030 1340     		ands	r3, r3, r2
 1246 0032 002B     		cmp	r3, #0
 1247 0034 00D0     		beq	.L65
 661:../lwip-1.4.1/src/netif/etharp.c ****     /* do nothing */
 662:../lwip-1.4.1/src/netif/etharp.c ****     return;
 1248              		.loc 1 662 0
 1249 0036 09E0     		b	.L62
 1250              	.L65:
 663:../lwip-1.4.1/src/netif/etharp.c ****   }
 664:../lwip-1.4.1/src/netif/etharp.c **** 
 665:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
 666:../lwip-1.4.1/src/netif/etharp.c ****   /* update the source IP address in the cache, if present */
 667:../lwip-1.4.1/src/netif/etharp.c ****   /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
 668:../lwip-1.4.1/src/netif/etharp.c ****    * back soon (for example, if the destination IP address is ours. */
 669:../lwip-1.4.1/src/netif/etharp.c ****   etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
 1251              		.loc 1 669 0
 1252 0038 7B69     		ldr	r3, [r7, #20]
 1253 003a 0633     		adds	r3, r3, #6
 1254 003c 07F10C02 		add	r2, r7, #12
 1255 0040 7868     		ldr	r0, [r7, #4]
 1256 0042 1146     		mov	r1, r2
 1257 0044 1A46     		mov	r2, r3
 1258 0046 0223     		movs	r3, #2
 1259 0048 FFF7FEFF 		bl	etharp_update_arp_entry
 1260              	.L62:
 670:../lwip-1.4.1/src/netif/etharp.c **** }
 1261              		.loc 1 670 0
 1262 004c 1837     		adds	r7, r7, #24
 1263              		.cfi_def_cfa_offset 8
 1264 004e BD46     		mov	sp, r7
 1265              		.cfi_def_cfa_register 13
 1266              		@ sp needed
 1267 0050 80BD     		pop	{r7, pc}
 1268              		.cfi_endproc
 1269              	.LFE8:
 1271 0052 00BF     		.section	.text.etharp_arp_input,"ax",%progbits
 1272              		.align	2
 1273              		.thumb
 1274              		.thumb_func
 1276              	etharp_arp_input:
 1277              	.LFB9:
 671:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_TRUST_IP_MAC */
 672:../lwip-1.4.1/src/netif/etharp.c **** 
 673:../lwip-1.4.1/src/netif/etharp.c **** /**
 674:../lwip-1.4.1/src/netif/etharp.c ****  * Responds to ARP requests to us. Upon ARP replies to us, add entry to cache  
 675:../lwip-1.4.1/src/netif/etharp.c ****  * send out queued IP packets. Updates cache with snooped address pairs.
 676:../lwip-1.4.1/src/netif/etharp.c ****  *
 677:../lwip-1.4.1/src/netif/etharp.c ****  * Should be called for incoming ARP packets. The pbuf in the argument
 678:../lwip-1.4.1/src/netif/etharp.c ****  * is freed by this function.
 679:../lwip-1.4.1/src/netif/etharp.c ****  *
 680:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif The lwIP network interface on which the ARP packet pbuf arrived.
 681:../lwip-1.4.1/src/netif/etharp.c ****  * @param ethaddr Ethernet address of netif.
 682:../lwip-1.4.1/src/netif/etharp.c ****  * @param p The ARP packet that arrived on netif. Is freed by this function.
 683:../lwip-1.4.1/src/netif/etharp.c ****  *
 684:../lwip-1.4.1/src/netif/etharp.c ****  * @return NULL
 685:../lwip-1.4.1/src/netif/etharp.c ****  *
 686:../lwip-1.4.1/src/netif/etharp.c ****  * @see pbuf_free()
 687:../lwip-1.4.1/src/netif/etharp.c ****  */
 688:../lwip-1.4.1/src/netif/etharp.c **** static void
 689:../lwip-1.4.1/src/netif/etharp.c **** etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
 690:../lwip-1.4.1/src/netif/etharp.c **** {
 1278              		.loc 1 690 0
 1279              		.cfi_startproc
 1280              		@ args = 0, pretend = 0, frame = 40
 1281              		@ frame_needed = 1, uses_anonymous_args = 0
 1282 0000 80B5     		push	{r7, lr}
 1283              		.cfi_def_cfa_offset 8
 1284              		.cfi_offset 7, -8
 1285              		.cfi_offset 14, -4
 1286 0002 8AB0     		sub	sp, sp, #40
 1287              		.cfi_def_cfa_offset 48
 1288 0004 00AF     		add	r7, sp, #0
 1289              		.cfi_def_cfa_register 7
 1290 0006 F860     		str	r0, [r7, #12]
 1291 0008 B960     		str	r1, [r7, #8]
 1292 000a 7A60     		str	r2, [r7, #4]
 691:../lwip-1.4.1/src/netif/etharp.c ****   struct etharp_hdr *hdr;
 692:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_hdr *ethhdr;
 693:../lwip-1.4.1/src/netif/etharp.c ****   /* these are aligned properly, whereas the ARP header fields might not be */
 694:../lwip-1.4.1/src/netif/etharp.c ****   ip_addr_t sipaddr, dipaddr;
 695:../lwip-1.4.1/src/netif/etharp.c ****   u8_t for_us;
 696:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
 697:../lwip-1.4.1/src/netif/etharp.c ****   const u8_t * ethdst_hwaddr;
 698:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 699:../lwip-1.4.1/src/netif/etharp.c **** 
 700:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 1293              		.loc 1 700 0
 1294 000c FB68     		ldr	r3, [r7, #12]
 1295 000e 002B     		cmp	r3, #0
 1296 0010 00D1     		bne	.L68
 1297 0012 D7E0     		b	.L67
 1298              	.L68:
 701:../lwip-1.4.1/src/netif/etharp.c **** 
 702:../lwip-1.4.1/src/netif/etharp.c ****   /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
 703:../lwip-1.4.1/src/netif/etharp.c ****      since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
 704:../lwip-1.4.1/src/netif/etharp.c ****   if (p->len < SIZEOF_ETHARP_PACKET) {
 1299              		.loc 1 704 0
 1300 0014 7B68     		ldr	r3, [r7, #4]
 1301 0016 5B89     		ldrh	r3, [r3, #10]
 1302 0018 292B     		cmp	r3, #41
 1303 001a 0DD8     		bhi	.L70
 705:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
 706:../lwip-1.4.1/src/netif/etharp.c ****       ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
 707:../lwip-1.4.1/src/netif/etharp.c ****       (s16_t)SIZEOF_ETHARP_PACKET));
 708:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.lenerr);
 1304              		.loc 1 708 0
 1305 001c 6B4B     		ldr	r3, .L88
 1306 001e 5B6C     		ldr	r3, [r3, #68]
 1307 0020 0133     		adds	r3, r3, #1
 1308 0022 6A4A     		ldr	r2, .L88
 1309 0024 5364     		str	r3, [r2, #68]
 709:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.drop);
 1310              		.loc 1 709 0
 1311 0026 694B     		ldr	r3, .L88
 1312 0028 DB6B     		ldr	r3, [r3, #60]
 1313 002a 0133     		adds	r3, r3, #1
 1314 002c 674A     		ldr	r2, .L88
 1315 002e D363     		str	r3, [r2, #60]
 710:../lwip-1.4.1/src/netif/etharp.c ****     pbuf_free(p);
 1316              		.loc 1 710 0
 1317 0030 7868     		ldr	r0, [r7, #4]
 1318 0032 FFF7FEFF 		bl	pbuf_free
 711:../lwip-1.4.1/src/netif/etharp.c ****     return;
 1319              		.loc 1 711 0
 1320 0036 C5E0     		b	.L67
 1321              	.L70:
 712:../lwip-1.4.1/src/netif/etharp.c ****   }
 713:../lwip-1.4.1/src/netif/etharp.c **** 
 714:../lwip-1.4.1/src/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 1322              		.loc 1 714 0
 1323 0038 7B68     		ldr	r3, [r7, #4]
 1324 003a 5B68     		ldr	r3, [r3, #4]
 1325 003c 3B62     		str	r3, [r7, #32]
 715:../lwip-1.4.1/src/netif/etharp.c ****   hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 1326              		.loc 1 715 0
 1327 003e 3B6A     		ldr	r3, [r7, #32]
 1328 0040 0E33     		adds	r3, r3, #14
 1329 0042 FB61     		str	r3, [r7, #28]
 716:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_VLAN
 717:../lwip-1.4.1/src/netif/etharp.c ****   if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
 718:../lwip-1.4.1/src/netif/etharp.c ****     hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
 719:../lwip-1.4.1/src/netif/etharp.c ****   }
 720:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_VLAN */
 721:../lwip-1.4.1/src/netif/etharp.c **** 
 722:../lwip-1.4.1/src/netif/etharp.c ****   /* RFC 826 "Packet Reception": */
 723:../lwip-1.4.1/src/netif/etharp.c ****   if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 1330              		.loc 1 723 0
 1331 0044 FB69     		ldr	r3, [r7, #28]
 1332 0046 1B88     		ldrh	r3, [r3]	@ unaligned
 1333 0048 9BB2     		uxth	r3, r3
 1334 004a B3F5807F 		cmp	r3, #256
 1335 004e 0CD1     		bne	.L71
 724:../lwip-1.4.1/src/netif/etharp.c ****       (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 1336              		.loc 1 724 0 discriminator 1
 1337 0050 FB69     		ldr	r3, [r7, #28]
 1338 0052 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 723:../lwip-1.4.1/src/netif/etharp.c ****       (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 1339              		.loc 1 723 0 discriminator 1
 1340 0054 062B     		cmp	r3, #6
 1341 0056 08D1     		bne	.L71
 725:../lwip-1.4.1/src/netif/etharp.c ****       (hdr->protolen != sizeof(ip_addr_t)) ||
 1342              		.loc 1 725 0
 1343 0058 FB69     		ldr	r3, [r7, #28]
 1344 005a 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 724:../lwip-1.4.1/src/netif/etharp.c ****       (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 1345              		.loc 1 724 0
 1346 005c 042B     		cmp	r3, #4
 1347 005e 04D1     		bne	.L71
 726:../lwip-1.4.1/src/netif/etharp.c ****       (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 1348              		.loc 1 726 0
 1349 0060 FB69     		ldr	r3, [r7, #28]
 1350 0062 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 1351 0064 9BB2     		uxth	r3, r3
 725:../lwip-1.4.1/src/netif/etharp.c ****       (hdr->protolen != sizeof(ip_addr_t)) ||
 1352              		.loc 1 725 0
 1353 0066 082B     		cmp	r3, #8
 1354 0068 0DD0     		beq	.L72
 1355              	.L71:
 727:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
 728:../lwip-1.4.1/src/netif/etharp.c ****       ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%
 729:../lwip-1.4.1/src/netif/etharp.c ****       hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
 730:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.proterr);
 1356              		.loc 1 730 0
 1357 006a 584B     		ldr	r3, .L88
 1358 006c 1B6D     		ldr	r3, [r3, #80]
 1359 006e 0133     		adds	r3, r3, #1
 1360 0070 564A     		ldr	r2, .L88
 1361 0072 1365     		str	r3, [r2, #80]
 731:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.drop);
 1362              		.loc 1 731 0
 1363 0074 554B     		ldr	r3, .L88
 1364 0076 DB6B     		ldr	r3, [r3, #60]
 1365 0078 0133     		adds	r3, r3, #1
 1366 007a 544A     		ldr	r2, .L88
 1367 007c D363     		str	r3, [r2, #60]
 732:../lwip-1.4.1/src/netif/etharp.c ****     pbuf_free(p);
 1368              		.loc 1 732 0
 1369 007e 7868     		ldr	r0, [r7, #4]
 1370 0080 FFF7FEFF 		bl	pbuf_free
 733:../lwip-1.4.1/src/netif/etharp.c ****     return;
 1371              		.loc 1 733 0
 1372 0084 9EE0     		b	.L67
 1373              	.L72:
 734:../lwip-1.4.1/src/netif/etharp.c ****   }
 735:../lwip-1.4.1/src/netif/etharp.c ****   ETHARP_STATS_INC(etharp.recv);
 1374              		.loc 1 735 0
 1375 0086 514B     		ldr	r3, .L88
 1376 0088 5B6B     		ldr	r3, [r3, #52]
 1377 008a 0133     		adds	r3, r3, #1
 1378 008c 4F4A     		ldr	r2, .L88
 1379 008e 5363     		str	r3, [r2, #52]
 736:../lwip-1.4.1/src/netif/etharp.c **** 
 737:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
 738:../lwip-1.4.1/src/netif/etharp.c ****   /* We have to check if a host already has configured our random
 739:../lwip-1.4.1/src/netif/etharp.c ****    * created link local address and continously check if there is
 740:../lwip-1.4.1/src/netif/etharp.c ****    * a host with this IP-address so we can detect collisions */
 741:../lwip-1.4.1/src/netif/etharp.c ****   autoip_arp_reply(netif, hdr);
 742:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 743:../lwip-1.4.1/src/netif/etharp.c **** 
 744:../lwip-1.4.1/src/netif/etharp.c ****   /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
 745:../lwip-1.4.1/src/netif/etharp.c ****    * structure packing (not using structure copy which breaks strict-aliasing rules). */
 746:../lwip-1.4.1/src/netif/etharp.c ****   IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 1380              		.loc 1 746 0
 1381 0090 FB69     		ldr	r3, [r7, #28]
 1382 0092 0E33     		adds	r3, r3, #14
 1383 0094 07F11802 		add	r2, r7, #24
 1384 0098 1046     		mov	r0, r2
 1385 009a 1946     		mov	r1, r3
 1386 009c 0422     		movs	r2, #4
 1387 009e FFF7FEFF 		bl	memcpy
 747:../lwip-1.4.1/src/netif/etharp.c ****   IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 1388              		.loc 1 747 0
 1389 00a2 FB69     		ldr	r3, [r7, #28]
 1390 00a4 1833     		adds	r3, r3, #24
 1391 00a6 07F11402 		add	r2, r7, #20
 1392 00aa 1046     		mov	r0, r2
 1393 00ac 1946     		mov	r1, r3
 1394 00ae 0422     		movs	r2, #4
 1395 00b0 FFF7FEFF 		bl	memcpy
 748:../lwip-1.4.1/src/netif/etharp.c **** 
 749:../lwip-1.4.1/src/netif/etharp.c ****   /* this interface is not configured? */
 750:../lwip-1.4.1/src/netif/etharp.c ****   if (ip_addr_isany(&netif->ip_addr)) {
 1396              		.loc 1 750 0
 1397 00b4 FB68     		ldr	r3, [r7, #12]
 1398 00b6 0433     		adds	r3, r3, #4
 1399 00b8 002B     		cmp	r3, #0
 1400 00ba 03D0     		beq	.L73
 1401              		.loc 1 750 0 is_stmt 0 discriminator 1
 1402 00bc FB68     		ldr	r3, [r7, #12]
 1403 00be 5B68     		ldr	r3, [r3, #4]
 1404 00c0 002B     		cmp	r3, #0
 1405 00c2 03D1     		bne	.L74
 1406              	.L73:
 751:../lwip-1.4.1/src/netif/etharp.c ****     for_us = 0;
 1407              		.loc 1 751 0 is_stmt 1
 1408 00c4 0023     		movs	r3, #0
 1409 00c6 87F82730 		strb	r3, [r7, #39]
 1410 00ca 09E0     		b	.L75
 1411              	.L74:
 752:../lwip-1.4.1/src/netif/etharp.c ****   } else {
 753:../lwip-1.4.1/src/netif/etharp.c ****     /* ARP packet directed to us? */
 754:../lwip-1.4.1/src/netif/etharp.c ****     for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 1412              		.loc 1 754 0
 1413 00cc 7A69     		ldr	r2, [r7, #20]
 1414 00ce FB68     		ldr	r3, [r7, #12]
 1415 00d0 5B68     		ldr	r3, [r3, #4]
 1416 00d2 9A42     		cmp	r2, r3
 1417 00d4 0CBF     		ite	eq
 1418 00d6 0123     		moveq	r3, #1
 1419 00d8 0023     		movne	r3, #0
 1420 00da DBB2     		uxtb	r3, r3
 1421 00dc 87F82730 		strb	r3, [r7, #39]
 1422              	.L75:
 755:../lwip-1.4.1/src/netif/etharp.c ****   }
 756:../lwip-1.4.1/src/netif/etharp.c **** 
 757:../lwip-1.4.1/src/netif/etharp.c ****   /* ARP message directed to us?
 758:../lwip-1.4.1/src/netif/etharp.c ****       -> add IP address in ARP cache; assume requester wants to talk to us,
 759:../lwip-1.4.1/src/netif/etharp.c ****          can result in directly sending the queued packets for this host.
 760:../lwip-1.4.1/src/netif/etharp.c ****      ARP message not directed to us?
 761:../lwip-1.4.1/src/netif/etharp.c ****       ->  update the source IP address in the cache, if present */
 762:../lwip-1.4.1/src/netif/etharp.c ****   etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 1423              		.loc 1 762 0
 1424 00e0 FB69     		ldr	r3, [r7, #28]
 1425 00e2 03F10802 		add	r2, r3, #8
 1426 00e6 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 1427 00ea 002B     		cmp	r3, #0
 1428 00ec 01D0     		beq	.L76
 1429              		.loc 1 762 0 is_stmt 0 discriminator 1
 1430 00ee 0123     		movs	r3, #1
 1431 00f0 00E0     		b	.L77
 1432              	.L76:
 1433              		.loc 1 762 0 discriminator 2
 1434 00f2 0223     		movs	r3, #2
 1435              	.L77:
 1436              		.loc 1 762 0 discriminator 4
 1437 00f4 07F11801 		add	r1, r7, #24
 1438 00f8 F868     		ldr	r0, [r7, #12]
 1439 00fa FFF7FEFF 		bl	etharp_update_arp_entry
 763:../lwip-1.4.1/src/netif/etharp.c ****                    for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
 764:../lwip-1.4.1/src/netif/etharp.c **** 
 765:../lwip-1.4.1/src/netif/etharp.c ****   /* now act on the message itself */
 766:../lwip-1.4.1/src/netif/etharp.c ****   switch (hdr->opcode) {
 1440              		.loc 1 766 0 is_stmt 1 discriminator 4
 1441 00fe FB69     		ldr	r3, [r7, #28]
 1442 0100 DB88     		ldrh	r3, [r3, #6]	@ unaligned
 1443 0102 9BB2     		uxth	r3, r3
 1444 0104 B3F5807F 		cmp	r3, #256
 1445 0108 03D0     		beq	.L79
 1446 010a B3F5007F 		cmp	r3, #512
 1447 010e 55D0     		beq	.L87
 1448              		.loc 1 766 0 is_stmt 0
 1449 0110 4EE0     		b	.L86
 1450              	.L79:
 767:../lwip-1.4.1/src/netif/etharp.c ****   /* ARP request? */
 768:../lwip-1.4.1/src/netif/etharp.c ****   case PP_HTONS(ARP_REQUEST):
 769:../lwip-1.4.1/src/netif/etharp.c ****     /* ARP request. If it asked for our address, we send out a
 770:../lwip-1.4.1/src/netif/etharp.c ****      * reply. In any case, we time-stamp any existing ARP entry,
 771:../lwip-1.4.1/src/netif/etharp.c ****      * and possiby send out an IP packet that was queued on it. */
 772:../lwip-1.4.1/src/netif/etharp.c **** 
 773:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
 774:../lwip-1.4.1/src/netif/etharp.c ****     /* ARP request for our address? */
 775:../lwip-1.4.1/src/netif/etharp.c ****     if (for_us) {
 1451              		.loc 1 775 0 is_stmt 1
 1452 0112 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 1453 0116 002B     		cmp	r3, #0
 1454 0118 40D0     		beq	.L81
 776:../lwip-1.4.1/src/netif/etharp.c **** 
 777:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for ou
 778:../lwip-1.4.1/src/netif/etharp.c ****       /* Re-use pbuf to send ARP reply.
 779:../lwip-1.4.1/src/netif/etharp.c ****          Since we are re-using an existing pbuf, we can't call etharp_raw since
 780:../lwip-1.4.1/src/netif/etharp.c ****          that would allocate a new pbuf. */
 781:../lwip-1.4.1/src/netif/etharp.c ****       hdr->opcode = htons(ARP_REPLY);
 1455              		.loc 1 781 0
 1456 011a 0220     		movs	r0, #2
 1457 011c FFF7FEFF 		bl	lwip_htons
 1458 0120 0346     		mov	r3, r0
 1459 0122 1A46     		mov	r2, r3
 1460 0124 FB69     		ldr	r3, [r7, #28]
 1461 0126 DA80     		strh	r2, [r3, #6]	@ unaligned
 782:../lwip-1.4.1/src/netif/etharp.c **** 
 783:../lwip-1.4.1/src/netif/etharp.c ****       IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 1462              		.loc 1 783 0
 1463 0128 FB69     		ldr	r3, [r7, #28]
 1464 012a 03F11802 		add	r2, r3, #24
 1465 012e FB69     		ldr	r3, [r7, #28]
 1466 0130 0E33     		adds	r3, r3, #14
 1467 0132 1046     		mov	r0, r2
 1468 0134 1946     		mov	r1, r3
 1469 0136 0422     		movs	r2, #4
 1470 0138 FFF7FEFF 		bl	memcpy
 784:../lwip-1.4.1/src/netif/etharp.c ****       IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 1471              		.loc 1 784 0
 1472 013c FB69     		ldr	r3, [r7, #28]
 1473 013e 03F10E02 		add	r2, r3, #14
 1474 0142 FB68     		ldr	r3, [r7, #12]
 1475 0144 0433     		adds	r3, r3, #4
 1476 0146 1046     		mov	r0, r2
 1477 0148 1946     		mov	r1, r3
 1478 014a 0422     		movs	r2, #4
 1479 014c FFF7FEFF 		bl	memcpy
 785:../lwip-1.4.1/src/netif/etharp.c **** 
 786:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 787:../lwip-1.4.1/src/netif/etharp.c ****                   (netif->hwaddr_len == ETHARP_HWADDR_LEN));
 788:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
 789:../lwip-1.4.1/src/netif/etharp.c ****       /* If we are using Link-Local, all ARP packets that contain a Link-Local
 790:../lwip-1.4.1/src/netif/etharp.c ****        * 'sender IP address' MUST be sent using link-layer broadcast instead of
 791:../lwip-1.4.1/src/netif/etharp.c ****        * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
 792:../lwip-1.4.1/src/netif/etharp.c ****       ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwa
 793:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 794:../lwip-1.4.1/src/netif/etharp.c **** 
 795:../lwip-1.4.1/src/netif/etharp.c ****       ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 1480              		.loc 1 795 0
 1481 0150 FB69     		ldr	r3, [r7, #28]
 1482 0152 03F11202 		add	r2, r3, #18
 1483 0156 FB69     		ldr	r3, [r7, #28]
 1484 0158 0833     		adds	r3, r3, #8
 1485 015a 1046     		mov	r0, r2
 1486 015c 1946     		mov	r1, r3
 1487 015e 0622     		movs	r2, #6
 1488 0160 FFF7FEFF 		bl	memcpy
 796:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
 797:../lwip-1.4.1/src/netif/etharp.c ****       ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
 798:../lwip-1.4.1/src/netif/etharp.c **** #else  /* LWIP_AUTOIP */
 799:../lwip-1.4.1/src/netif/etharp.c ****       ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 1489              		.loc 1 799 0
 1490 0164 3A6A     		ldr	r2, [r7, #32]
 1491 0166 FB69     		ldr	r3, [r7, #28]
 1492 0168 0833     		adds	r3, r3, #8
 1493 016a 1046     		mov	r0, r2
 1494 016c 1946     		mov	r1, r3
 1495 016e 0622     		movs	r2, #6
 1496 0170 FFF7FEFF 		bl	memcpy
 800:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 801:../lwip-1.4.1/src/netif/etharp.c ****       ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 1497              		.loc 1 801 0
 1498 0174 FB69     		ldr	r3, [r7, #28]
 1499 0176 0833     		adds	r3, r3, #8
 1500 0178 1846     		mov	r0, r3
 1501 017a B968     		ldr	r1, [r7, #8]
 1502 017c 0622     		movs	r2, #6
 1503 017e FFF7FEFF 		bl	memcpy
 802:../lwip-1.4.1/src/netif/etharp.c ****       ETHADDR16_COPY(&ethhdr->src, ethaddr);
 1504              		.loc 1 802 0
 1505 0182 3B6A     		ldr	r3, [r7, #32]
 1506 0184 0633     		adds	r3, r3, #6
 1507 0186 1846     		mov	r0, r3
 1508 0188 B968     		ldr	r1, [r7, #8]
 1509 018a 0622     		movs	r2, #6
 1510 018c FFF7FEFF 		bl	memcpy
 803:../lwip-1.4.1/src/netif/etharp.c **** 
 804:../lwip-1.4.1/src/netif/etharp.c ****       /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
 805:../lwip-1.4.1/src/netif/etharp.c ****          are already correct, we tested that before */
 806:../lwip-1.4.1/src/netif/etharp.c **** 
 807:../lwip-1.4.1/src/netif/etharp.c ****       /* return ARP reply */
 808:../lwip-1.4.1/src/netif/etharp.c ****       netif->linkoutput(netif, p);
 1511              		.loc 1 808 0
 1512 0190 FB68     		ldr	r3, [r7, #12]
 1513 0192 9B69     		ldr	r3, [r3, #24]
 1514 0194 F868     		ldr	r0, [r7, #12]
 1515 0196 7968     		ldr	r1, [r7, #4]
 1516 0198 9847     		blx	r3
 1517 019a 08E0     		b	.L82
 1518              	.L81:
 809:../lwip-1.4.1/src/netif/etharp.c ****     /* we are not configured? */
 810:../lwip-1.4.1/src/netif/etharp.c ****     } else if (ip_addr_isany(&netif->ip_addr)) {
 1519              		.loc 1 810 0
 1520 019c FB68     		ldr	r3, [r7, #12]
 1521 019e 0433     		adds	r3, r3, #4
 1522 01a0 002B     		cmp	r3, #0
 1523 01a2 03D0     		beq	.L83
 1524              		.loc 1 810 0 is_stmt 0 discriminator 1
 1525 01a4 FB68     		ldr	r3, [r7, #12]
 1526 01a6 5B68     		ldr	r3, [r3, #4]
 1527 01a8 002B     		cmp	r3, #0
 1528 01aa 00D1     		bne	.L82
 1529              	.L83:
 811:../lwip-1.4.1/src/netif/etharp.c ****       /* { for_us == 0 and netif->ip_addr.addr == 0 } */
 812:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP reque
 1530              		.loc 1 812 0 is_stmt 1
 1531 01ac 00BF     		nop
 1532              	.L82:
 813:../lwip-1.4.1/src/netif/etharp.c ****     /* request was not directed to us */
 814:../lwip-1.4.1/src/netif/etharp.c ****     } else {
 815:../lwip-1.4.1/src/netif/etharp.c ****       /* { for_us == 0 and netif->ip_addr.addr != 0 } */
 816:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"
 817:../lwip-1.4.1/src/netif/etharp.c ****     }
 818:../lwip-1.4.1/src/netif/etharp.c ****     break;
 1533              		.loc 1 818 0 discriminator 6
 1534 01ae 06E0     		b	.L84
 1535              	.L86:
 819:../lwip-1.4.1/src/netif/etharp.c ****   case PP_HTONS(ARP_REPLY):
 820:../lwip-1.4.1/src/netif/etharp.c ****     /* ARP reply. We already updated the ARP cache earlier. */
 821:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
 822:../lwip-1.4.1/src/netif/etharp.c **** #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
 823:../lwip-1.4.1/src/netif/etharp.c ****     /* DHCP wants to know about ARP replies from any host with an
 824:../lwip-1.4.1/src/netif/etharp.c ****      * IP address also offered to us by the DHCP server. We do not
 825:../lwip-1.4.1/src/netif/etharp.c ****      * want to take a duplicate IP address on a single network.
 826:../lwip-1.4.1/src/netif/etharp.c ****      * @todo How should we handle redundant (fail-over) interfaces? */
 827:../lwip-1.4.1/src/netif/etharp.c ****     dhcp_arp_reply(netif, &sipaddr);
 828:../lwip-1.4.1/src/netif/etharp.c **** #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
 829:../lwip-1.4.1/src/netif/etharp.c ****     break;
 830:../lwip-1.4.1/src/netif/etharp.c ****   default:
 831:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"
 832:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.err);
 1536              		.loc 1 832 0
 1537 01b0 064B     		ldr	r3, .L88
 1538 01b2 9B6D     		ldr	r3, [r3, #88]
 1539 01b4 0133     		adds	r3, r3, #1
 1540 01b6 054A     		ldr	r2, .L88
 1541 01b8 9365     		str	r3, [r2, #88]
 833:../lwip-1.4.1/src/netif/etharp.c ****     break;
 1542              		.loc 1 833 0
 1543 01ba 00E0     		b	.L84
 1544              	.L87:
 829:../lwip-1.4.1/src/netif/etharp.c ****   default:
 1545              		.loc 1 829 0
 1546 01bc 00BF     		nop
 1547              	.L84:
 834:../lwip-1.4.1/src/netif/etharp.c ****   }
 835:../lwip-1.4.1/src/netif/etharp.c ****   /* free ARP packet */
 836:../lwip-1.4.1/src/netif/etharp.c ****   pbuf_free(p);
 1548              		.loc 1 836 0 discriminator 8
 1549 01be 7868     		ldr	r0, [r7, #4]
 1550 01c0 FFF7FEFF 		bl	pbuf_free
 1551              	.L67:
 837:../lwip-1.4.1/src/netif/etharp.c **** }
 1552              		.loc 1 837 0
 1553 01c4 2837     		adds	r7, r7, #40
 1554              		.cfi_def_cfa_offset 8
 1555 01c6 BD46     		mov	sp, r7
 1556              		.cfi_def_cfa_register 13
 1557              		@ sp needed
 1558 01c8 80BD     		pop	{r7, pc}
 1559              	.L89:
 1560 01ca 00BF     		.align	2
 1561              	.L88:
 1562 01cc 00000000 		.word	lwip_stats
 1563              		.cfi_endproc
 1564              	.LFE9:
 1566              		.section	.text.etharp_output_to_arp_index,"ax",%progbits
 1567              		.align	2
 1568              		.thumb
 1569              		.thumb_func
 1571              	etharp_output_to_arp_index:
 1572              	.LFB10:
 838:../lwip-1.4.1/src/netif/etharp.c **** 
 839:../lwip-1.4.1/src/netif/etharp.c **** /** Just a small helper function that sends a pbuf to an ethernet address
 840:../lwip-1.4.1/src/netif/etharp.c ****  * in the arp_table specified by the index 'arp_idx'.
 841:../lwip-1.4.1/src/netif/etharp.c ****  */
 842:../lwip-1.4.1/src/netif/etharp.c **** static err_t
 843:../lwip-1.4.1/src/netif/etharp.c **** etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
 844:../lwip-1.4.1/src/netif/etharp.c **** {
 1573              		.loc 1 844 0
 1574              		.cfi_startproc
 1575              		@ args = 0, pretend = 0, frame = 16
 1576              		@ frame_needed = 1, uses_anonymous_args = 0
 1577 0000 90B5     		push	{r4, r7, lr}
 1578              		.cfi_def_cfa_offset 12
 1579              		.cfi_offset 4, -12
 1580              		.cfi_offset 7, -8
 1581              		.cfi_offset 14, -4
 1582 0002 85B0     		sub	sp, sp, #20
 1583              		.cfi_def_cfa_offset 32
 1584 0004 00AF     		add	r7, sp, #0
 1585              		.cfi_def_cfa_register 7
 1586 0006 F860     		str	r0, [r7, #12]
 1587 0008 B960     		str	r1, [r7, #8]
 1588 000a 1346     		mov	r3, r2
 1589 000c FB71     		strb	r3, [r7, #7]
 845:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 1590              		.loc 1 845 0
 1591 000e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1592 0010 1346     		mov	r3, r2
 1593 0012 9B00     		lsls	r3, r3, #2
 1594 0014 1344     		add	r3, r3, r2
 1595 0016 9B00     		lsls	r3, r3, #2
 846:../lwip-1.4.1/src/netif/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 847:../lwip-1.4.1/src/netif/etharp.c ****   /* if arp table entry is about to expire: re-request it,
 848:../lwip-1.4.1/src/netif/etharp.c ****      but only if its state is ETHARP_STATE_STABLE to prevent flooding the
 849:../lwip-1.4.1/src/netif/etharp.c ****      network with ARP requests if this address is used frequently. */
 850:../lwip-1.4.1/src/netif/etharp.c ****   if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 1596              		.loc 1 850 0
 1597 0018 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1598 001a 2249     		ldr	r1, .L93
 1599 001c 1346     		mov	r3, r2
 1600 001e 9B00     		lsls	r3, r3, #2
 1601 0020 1344     		add	r3, r3, r2
 1602 0022 9B00     		lsls	r3, r3, #2
 1603 0024 0B44     		add	r3, r3, r1
 1604 0026 1033     		adds	r3, r3, #16
 1605 0028 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1606 002a 022B     		cmp	r3, #2
 1607 002c 23D1     		bne	.L91
 851:../lwip-1.4.1/src/netif/etharp.c ****       (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 1608              		.loc 1 851 0 discriminator 1
 1609 002e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1610 0030 1C49     		ldr	r1, .L93
 1611 0032 1346     		mov	r3, r2
 1612 0034 9B00     		lsls	r3, r3, #2
 1613 0036 1344     		add	r3, r3, r2
 1614 0038 9B00     		lsls	r3, r3, #2
 1615 003a 0B44     		add	r3, r3, r1
 1616 003c 1033     		adds	r3, r3, #16
 1617 003e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 850:../lwip-1.4.1/src/netif/etharp.c ****       (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 1618              		.loc 1 850 0 discriminator 1
 1619 0040 E32B     		cmp	r3, #227
 1620 0042 18D9     		bls	.L91
 852:../lwip-1.4.1/src/netif/etharp.c ****     if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 1621              		.loc 1 852 0
 1622 0044 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1623 0046 1346     		mov	r3, r2
 1624 0048 9B00     		lsls	r3, r3, #2
 1625 004a 1344     		add	r3, r3, r2
 1626 004c 9B00     		lsls	r3, r3, #2
 1627 004e 154A     		ldr	r2, .L93
 1628 0050 1344     		add	r3, r3, r2
 1629 0052 0433     		adds	r3, r3, #4
 1630 0054 F868     		ldr	r0, [r7, #12]
 1631 0056 1946     		mov	r1, r3
 1632 0058 FFF7FEFF 		bl	etharp_request
 1633 005c 0346     		mov	r3, r0
 1634 005e 002B     		cmp	r3, #0
 1635 0060 09D1     		bne	.L91
 853:../lwip-1.4.1/src/netif/etharp.c ****       arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 1636              		.loc 1 853 0
 1637 0062 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1638 0064 0F49     		ldr	r1, .L93
 1639 0066 1346     		mov	r3, r2
 1640 0068 9B00     		lsls	r3, r3, #2
 1641 006a 1344     		add	r3, r3, r2
 1642 006c 9B00     		lsls	r3, r3, #2
 1643 006e 0B44     		add	r3, r3, r1
 1644 0070 1033     		adds	r3, r3, #16
 1645 0072 0322     		movs	r2, #3
 1646 0074 9A70     		strb	r2, [r3, #2]
 1647              	.L91:
 854:../lwip-1.4.1/src/netif/etharp.c ****     }
 855:../lwip-1.4.1/src/netif/etharp.c ****   }
 856:../lwip-1.4.1/src/netif/etharp.c ****   
 857:../lwip-1.4.1/src/netif/etharp.c ****   return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 1648              		.loc 1 857 0
 1649 0076 FB68     		ldr	r3, [r7, #12]
 1650 0078 03F12304 		add	r4, r3, #35
 858:../lwip-1.4.1/src/netif/etharp.c ****     &arp_table[arp_idx].ethaddr);
 1651              		.loc 1 858 0
 1652 007c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 857:../lwip-1.4.1/src/netif/etharp.c ****     &arp_table[arp_idx].ethaddr);
 1653              		.loc 1 857 0
 1654 007e 1346     		mov	r3, r2
 1655 0080 9B00     		lsls	r3, r3, #2
 1656 0082 1344     		add	r3, r3, r2
 1657 0084 9B00     		lsls	r3, r3, #2
 1658 0086 0833     		adds	r3, r3, #8
 1659 0088 064A     		ldr	r2, .L93
 1660 008a 1344     		add	r3, r3, r2
 1661 008c 0433     		adds	r3, r3, #4
 1662 008e F868     		ldr	r0, [r7, #12]
 1663 0090 B968     		ldr	r1, [r7, #8]
 1664 0092 2246     		mov	r2, r4
 1665 0094 FFF7FEFF 		bl	etharp_send_ip
 1666 0098 0346     		mov	r3, r0
 859:../lwip-1.4.1/src/netif/etharp.c **** }
 1667              		.loc 1 859 0
 1668 009a 1846     		mov	r0, r3
 1669 009c 1437     		adds	r7, r7, #20
 1670              		.cfi_def_cfa_offset 12
 1671 009e BD46     		mov	sp, r7
 1672              		.cfi_def_cfa_register 13
 1673              		@ sp needed
 1674 00a0 90BD     		pop	{r4, r7, pc}
 1675              	.L94:
 1676 00a2 00BF     		.align	2
 1677              	.L93:
 1678 00a4 00000000 		.word	arp_table
 1679              		.cfi_endproc
 1680              	.LFE10:
 1682              		.section	.text.etharp_output,"ax",%progbits
 1683              		.align	2
 1684              		.global	etharp_output
 1685              		.thumb
 1686              		.thumb_func
 1688              	etharp_output:
 1689              	.LFB11:
 860:../lwip-1.4.1/src/netif/etharp.c **** 
 861:../lwip-1.4.1/src/netif/etharp.c **** /**
 862:../lwip-1.4.1/src/netif/etharp.c ****  * Resolve and fill-in Ethernet address header for outgoing IP packet.
 863:../lwip-1.4.1/src/netif/etharp.c ****  *
 864:../lwip-1.4.1/src/netif/etharp.c ****  * For IP multicast and broadcast, corresponding Ethernet addresses
 865:../lwip-1.4.1/src/netif/etharp.c ****  * are selected and the packet is transmitted on the link.
 866:../lwip-1.4.1/src/netif/etharp.c ****  *
 867:../lwip-1.4.1/src/netif/etharp.c ****  * For unicast addresses, the packet is submitted to etharp_query(). In
 868:../lwip-1.4.1/src/netif/etharp.c ****  * case the IP address is outside the local network, the IP address of
 869:../lwip-1.4.1/src/netif/etharp.c ****  * the gateway is used.
 870:../lwip-1.4.1/src/netif/etharp.c ****  *
 871:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif The lwIP network interface which the IP packet will be sent on.
 872:../lwip-1.4.1/src/netif/etharp.c ****  * @param q The pbuf(s) containing the IP packet to be sent.
 873:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr The IP address of the packet destination.
 874:../lwip-1.4.1/src/netif/etharp.c ****  *
 875:../lwip-1.4.1/src/netif/etharp.c ****  * @return
 876:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_RTE No route to destination (no gateway to external networks),
 877:../lwip-1.4.1/src/netif/etharp.c ****  * or the return type of either etharp_query() or etharp_send_ip().
 878:../lwip-1.4.1/src/netif/etharp.c ****  */
 879:../lwip-1.4.1/src/netif/etharp.c **** err_t
 880:../lwip-1.4.1/src/netif/etharp.c **** etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
 881:../lwip-1.4.1/src/netif/etharp.c **** {
 1690              		.loc 1 881 0
 1691              		.cfi_startproc
 1692              		@ args = 0, pretend = 0, frame = 32
 1693              		@ frame_needed = 1, uses_anonymous_args = 0
 1694 0000 80B5     		push	{r7, lr}
 1695              		.cfi_def_cfa_offset 8
 1696              		.cfi_offset 7, -8
 1697              		.cfi_offset 14, -4
 1698 0002 88B0     		sub	sp, sp, #32
 1699              		.cfi_def_cfa_offset 40
 1700 0004 00AF     		add	r7, sp, #0
 1701              		.cfi_def_cfa_register 7
 1702 0006 F860     		str	r0, [r7, #12]
 1703 0008 B960     		str	r1, [r7, #8]
 1704 000a 7A60     		str	r2, [r7, #4]
 882:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_addr *dest;
 883:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_addr mcastaddr;
 884:../lwip-1.4.1/src/netif/etharp.c ****   ip_addr_t *dst_addr = ipaddr;
 1705              		.loc 1 884 0
 1706 000c 7B68     		ldr	r3, [r7, #4]
 1707 000e BB61     		str	r3, [r7, #24]
 885:../lwip-1.4.1/src/netif/etharp.c **** 
 886:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 887:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 888:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 889:../lwip-1.4.1/src/netif/etharp.c **** 
 890:../lwip-1.4.1/src/netif/etharp.c ****   /* make room for Ethernet header - should not fail */
 891:../lwip-1.4.1/src/netif/etharp.c ****   if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 1708              		.loc 1 891 0
 1709 0010 B868     		ldr	r0, [r7, #8]
 1710 0012 0E21     		movs	r1, #14
 1711 0014 FFF7FEFF 		bl	pbuf_header
 1712 0018 0346     		mov	r3, r0
 1713 001a 002B     		cmp	r3, #0
 1714 001c 06D0     		beq	.L96
 892:../lwip-1.4.1/src/netif/etharp.c ****     /* bail out */
 893:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
 894:../lwip-1.4.1/src/netif/etharp.c ****       ("etharp_output: could not allocate room for header.\n"));
 895:../lwip-1.4.1/src/netif/etharp.c ****     LINK_STATS_INC(link.lenerr);
 1715              		.loc 1 895 0
 1716 001e 5E4B     		ldr	r3, .L108
 1717 0020 5B69     		ldr	r3, [r3, #20]
 1718 0022 0133     		adds	r3, r3, #1
 1719 0024 5C4A     		ldr	r2, .L108
 1720 0026 5361     		str	r3, [r2, #20]
 896:../lwip-1.4.1/src/netif/etharp.c ****     return ERR_BUF;
 1721              		.loc 1 896 0
 1722 0028 FE23     		movs	r3, #254
 1723 002a B0E0     		b	.L107
 1724              	.L96:
 897:../lwip-1.4.1/src/netif/etharp.c ****   }
 898:../lwip-1.4.1/src/netif/etharp.c **** 
 899:../lwip-1.4.1/src/netif/etharp.c ****   /* Determine on destination hardware address. Broadcasts and multicasts
 900:../lwip-1.4.1/src/netif/etharp.c ****    * are special, other IP addresses are looked up in the ARP table. */
 901:../lwip-1.4.1/src/netif/etharp.c **** 
 902:../lwip-1.4.1/src/netif/etharp.c ****   /* broadcast destination IP address? */
 903:../lwip-1.4.1/src/netif/etharp.c ****   if (ip_addr_isbroadcast(ipaddr, netif)) {
 1725              		.loc 1 903 0
 1726 002c 7B68     		ldr	r3, [r7, #4]
 1727 002e 1B68     		ldr	r3, [r3]
 1728 0030 1846     		mov	r0, r3
 1729 0032 F968     		ldr	r1, [r7, #12]
 1730 0034 FFF7FEFF 		bl	ip4_addr_isbroadcast
 1731 0038 0346     		mov	r3, r0
 1732 003a 002B     		cmp	r3, #0
 1733 003c 02D0     		beq	.L98
 904:../lwip-1.4.1/src/netif/etharp.c ****     /* broadcast on Ethernet also */
 905:../lwip-1.4.1/src/netif/etharp.c ****     dest = (struct eth_addr *)&ethbroadcast;
 1734              		.loc 1 905 0
 1735 003e 574B     		ldr	r3, .L108+4
 1736 0040 FB61     		str	r3, [r7, #28]
 1737 0042 9BE0     		b	.L99
 1738              	.L98:
 906:../lwip-1.4.1/src/netif/etharp.c ****   /* multicast destination IP address? */
 907:../lwip-1.4.1/src/netif/etharp.c ****   } else if (ip_addr_ismulticast(ipaddr)) {
 1739              		.loc 1 907 0
 1740 0044 7B68     		ldr	r3, [r7, #4]
 1741 0046 1B68     		ldr	r3, [r3]
 1742 0048 03F0F003 		and	r3, r3, #240
 1743 004c E02B     		cmp	r3, #224
 1744 004e 16D1     		bne	.L100
 908:../lwip-1.4.1/src/netif/etharp.c ****     /* Hash IP multicast address to MAC address.*/
 909:../lwip-1.4.1/src/netif/etharp.c ****     mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 1745              		.loc 1 909 0
 1746 0050 0123     		movs	r3, #1
 1747 0052 3B74     		strb	r3, [r7, #16]
 910:../lwip-1.4.1/src/netif/etharp.c ****     mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 1748              		.loc 1 910 0
 1749 0054 0023     		movs	r3, #0
 1750 0056 7B74     		strb	r3, [r7, #17]
 911:../lwip-1.4.1/src/netif/etharp.c ****     mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 1751              		.loc 1 911 0
 1752 0058 5E23     		movs	r3, #94
 1753 005a BB74     		strb	r3, [r7, #18]
 912:../lwip-1.4.1/src/netif/etharp.c ****     mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 1754              		.loc 1 912 0
 1755 005c 7B68     		ldr	r3, [r7, #4]
 1756 005e 0133     		adds	r3, r3, #1
 1757 0060 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1758 0062 03F07F03 		and	r3, r3, #127
 1759 0066 DBB2     		uxtb	r3, r3
 1760 0068 FB74     		strb	r3, [r7, #19]
 913:../lwip-1.4.1/src/netif/etharp.c ****     mcastaddr.addr[4] = ip4_addr3(ipaddr);
 1761              		.loc 1 913 0
 1762 006a 7B68     		ldr	r3, [r7, #4]
 1763 006c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1764 006e 3B75     		strb	r3, [r7, #20]
 914:../lwip-1.4.1/src/netif/etharp.c ****     mcastaddr.addr[5] = ip4_addr4(ipaddr);
 1765              		.loc 1 914 0
 1766 0070 7B68     		ldr	r3, [r7, #4]
 1767 0072 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1768 0074 7B75     		strb	r3, [r7, #21]
 915:../lwip-1.4.1/src/netif/etharp.c ****     /* destination Ethernet address is multicast */
 916:../lwip-1.4.1/src/netif/etharp.c ****     dest = &mcastaddr;
 1769              		.loc 1 916 0
 1770 0076 07F11003 		add	r3, r7, #16
 1771 007a FB61     		str	r3, [r7, #28]
 1772 007c 7EE0     		b	.L99
 1773              	.L100:
 1774              	.LBB6:
 917:../lwip-1.4.1/src/netif/etharp.c ****   /* unicast destination IP address? */
 918:../lwip-1.4.1/src/netif/etharp.c ****   } else {
 919:../lwip-1.4.1/src/netif/etharp.c ****     s8_t i;
 920:../lwip-1.4.1/src/netif/etharp.c ****     /* outside local network? if so, this can neither be a global broadcast nor
 921:../lwip-1.4.1/src/netif/etharp.c ****        a subnet broadcast. */
 922:../lwip-1.4.1/src/netif/etharp.c ****     if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 1775              		.loc 1 922 0
 1776 007e 7B68     		ldr	r3, [r7, #4]
 1777 0080 1A68     		ldr	r2, [r3]
 1778 0082 FB68     		ldr	r3, [r7, #12]
 1779 0084 5B68     		ldr	r3, [r3, #4]
 1780 0086 5A40     		eors	r2, r2, r3
 1781 0088 FB68     		ldr	r3, [r7, #12]
 1782 008a 9B68     		ldr	r3, [r3, #8]
 1783 008c 1340     		ands	r3, r3, r2
 1784 008e 002B     		cmp	r3, #0
 1785 0090 14D0     		beq	.L101
 923:../lwip-1.4.1/src/netif/etharp.c ****         !ip_addr_islinklocal(ipaddr)) {
 1786              		.loc 1 923 0 discriminator 1
 1787 0092 7B68     		ldr	r3, [r7, #4]
 1788 0094 1B68     		ldr	r3, [r3]
 1789 0096 9BB2     		uxth	r3, r3
 922:../lwip-1.4.1/src/netif/etharp.c ****         !ip_addr_islinklocal(ipaddr)) {
 1790              		.loc 1 922 0 discriminator 1
 1791 0098 4FF6A962 		movw	r2, #65193
 1792 009c 9342     		cmp	r3, r2
 1793 009e 0DD0     		beq	.L101
 924:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
 925:../lwip-1.4.1/src/netif/etharp.c ****       struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
 926:../lwip-1.4.1/src/netif/etharp.c ****         sizeof(struct eth_hdr));
 927:../lwip-1.4.1/src/netif/etharp.c ****       /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
 928:../lwip-1.4.1/src/netif/etharp.c ****          a link-local source address must always be "directly to its destination
 929:../lwip-1.4.1/src/netif/etharp.c ****          on the same physical link. The host MUST NOT send the packet to any
 930:../lwip-1.4.1/src/netif/etharp.c ****          router for forwarding". */
 931:../lwip-1.4.1/src/netif/etharp.c ****       if (!ip_addr_islinklocal(&iphdr->src))
 932:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 933:../lwip-1.4.1/src/netif/etharp.c ****       {
 934:../lwip-1.4.1/src/netif/etharp.c ****         /* interface has default gateway? */
 935:../lwip-1.4.1/src/netif/etharp.c ****         if (!ip_addr_isany(&netif->gw)) {
 1794              		.loc 1 935 0
 1795 00a0 FB68     		ldr	r3, [r7, #12]
 1796 00a2 0C33     		adds	r3, r3, #12
 1797 00a4 002B     		cmp	r3, #0
 1798 00a6 07D0     		beq	.L102
 1799              		.loc 1 935 0 is_stmt 0 discriminator 1
 1800 00a8 FB68     		ldr	r3, [r7, #12]
 1801 00aa DB68     		ldr	r3, [r3, #12]
 1802 00ac 002B     		cmp	r3, #0
 1803 00ae 03D0     		beq	.L102
 936:../lwip-1.4.1/src/netif/etharp.c ****           /* send to hardware address of default gateway IP address */
 937:../lwip-1.4.1/src/netif/etharp.c ****           dst_addr = &(netif->gw);
 1804              		.loc 1 937 0 is_stmt 1
 1805 00b0 FB68     		ldr	r3, [r7, #12]
 1806 00b2 0C33     		adds	r3, r3, #12
 1807 00b4 BB61     		str	r3, [r7, #24]
 1808 00b6 01E0     		b	.L101
 1809              	.L102:
 938:../lwip-1.4.1/src/netif/etharp.c ****         /* no default gateway available */
 939:../lwip-1.4.1/src/netif/etharp.c ****         } else {
 940:../lwip-1.4.1/src/netif/etharp.c ****           /* no route to destination error (default gateway missing) */
 941:../lwip-1.4.1/src/netif/etharp.c ****           return ERR_RTE;
 1810              		.loc 1 941 0
 1811 00b8 FC23     		movs	r3, #252
 1812 00ba 68E0     		b	.L107
 1813              	.L101:
 942:../lwip-1.4.1/src/netif/etharp.c ****         }
 943:../lwip-1.4.1/src/netif/etharp.c ****       }
 944:../lwip-1.4.1/src/netif/etharp.c ****     }
 945:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 946:../lwip-1.4.1/src/netif/etharp.c ****     if (netif->addr_hint != NULL) {
 947:../lwip-1.4.1/src/netif/etharp.c ****       /* per-pcb cached entry was given */
 948:../lwip-1.4.1/src/netif/etharp.c ****       u8_t etharp_cached_entry = *(netif->addr_hint);
 949:../lwip-1.4.1/src/netif/etharp.c ****       if (etharp_cached_entry < ARP_TABLE_SIZE) {
 950:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 951:../lwip-1.4.1/src/netif/etharp.c ****         if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 1814              		.loc 1 951 0
 1815 00bc 384B     		ldr	r3, .L108+8
 1816 00be 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1817 00c0 1946     		mov	r1, r3
 1818 00c2 384A     		ldr	r2, .L108+12
 1819 00c4 0B46     		mov	r3, r1
 1820 00c6 9B00     		lsls	r3, r3, #2
 1821 00c8 0B44     		add	r3, r3, r1
 1822 00ca 9B00     		lsls	r3, r3, #2
 1823 00cc 1344     		add	r3, r3, r2
 1824 00ce 1033     		adds	r3, r3, #16
 1825 00d0 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1826 00d2 012B     		cmp	r3, #1
 1827 00d4 1BD9     		bls	.L103
 952:../lwip-1.4.1/src/netif/etharp.c ****             (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 1828              		.loc 1 952 0 discriminator 1
 1829 00d6 BB69     		ldr	r3, [r7, #24]
 1830 00d8 1A68     		ldr	r2, [r3]
 1831 00da 314B     		ldr	r3, .L108+8
 1832 00dc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1833 00de 1846     		mov	r0, r3
 1834 00e0 3049     		ldr	r1, .L108+12
 1835 00e2 0346     		mov	r3, r0
 1836 00e4 9B00     		lsls	r3, r3, #2
 1837 00e6 0344     		add	r3, r3, r0
 1838 00e8 9B00     		lsls	r3, r3, #2
 1839 00ea 0B44     		add	r3, r3, r1
 1840 00ec 5B68     		ldr	r3, [r3, #4]
 951:../lwip-1.4.1/src/netif/etharp.c ****             (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 1841              		.loc 1 951 0 discriminator 1
 1842 00ee 9A42     		cmp	r2, r3
 1843 00f0 0DD1     		bne	.L103
 953:../lwip-1.4.1/src/netif/etharp.c ****           /* the per-pcb-cached entry is stable and the right one! */
 954:../lwip-1.4.1/src/netif/etharp.c ****           ETHARP_STATS_INC(etharp.cachehit);
 1844              		.loc 1 954 0
 1845 00f2 294B     		ldr	r3, .L108
 1846 00f4 DB6D     		ldr	r3, [r3, #92]
 1847 00f6 0133     		adds	r3, r3, #1
 1848 00f8 274A     		ldr	r2, .L108
 1849 00fa D365     		str	r3, [r2, #92]
 955:../lwip-1.4.1/src/netif/etharp.c ****           return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 1850              		.loc 1 955 0
 1851 00fc 284B     		ldr	r3, .L108+8
 1852 00fe 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1853 0100 F868     		ldr	r0, [r7, #12]
 1854 0102 B968     		ldr	r1, [r7, #8]
 1855 0104 1A46     		mov	r2, r3
 1856 0106 FFF7FEFF 		bl	etharp_output_to_arp_index
 1857 010a 0346     		mov	r3, r0
 1858 010c 3FE0     		b	.L107
 1859              	.L103:
 956:../lwip-1.4.1/src/netif/etharp.c ****         }
 957:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 958:../lwip-1.4.1/src/netif/etharp.c ****       }
 959:../lwip-1.4.1/src/netif/etharp.c ****     }
 960:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 961:../lwip-1.4.1/src/netif/etharp.c **** 
 962:../lwip-1.4.1/src/netif/etharp.c ****     /* find stable entry: do this here since this is a critical path for
 963:../lwip-1.4.1/src/netif/etharp.c ****        throughput and etharp_find_entry() is kind of slow */
 964:../lwip-1.4.1/src/netif/etharp.c ****     for (i = 0; i < ARP_TABLE_SIZE; i++) {
 1860              		.loc 1 964 0
 1861 010e 0023     		movs	r3, #0
 1862 0110 FB75     		strb	r3, [r7, #23]
 1863 0112 28E0     		b	.L104
 1864              	.L106:
 965:../lwip-1.4.1/src/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1865              		.loc 1 965 0
 1866 0114 97F91720 		ldrsb	r2, [r7, #23]
 1867 0118 2249     		ldr	r1, .L108+12
 1868 011a 1346     		mov	r3, r2
 1869 011c 9B00     		lsls	r3, r3, #2
 1870 011e 1344     		add	r3, r3, r2
 1871 0120 9B00     		lsls	r3, r3, #2
 1872 0122 0B44     		add	r3, r3, r1
 1873 0124 1033     		adds	r3, r3, #16
 1874 0126 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1875 0128 012B     		cmp	r3, #1
 1876 012a 17D9     		bls	.L105
 966:../lwip-1.4.1/src/netif/etharp.c ****           (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 1877              		.loc 1 966 0 discriminator 1
 1878 012c BB69     		ldr	r3, [r7, #24]
 1879 012e 1968     		ldr	r1, [r3]
 1880 0130 97F91720 		ldrsb	r2, [r7, #23]
 1881 0134 1B48     		ldr	r0, .L108+12
 1882 0136 1346     		mov	r3, r2
 1883 0138 9B00     		lsls	r3, r3, #2
 1884 013a 1344     		add	r3, r3, r2
 1885 013c 9B00     		lsls	r3, r3, #2
 1886 013e 0344     		add	r3, r3, r0
 1887 0140 5B68     		ldr	r3, [r3, #4]
 965:../lwip-1.4.1/src/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1888              		.loc 1 965 0 discriminator 1
 1889 0142 9942     		cmp	r1, r3
 1890 0144 0AD1     		bne	.L105
 967:../lwip-1.4.1/src/netif/etharp.c ****         /* found an existing, stable entry */
 968:../lwip-1.4.1/src/netif/etharp.c ****         ETHARP_SET_HINT(netif, i);
 1891              		.loc 1 968 0
 1892 0146 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 1893 0148 154B     		ldr	r3, .L108+8
 1894 014a 1A70     		strb	r2, [r3]
 969:../lwip-1.4.1/src/netif/etharp.c ****         return etharp_output_to_arp_index(netif, q, i);
 1895              		.loc 1 969 0
 1896 014c FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1897 014e F868     		ldr	r0, [r7, #12]
 1898 0150 B968     		ldr	r1, [r7, #8]
 1899 0152 1A46     		mov	r2, r3
 1900 0154 FFF7FEFF 		bl	etharp_output_to_arp_index
 1901 0158 0346     		mov	r3, r0
 1902 015a 18E0     		b	.L107
 1903              	.L105:
 964:../lwip-1.4.1/src/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1904              		.loc 1 964 0 discriminator 2
 1905 015c FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1906 015e DBB2     		uxtb	r3, r3
 1907 0160 0133     		adds	r3, r3, #1
 1908 0162 DBB2     		uxtb	r3, r3
 1909 0164 FB75     		strb	r3, [r7, #23]
 1910              	.L104:
 964:../lwip-1.4.1/src/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1911              		.loc 1 964 0 is_stmt 0 discriminator 1
 1912 0166 97F91730 		ldrsb	r3, [r7, #23]
 1913 016a 092B     		cmp	r3, #9
 1914 016c D2DD     		ble	.L106
 970:../lwip-1.4.1/src/netif/etharp.c ****       }
 971:../lwip-1.4.1/src/netif/etharp.c ****     }
 972:../lwip-1.4.1/src/netif/etharp.c ****     /* no stable entry found, use the (slower) query function:
 973:../lwip-1.4.1/src/netif/etharp.c ****        queue on destination Ethernet address belonging to ipaddr */
 974:../lwip-1.4.1/src/netif/etharp.c ****     return etharp_query(netif, dst_addr, q);
 1915              		.loc 1 974 0 is_stmt 1
 1916 016e F868     		ldr	r0, [r7, #12]
 1917 0170 B969     		ldr	r1, [r7, #24]
 1918 0172 BA68     		ldr	r2, [r7, #8]
 1919 0174 FFF7FEFF 		bl	etharp_query
 1920 0178 0346     		mov	r3, r0
 1921 017a 08E0     		b	.L107
 1922              	.L99:
 1923              	.LBE6:
 975:../lwip-1.4.1/src/netif/etharp.c ****   }
 976:../lwip-1.4.1/src/netif/etharp.c **** 
 977:../lwip-1.4.1/src/netif/etharp.c ****   /* continuation for multicast/broadcast destinations */
 978:../lwip-1.4.1/src/netif/etharp.c ****   /* obtain source Ethernet address of the given interface */
 979:../lwip-1.4.1/src/netif/etharp.c ****   /* send packet directly on the link */
 980:../lwip-1.4.1/src/netif/etharp.c ****   return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 1924              		.loc 1 980 0
 1925 017c FB68     		ldr	r3, [r7, #12]
 1926 017e 2333     		adds	r3, r3, #35
 1927 0180 F868     		ldr	r0, [r7, #12]
 1928 0182 B968     		ldr	r1, [r7, #8]
 1929 0184 1A46     		mov	r2, r3
 1930 0186 FB69     		ldr	r3, [r7, #28]
 1931 0188 FFF7FEFF 		bl	etharp_send_ip
 1932 018c 0346     		mov	r3, r0
 1933              	.L107:
 1934 018e 5BB2     		sxtb	r3, r3
 981:../lwip-1.4.1/src/netif/etharp.c **** }
 1935              		.loc 1 981 0 discriminator 2
 1936 0190 1846     		mov	r0, r3
 1937 0192 2037     		adds	r7, r7, #32
 1938              		.cfi_def_cfa_offset 8
 1939 0194 BD46     		mov	sp, r7
 1940              		.cfi_def_cfa_register 13
 1941              		@ sp needed
 1942 0196 80BD     		pop	{r7, pc}
 1943              	.L109:
 1944              		.align	2
 1945              	.L108:
 1946 0198 00000000 		.word	lwip_stats
 1947 019c 00000000 		.word	ethbroadcast
 1948 01a0 C8000000 		.word	etharp_cached_entry
 1949 01a4 00000000 		.word	arp_table
 1950              		.cfi_endproc
 1951              	.LFE11:
 1953              		.section	.text.etharp_query,"ax",%progbits
 1954              		.align	2
 1955              		.global	etharp_query
 1956              		.thumb
 1957              		.thumb_func
 1959              	etharp_query:
 1960              	.LFB12:
 982:../lwip-1.4.1/src/netif/etharp.c **** 
 983:../lwip-1.4.1/src/netif/etharp.c **** /**
 984:../lwip-1.4.1/src/netif/etharp.c ****  * Send an ARP request for the given IP address and/or queue a packet.
 985:../lwip-1.4.1/src/netif/etharp.c ****  *
 986:../lwip-1.4.1/src/netif/etharp.c ****  * If the IP address was not yet in the cache, a pending ARP cache entry
 987:../lwip-1.4.1/src/netif/etharp.c ****  * is added and an ARP request is sent for the given address. The packet
 988:../lwip-1.4.1/src/netif/etharp.c ****  * is queued on this entry.
 989:../lwip-1.4.1/src/netif/etharp.c ****  *
 990:../lwip-1.4.1/src/netif/etharp.c ****  * If the IP address was already pending in the cache, a new ARP request
 991:../lwip-1.4.1/src/netif/etharp.c ****  * is sent for the given address. The packet is queued on this entry.
 992:../lwip-1.4.1/src/netif/etharp.c ****  *
 993:../lwip-1.4.1/src/netif/etharp.c ****  * If the IP address was already stable in the cache, and a packet is
 994:../lwip-1.4.1/src/netif/etharp.c ****  * given, it is directly sent and no ARP request is sent out. 
 995:../lwip-1.4.1/src/netif/etharp.c ****  * 
 996:../lwip-1.4.1/src/netif/etharp.c ****  * If the IP address was already stable in the cache, and no packet is
 997:../lwip-1.4.1/src/netif/etharp.c ****  * given, an ARP request is sent out.
 998:../lwip-1.4.1/src/netif/etharp.c ****  * 
 999:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif The lwIP network interface on which ipaddr
1000:../lwip-1.4.1/src/netif/etharp.c ****  * must be queried for.
1001:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr The IP address to be resolved.
1002:../lwip-1.4.1/src/netif/etharp.c ****  * @param q If non-NULL, a pbuf that must be delivered to the IP address.
1003:../lwip-1.4.1/src/netif/etharp.c ****  * q is not freed by this function.
1004:../lwip-1.4.1/src/netif/etharp.c ****  *
1005:../lwip-1.4.1/src/netif/etharp.c ****  * @note q must only be ONE packet, not a packet queue!
1006:../lwip-1.4.1/src/netif/etharp.c ****  *
1007:../lwip-1.4.1/src/netif/etharp.c ****  * @return
1008:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_BUF Could not make room for Ethernet header.
1009:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_MEM Hardware address unknown, and no more ARP entries available
1010:../lwip-1.4.1/src/netif/etharp.c ****  *   to query for address or queue the packet.
1011:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_MEM Could not queue packet due to memory shortage.
1012:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_RTE No route to destination (no gateway to external networks).
1013:../lwip-1.4.1/src/netif/etharp.c ****  * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
1014:../lwip-1.4.1/src/netif/etharp.c ****  *
1015:../lwip-1.4.1/src/netif/etharp.c ****  */
1016:../lwip-1.4.1/src/netif/etharp.c **** err_t
1017:../lwip-1.4.1/src/netif/etharp.c **** etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
1018:../lwip-1.4.1/src/netif/etharp.c **** {
 1961              		.loc 1 1018 0
 1962              		.cfi_startproc
 1963              		@ args = 0, pretend = 0, frame = 48
 1964              		@ frame_needed = 1, uses_anonymous_args = 0
 1965 0000 80B5     		push	{r7, lr}
 1966              		.cfi_def_cfa_offset 8
 1967              		.cfi_offset 7, -8
 1968              		.cfi_offset 14, -4
 1969 0002 8CB0     		sub	sp, sp, #48
 1970              		.cfi_def_cfa_offset 56
 1971 0004 00AF     		add	r7, sp, #0
 1972              		.cfi_def_cfa_register 7
 1973 0006 F860     		str	r0, [r7, #12]
 1974 0008 B960     		str	r1, [r7, #8]
 1975 000a 7A60     		str	r2, [r7, #4]
1019:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 1976              		.loc 1 1019 0
 1977 000c FB68     		ldr	r3, [r7, #12]
 1978 000e 2333     		adds	r3, r3, #35
 1979 0010 FB61     		str	r3, [r7, #28]
1020:../lwip-1.4.1/src/netif/etharp.c ****   err_t result = ERR_MEM;
 1980              		.loc 1 1020 0
 1981 0012 FF23     		movs	r3, #255
 1982 0014 87F82F30 		strb	r3, [r7, #47]
1021:../lwip-1.4.1/src/netif/etharp.c ****   s8_t i; /* ARP entry index */
1022:../lwip-1.4.1/src/netif/etharp.c **** 
1023:../lwip-1.4.1/src/netif/etharp.c ****   /* non-unicast address? */
1024:../lwip-1.4.1/src/netif/etharp.c ****   if (ip_addr_isbroadcast(ipaddr, netif) ||
 1983              		.loc 1 1024 0
 1984 0018 BB68     		ldr	r3, [r7, #8]
 1985 001a 1B68     		ldr	r3, [r3]
 1986 001c 1846     		mov	r0, r3
 1987 001e F968     		ldr	r1, [r7, #12]
 1988 0020 FFF7FEFF 		bl	ip4_addr_isbroadcast
 1989 0024 0346     		mov	r3, r0
 1990 0026 002B     		cmp	r3, #0
 1991 0028 0CD1     		bne	.L111
1025:../lwip-1.4.1/src/netif/etharp.c ****       ip_addr_ismulticast(ipaddr) ||
 1992              		.loc 1 1025 0 discriminator 1
 1993 002a BB68     		ldr	r3, [r7, #8]
 1994 002c 1B68     		ldr	r3, [r3]
 1995 002e 03F0F003 		and	r3, r3, #240
1024:../lwip-1.4.1/src/netif/etharp.c ****       ip_addr_ismulticast(ipaddr) ||
 1996              		.loc 1 1024 0 discriminator 1
 1997 0032 E02B     		cmp	r3, #224
 1998 0034 06D0     		beq	.L111
 1999              		.loc 1 1025 0
 2000 0036 BB68     		ldr	r3, [r7, #8]
 2001 0038 002B     		cmp	r3, #0
 2002 003a 03D0     		beq	.L111
1026:../lwip-1.4.1/src/netif/etharp.c ****       ip_addr_isany(ipaddr)) {
 2003              		.loc 1 1026 0
 2004 003c BB68     		ldr	r3, [r7, #8]
 2005 003e 1B68     		ldr	r3, [r3]
 2006 0040 002B     		cmp	r3, #0
 2007 0042 01D1     		bne	.L112
 2008              	.L111:
1027:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address 
1028:../lwip-1.4.1/src/netif/etharp.c ****     return ERR_ARG;
 2009              		.loc 1 1028 0
 2010 0044 F223     		movs	r3, #242
 2011 0046 0EE1     		b	.L113
 2012              	.L112:
1029:../lwip-1.4.1/src/netif/etharp.c ****   }
1030:../lwip-1.4.1/src/netif/etharp.c **** 
1031:../lwip-1.4.1/src/netif/etharp.c ****   /* find entry in ARP cache, ask to create entry if queueing packet */
1032:../lwip-1.4.1/src/netif/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 2013              		.loc 1 1032 0
 2014 0048 B868     		ldr	r0, [r7, #8]
 2015 004a 0121     		movs	r1, #1
 2016 004c FFF7FEFF 		bl	etharp_find_entry
 2017 0050 0346     		mov	r3, r0
 2018 0052 FB76     		strb	r3, [r7, #27]
1033:../lwip-1.4.1/src/netif/etharp.c **** 
1034:../lwip-1.4.1/src/netif/etharp.c ****   /* could not find or create entry? */
1035:../lwip-1.4.1/src/netif/etharp.c ****   if (i < 0) {
 2019              		.loc 1 1035 0
 2020 0054 97F91B30 		ldrsb	r3, [r7, #27]
 2021 0058 002B     		cmp	r3, #0
 2022 005a 09DA     		bge	.L114
1036:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
1037:../lwip-1.4.1/src/netif/etharp.c ****     if (q) {
 2023              		.loc 1 1037 0
 2024 005c 7B68     		ldr	r3, [r7, #4]
 2025 005e 002B     		cmp	r3, #0
 2026 0060 04D0     		beq	.L115
1038:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
1039:../lwip-1.4.1/src/netif/etharp.c ****       ETHARP_STATS_INC(etharp.memerr);
 2027              		.loc 1 1039 0
 2028 0062 834B     		ldr	r3, .L138
 2029 0064 9B6C     		ldr	r3, [r3, #72]
 2030 0066 0133     		adds	r3, r3, #1
 2031 0068 814A     		ldr	r2, .L138
 2032 006a 9364     		str	r3, [r2, #72]
 2033              	.L115:
1040:../lwip-1.4.1/src/netif/etharp.c ****     }
1041:../lwip-1.4.1/src/netif/etharp.c ****     return (err_t)i;
 2034              		.loc 1 1041 0
 2035 006c FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 2036 006e FAE0     		b	.L113
 2037              	.L114:
1042:../lwip-1.4.1/src/netif/etharp.c ****   }
1043:../lwip-1.4.1/src/netif/etharp.c **** 
1044:../lwip-1.4.1/src/netif/etharp.c ****   /* mark a fresh entry as pending (we just sent a request) */
1045:../lwip-1.4.1/src/netif/etharp.c ****   if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 2038              		.loc 1 1045 0
 2039 0070 97F91B20 		ldrsb	r2, [r7, #27]
 2040 0074 7F49     		ldr	r1, .L138+4
 2041 0076 1346     		mov	r3, r2
 2042 0078 9B00     		lsls	r3, r3, #2
 2043 007a 1344     		add	r3, r3, r2
 2044 007c 9B00     		lsls	r3, r3, #2
 2045 007e 0B44     		add	r3, r3, r1
 2046 0080 1033     		adds	r3, r3, #16
 2047 0082 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2048 0084 002B     		cmp	r3, #0
 2049 0086 0AD1     		bne	.L116
1046:../lwip-1.4.1/src/netif/etharp.c ****     arp_table[i].state = ETHARP_STATE_PENDING;
 2050              		.loc 1 1046 0
 2051 0088 97F91B20 		ldrsb	r2, [r7, #27]
 2052 008c 7949     		ldr	r1, .L138+4
 2053 008e 1346     		mov	r3, r2
 2054 0090 9B00     		lsls	r3, r3, #2
 2055 0092 1344     		add	r3, r3, r2
 2056 0094 9B00     		lsls	r3, r3, #2
 2057 0096 0B44     		add	r3, r3, r1
 2058 0098 1033     		adds	r3, r3, #16
 2059 009a 0122     		movs	r2, #1
 2060 009c 9A70     		strb	r2, [r3, #2]
 2061              	.L116:
1047:../lwip-1.4.1/src/netif/etharp.c ****   }
1048:../lwip-1.4.1/src/netif/etharp.c **** 
1049:../lwip-1.4.1/src/netif/etharp.c ****   /* { i is either a STABLE or (new or existing) PENDING entry } */
1050:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 2062              		.loc 1 1050 0
 2063 009e 97F91B20 		ldrsb	r2, [r7, #27]
 2064 00a2 7449     		ldr	r1, .L138+4
 2065 00a4 1346     		mov	r3, r2
 2066 00a6 9B00     		lsls	r3, r3, #2
 2067 00a8 1344     		add	r3, r3, r2
 2068 00aa 9B00     		lsls	r3, r3, #2
 2069 00ac 0B44     		add	r3, r3, r1
 2070 00ae 1033     		adds	r3, r3, #16
 2071 00b0 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2072 00b2 012B     		cmp	r3, #1
 2073 00b4 05D0     		beq	.L117
 2074              		.loc 1 1050 0 is_stmt 0 discriminator 1
 2075 00b6 97F91B20 		ldrsb	r2, [r7, #27]
 2076 00ba 1346     		mov	r3, r2
 2077 00bc 9B00     		lsls	r3, r3, #2
 2078 00be 1344     		add	r3, r3, r2
 2079 00c0 9B00     		lsls	r3, r3, #2
 2080              	.L117:
1051:../lwip-1.4.1/src/netif/etharp.c ****   ((arp_table[i].state == ETHARP_STATE_PENDING) ||
1052:../lwip-1.4.1/src/netif/etharp.c ****    (arp_table[i].state >= ETHARP_STATE_STABLE)));
1053:../lwip-1.4.1/src/netif/etharp.c **** 
1054:../lwip-1.4.1/src/netif/etharp.c ****   /* do we have a pending entry? or an implicit query request? */
1055:../lwip-1.4.1/src/netif/etharp.c ****   if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 2081              		.loc 1 1055 0 is_stmt 1
 2082 00c2 97F91B20 		ldrsb	r2, [r7, #27]
 2083 00c6 6B49     		ldr	r1, .L138+4
 2084 00c8 1346     		mov	r3, r2
 2085 00ca 9B00     		lsls	r3, r3, #2
 2086 00cc 1344     		add	r3, r3, r2
 2087 00ce 9B00     		lsls	r3, r3, #2
 2088 00d0 0B44     		add	r3, r3, r1
 2089 00d2 1033     		adds	r3, r3, #16
 2090 00d4 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2091 00d6 012B     		cmp	r3, #1
 2092 00d8 02D0     		beq	.L118
 2093              		.loc 1 1055 0 is_stmt 0 discriminator 1
 2094 00da 7B68     		ldr	r3, [r7, #4]
 2095 00dc 002B     		cmp	r3, #0
 2096 00de 0CD1     		bne	.L119
 2097              	.L118:
1056:../lwip-1.4.1/src/netif/etharp.c ****     /* try to resolve it; send out ARP request */
1057:../lwip-1.4.1/src/netif/etharp.c ****     result = etharp_request(netif, ipaddr);
 2098              		.loc 1 1057 0 is_stmt 1
 2099 00e0 F868     		ldr	r0, [r7, #12]
 2100 00e2 B968     		ldr	r1, [r7, #8]
 2101 00e4 FFF7FEFF 		bl	etharp_request
 2102 00e8 0346     		mov	r3, r0
 2103 00ea 87F82F30 		strb	r3, [r7, #47]
1058:../lwip-1.4.1/src/netif/etharp.c ****     if (result != ERR_OK) {
1059:../lwip-1.4.1/src/netif/etharp.c ****       /* ARP request couldn't be sent */
1060:../lwip-1.4.1/src/netif/etharp.c ****       /* We don't re-send arp request in etharp_tmr, but we still queue packets,
1061:../lwip-1.4.1/src/netif/etharp.c ****          since this failure could be temporary, and the next packet calling
1062:../lwip-1.4.1/src/netif/etharp.c ****          etharp_query again could lead to sending the queued packets. */
1063:../lwip-1.4.1/src/netif/etharp.c ****     }
1064:../lwip-1.4.1/src/netif/etharp.c ****     if (q == NULL) {
 2104              		.loc 1 1064 0
 2105 00ee 7B68     		ldr	r3, [r7, #4]
 2106 00f0 002B     		cmp	r3, #0
 2107 00f2 02D1     		bne	.L119
1065:../lwip-1.4.1/src/netif/etharp.c ****       return result;
 2108              		.loc 1 1065 0
 2109 00f4 97F82F30 		ldrb	r3, [r7, #47]	@ zero_extendqisi2
 2110 00f8 B5E0     		b	.L113
 2111              	.L119:
1066:../lwip-1.4.1/src/netif/etharp.c ****     }
1067:../lwip-1.4.1/src/netif/etharp.c ****   }
1068:../lwip-1.4.1/src/netif/etharp.c **** 
1069:../lwip-1.4.1/src/netif/etharp.c ****   /* packet given? */
1070:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
1071:../lwip-1.4.1/src/netif/etharp.c ****   /* stable entry? */
1072:../lwip-1.4.1/src/netif/etharp.c ****   if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 2112              		.loc 1 1072 0
 2113 00fa 97F91B20 		ldrsb	r2, [r7, #27]
 2114 00fe 5D49     		ldr	r1, .L138+4
 2115 0100 1346     		mov	r3, r2
 2116 0102 9B00     		lsls	r3, r3, #2
 2117 0104 1344     		add	r3, r3, r2
 2118 0106 9B00     		lsls	r3, r3, #2
 2119 0108 0B44     		add	r3, r3, r1
 2120 010a 1033     		adds	r3, r3, #16
 2121 010c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2122 010e 012B     		cmp	r3, #1
 2123 0110 15D9     		bls	.L120
1073:../lwip-1.4.1/src/netif/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
1074:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_SET_HINT(netif, i);
 2124              		.loc 1 1074 0
 2125 0112 FA7E     		ldrb	r2, [r7, #27]	@ zero_extendqisi2
 2126 0114 584B     		ldr	r3, .L138+8
 2127 0116 1A70     		strb	r2, [r3]
1075:../lwip-1.4.1/src/netif/etharp.c ****     /* send the packet */
1076:../lwip-1.4.1/src/netif/etharp.c ****     result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 2128              		.loc 1 1076 0
 2129 0118 97F91B20 		ldrsb	r2, [r7, #27]
 2130 011c 1346     		mov	r3, r2
 2131 011e 9B00     		lsls	r3, r3, #2
 2132 0120 1344     		add	r3, r3, r2
 2133 0122 9B00     		lsls	r3, r3, #2
 2134 0124 0833     		adds	r3, r3, #8
 2135 0126 534A     		ldr	r2, .L138+4
 2136 0128 1344     		add	r3, r3, r2
 2137 012a 0433     		adds	r3, r3, #4
 2138 012c F868     		ldr	r0, [r7, #12]
 2139 012e 7968     		ldr	r1, [r7, #4]
 2140 0130 FA69     		ldr	r2, [r7, #28]
 2141 0132 FFF7FEFF 		bl	etharp_send_ip
 2142 0136 0346     		mov	r3, r0
 2143 0138 87F82F30 		strb	r3, [r7, #47]
 2144 013c 91E0     		b	.L121
 2145              	.L120:
1077:../lwip-1.4.1/src/netif/etharp.c ****   /* pending entry? (either just created or already pending */
1078:../lwip-1.4.1/src/netif/etharp.c ****   } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 2146              		.loc 1 1078 0
 2147 013e 97F91B20 		ldrsb	r2, [r7, #27]
 2148 0142 4C49     		ldr	r1, .L138+4
 2149 0144 1346     		mov	r3, r2
 2150 0146 9B00     		lsls	r3, r3, #2
 2151 0148 1344     		add	r3, r3, r2
 2152 014a 9B00     		lsls	r3, r3, #2
 2153 014c 0B44     		add	r3, r3, r1
 2154 014e 1033     		adds	r3, r3, #16
 2155 0150 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2156 0152 012B     		cmp	r3, #1
 2157 0154 40F08580 		bne	.L121
 2158              	.LBB7:
1079:../lwip-1.4.1/src/netif/etharp.c ****     /* entry is still pending, queue the given packet 'q' */
1080:../lwip-1.4.1/src/netif/etharp.c ****     struct pbuf *p;
1081:../lwip-1.4.1/src/netif/etharp.c ****     int copy_needed = 0;
 2159              		.loc 1 1081 0
 2160 0158 0023     		movs	r3, #0
 2161 015a 7B62     		str	r3, [r7, #36]
1082:../lwip-1.4.1/src/netif/etharp.c ****     /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
1083:../lwip-1.4.1/src/netif/etharp.c ****      * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
1084:../lwip-1.4.1/src/netif/etharp.c ****      * PBUF_ROMs can be left as they are, since ROM must not get changed. */
1085:../lwip-1.4.1/src/netif/etharp.c ****     p = q;
 2162              		.loc 1 1085 0
 2163 015c 7B68     		ldr	r3, [r7, #4]
 2164 015e BB62     		str	r3, [r7, #40]
1086:../lwip-1.4.1/src/netif/etharp.c ****     while (p) {
 2165              		.loc 1 1086 0
 2166 0160 0EE0     		b	.L122
 2167              	.L126:
1087:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 2168              		.loc 1 1087 0
 2169 0162 BB6A     		ldr	r3, [r7, #40]
 2170 0164 5A89     		ldrh	r2, [r3, #10]
 2171 0166 BB6A     		ldr	r3, [r7, #40]
 2172 0168 1B89     		ldrh	r3, [r3, #8]
 2173 016a 9A42     		cmp	r2, r3
1088:../lwip-1.4.1/src/netif/etharp.c ****       if(p->type != PBUF_ROM) {
 2174              		.loc 1 1088 0
 2175 016c BB6A     		ldr	r3, [r7, #40]
 2176 016e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2177 0170 012B     		cmp	r3, #1
 2178 0172 02D0     		beq	.L124
1089:../lwip-1.4.1/src/netif/etharp.c ****         copy_needed = 1;
 2179              		.loc 1 1089 0
 2180 0174 0123     		movs	r3, #1
 2181 0176 7B62     		str	r3, [r7, #36]
1090:../lwip-1.4.1/src/netif/etharp.c ****         break;
 2182              		.loc 1 1090 0
 2183 0178 05E0     		b	.L125
 2184              	.L124:
1091:../lwip-1.4.1/src/netif/etharp.c ****       }
1092:../lwip-1.4.1/src/netif/etharp.c ****       p = p->next;
 2185              		.loc 1 1092 0
 2186 017a BB6A     		ldr	r3, [r7, #40]
 2187 017c 1B68     		ldr	r3, [r3]
 2188 017e BB62     		str	r3, [r7, #40]
 2189              	.L122:
1086:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 2190              		.loc 1 1086 0
 2191 0180 BB6A     		ldr	r3, [r7, #40]
 2192 0182 002B     		cmp	r3, #0
 2193 0184 EDD1     		bne	.L126
 2194              	.L125:
1093:../lwip-1.4.1/src/netif/etharp.c ****     }
1094:../lwip-1.4.1/src/netif/etharp.c ****     if(copy_needed) {
 2195              		.loc 1 1094 0
 2196 0186 7B6A     		ldr	r3, [r7, #36]
 2197 0188 002B     		cmp	r3, #0
 2198 018a 17D0     		beq	.L127
1095:../lwip-1.4.1/src/netif/etharp.c ****       /* copy the whole packet into new pbufs */
1096:../lwip-1.4.1/src/netif/etharp.c ****       p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 2199              		.loc 1 1096 0
 2200 018c BB6A     		ldr	r3, [r7, #40]
 2201 018e 1B89     		ldrh	r3, [r3, #8]
 2202 0190 0320     		movs	r0, #3
 2203 0192 1946     		mov	r1, r3
 2204 0194 0022     		movs	r2, #0
 2205 0196 FFF7FEFF 		bl	pbuf_alloc
 2206 019a B862     		str	r0, [r7, #40]
1097:../lwip-1.4.1/src/netif/etharp.c ****       if(p != NULL) {
 2207              		.loc 1 1097 0
 2208 019c BB6A     		ldr	r3, [r7, #40]
 2209 019e 002B     		cmp	r3, #0
 2210 01a0 11D0     		beq	.L129
1098:../lwip-1.4.1/src/netif/etharp.c ****         if (pbuf_copy(p, q) != ERR_OK) {
 2211              		.loc 1 1098 0
 2212 01a2 B86A     		ldr	r0, [r7, #40]
 2213 01a4 7968     		ldr	r1, [r7, #4]
 2214 01a6 FFF7FEFF 		bl	pbuf_copy
 2215 01aa 0346     		mov	r3, r0
 2216 01ac 002B     		cmp	r3, #0
 2217 01ae 0AD0     		beq	.L129
1099:../lwip-1.4.1/src/netif/etharp.c ****           pbuf_free(p);
 2218              		.loc 1 1099 0
 2219 01b0 B86A     		ldr	r0, [r7, #40]
 2220 01b2 FFF7FEFF 		bl	pbuf_free
1100:../lwip-1.4.1/src/netif/etharp.c ****           p = NULL;
 2221              		.loc 1 1100 0
 2222 01b6 0023     		movs	r3, #0
 2223 01b8 BB62     		str	r3, [r7, #40]
 2224 01ba 04E0     		b	.L129
 2225              	.L127:
1101:../lwip-1.4.1/src/netif/etharp.c ****         }
1102:../lwip-1.4.1/src/netif/etharp.c ****       }
1103:../lwip-1.4.1/src/netif/etharp.c ****     } else {
1104:../lwip-1.4.1/src/netif/etharp.c ****       /* referencing the old pbuf is enough */
1105:../lwip-1.4.1/src/netif/etharp.c ****       p = q;
 2226              		.loc 1 1105 0
 2227 01bc 7B68     		ldr	r3, [r7, #4]
 2228 01be BB62     		str	r3, [r7, #40]
1106:../lwip-1.4.1/src/netif/etharp.c ****       pbuf_ref(p);
 2229              		.loc 1 1106 0
 2230 01c0 B86A     		ldr	r0, [r7, #40]
 2231 01c2 FFF7FEFF 		bl	pbuf_ref
 2232              	.L129:
1107:../lwip-1.4.1/src/netif/etharp.c ****     }
1108:../lwip-1.4.1/src/netif/etharp.c ****     /* packet could be taken over? */
1109:../lwip-1.4.1/src/netif/etharp.c ****     if (p != NULL) {
 2233              		.loc 1 1109 0
 2234 01c6 BB6A     		ldr	r3, [r7, #40]
 2235 01c8 002B     		cmp	r3, #0
 2236 01ca 42D0     		beq	.L130
 2237              	.LBB8:
1110:../lwip-1.4.1/src/netif/etharp.c ****       /* queue packet ... */
1111:../lwip-1.4.1/src/netif/etharp.c **** #if ARP_QUEUEING
1112:../lwip-1.4.1/src/netif/etharp.c ****       struct etharp_q_entry *new_entry;
1113:../lwip-1.4.1/src/netif/etharp.c ****       /* allocate a new arp queue entry */
1114:../lwip-1.4.1/src/netif/etharp.c ****       new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
 2238              		.loc 1 1114 0
 2239 01cc 0720     		movs	r0, #7
 2240 01ce FFF7FEFF 		bl	memp_malloc
 2241 01d2 7861     		str	r0, [r7, #20]
1115:../lwip-1.4.1/src/netif/etharp.c ****       if (new_entry != NULL) {
 2242              		.loc 1 1115 0
 2243 01d4 7B69     		ldr	r3, [r7, #20]
 2244 01d6 002B     		cmp	r3, #0
 2245 01d8 34D0     		beq	.L131
1116:../lwip-1.4.1/src/netif/etharp.c ****         new_entry->next = 0;
 2246              		.loc 1 1116 0
 2247 01da 7B69     		ldr	r3, [r7, #20]
 2248 01dc 0022     		movs	r2, #0
 2249 01de 1A60     		str	r2, [r3]
1117:../lwip-1.4.1/src/netif/etharp.c ****         new_entry->p = p;
 2250              		.loc 1 1117 0
 2251 01e0 7B69     		ldr	r3, [r7, #20]
 2252 01e2 BA6A     		ldr	r2, [r7, #40]
 2253 01e4 5A60     		str	r2, [r3, #4]
1118:../lwip-1.4.1/src/netif/etharp.c ****         if(arp_table[i].q != NULL) {
 2254              		.loc 1 1118 0
 2255 01e6 97F91B20 		ldrsb	r2, [r7, #27]
 2256 01ea 2249     		ldr	r1, .L138+4
 2257 01ec 1346     		mov	r3, r2
 2258 01ee 9B00     		lsls	r3, r3, #2
 2259 01f0 1344     		add	r3, r3, r2
 2260 01f2 9B00     		lsls	r3, r3, #2
 2261 01f4 0B44     		add	r3, r3, r1
 2262 01f6 1B68     		ldr	r3, [r3]
 2263 01f8 002B     		cmp	r3, #0
 2264 01fa 15D0     		beq	.L132
 2265              	.LBB9:
1119:../lwip-1.4.1/src/netif/etharp.c ****           /* queue was already existent, append the new entry to the end */
1120:../lwip-1.4.1/src/netif/etharp.c ****           struct etharp_q_entry *r;
1121:../lwip-1.4.1/src/netif/etharp.c ****           r = arp_table[i].q;
 2266              		.loc 1 1121 0
 2267 01fc 97F91B20 		ldrsb	r2, [r7, #27]
 2268 0200 1C49     		ldr	r1, .L138+4
 2269 0202 1346     		mov	r3, r2
 2270 0204 9B00     		lsls	r3, r3, #2
 2271 0206 1344     		add	r3, r3, r2
 2272 0208 9B00     		lsls	r3, r3, #2
 2273 020a 0B44     		add	r3, r3, r1
 2274 020c 1B68     		ldr	r3, [r3]
 2275 020e 3B62     		str	r3, [r7, #32]
1122:../lwip-1.4.1/src/netif/etharp.c ****           while (r->next != NULL) {
 2276              		.loc 1 1122 0
 2277 0210 02E0     		b	.L133
 2278              	.L134:
1123:../lwip-1.4.1/src/netif/etharp.c ****             r = r->next;
 2279              		.loc 1 1123 0
 2280 0212 3B6A     		ldr	r3, [r7, #32]
 2281 0214 1B68     		ldr	r3, [r3]
 2282 0216 3B62     		str	r3, [r7, #32]
 2283              	.L133:
1122:../lwip-1.4.1/src/netif/etharp.c ****           while (r->next != NULL) {
 2284              		.loc 1 1122 0
 2285 0218 3B6A     		ldr	r3, [r7, #32]
 2286 021a 1B68     		ldr	r3, [r3]
 2287 021c 002B     		cmp	r3, #0
 2288 021e F8D1     		bne	.L134
1124:../lwip-1.4.1/src/netif/etharp.c ****           }
1125:../lwip-1.4.1/src/netif/etharp.c ****           r->next = new_entry;
 2289              		.loc 1 1125 0
 2290 0220 3B6A     		ldr	r3, [r7, #32]
 2291 0222 7A69     		ldr	r2, [r7, #20]
 2292 0224 1A60     		str	r2, [r3]
 2293              	.LBE9:
 2294 0226 09E0     		b	.L137
 2295              	.L132:
1126:../lwip-1.4.1/src/netif/etharp.c ****         } else {
1127:../lwip-1.4.1/src/netif/etharp.c ****           /* queue did not exist, first item in queue */
1128:../lwip-1.4.1/src/netif/etharp.c ****           arp_table[i].q = new_entry;
 2296              		.loc 1 1128 0
 2297 0228 97F91B20 		ldrsb	r2, [r7, #27]
 2298 022c 1149     		ldr	r1, .L138+4
 2299 022e 1346     		mov	r3, r2
 2300 0230 9B00     		lsls	r3, r3, #2
 2301 0232 1344     		add	r3, r3, r2
 2302 0234 9B00     		lsls	r3, r3, #2
 2303 0236 0B44     		add	r3, r3, r1
 2304 0238 7A69     		ldr	r2, [r7, #20]
 2305 023a 1A60     		str	r2, [r3]
 2306              	.L137:
1129:../lwip-1.4.1/src/netif/etharp.c ****         }
1130:../lwip-1.4.1/src/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"
1131:../lwip-1.4.1/src/netif/etharp.c ****         result = ERR_OK;
 2307              		.loc 1 1131 0
 2308 023c 0023     		movs	r3, #0
 2309 023e 87F82F30 		strb	r3, [r7, #47]
 2310 0242 0EE0     		b	.L121
 2311              	.L131:
1132:../lwip-1.4.1/src/netif/etharp.c ****       } else {
1133:../lwip-1.4.1/src/netif/etharp.c ****         /* the pool MEMP_ARP_QUEUE is empty */
1134:../lwip-1.4.1/src/netif/etharp.c ****         pbuf_free(p);
 2312              		.loc 1 1134 0
 2313 0244 B86A     		ldr	r0, [r7, #40]
 2314 0246 FFF7FEFF 		bl	pbuf_free
1135:../lwip-1.4.1/src/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_R
1136:../lwip-1.4.1/src/netif/etharp.c ****         result = ERR_MEM;
 2315              		.loc 1 1136 0
 2316 024a FF23     		movs	r3, #255
 2317 024c 87F82F30 		strb	r3, [r7, #47]
 2318              	.LBE8:
 2319 0250 07E0     		b	.L121
 2320              	.L130:
1137:../lwip-1.4.1/src/netif/etharp.c ****       }
1138:../lwip-1.4.1/src/netif/etharp.c **** #else /* ARP_QUEUEING */
1139:../lwip-1.4.1/src/netif/etharp.c ****       /* always queue one packet per ARP request only, freeing a previously queued packet */
1140:../lwip-1.4.1/src/netif/etharp.c ****       if (arp_table[i].q != NULL) {
1141:../lwip-1.4.1/src/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet
1142:../lwip-1.4.1/src/netif/etharp.c ****         pbuf_free(arp_table[i].q);
1143:../lwip-1.4.1/src/netif/etharp.c ****       }
1144:../lwip-1.4.1/src/netif/etharp.c ****       arp_table[i].q = p;
1145:../lwip-1.4.1/src/netif/etharp.c ****       result = ERR_OK;
1146:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S1
1147:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ARP_QUEUEING */
1148:../lwip-1.4.1/src/netif/etharp.c ****     } else {
1149:../lwip-1.4.1/src/netif/etharp.c ****       ETHARP_STATS_INC(etharp.memerr);
 2321              		.loc 1 1149 0
 2322 0252 074B     		ldr	r3, .L138
 2323 0254 9B6C     		ldr	r3, [r3, #72]
 2324 0256 0133     		adds	r3, r3, #1
 2325 0258 054A     		ldr	r2, .L138
 2326 025a 9364     		str	r3, [r2, #72]
1150:../lwip-1.4.1/src/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF
1151:../lwip-1.4.1/src/netif/etharp.c ****       result = ERR_MEM;
 2327              		.loc 1 1151 0
 2328 025c FF23     		movs	r3, #255
 2329 025e 87F82F30 		strb	r3, [r7, #47]
 2330              	.L121:
 2331              	.LBE7:
1152:../lwip-1.4.1/src/netif/etharp.c ****     }
1153:../lwip-1.4.1/src/netif/etharp.c ****   }
1154:../lwip-1.4.1/src/netif/etharp.c ****   return result;
 2332              		.loc 1 1154 0
 2333 0262 97F82F30 		ldrb	r3, [r7, #47]	@ zero_extendqisi2
 2334              	.L113:
 2335 0266 5BB2     		sxtb	r3, r3
1155:../lwip-1.4.1/src/netif/etharp.c **** }
 2336              		.loc 1 1155 0
 2337 0268 1846     		mov	r0, r3
 2338 026a 3037     		adds	r7, r7, #48
 2339              		.cfi_def_cfa_offset 8
 2340 026c BD46     		mov	sp, r7
 2341              		.cfi_def_cfa_register 13
 2342              		@ sp needed
 2343 026e 80BD     		pop	{r7, pc}
 2344              	.L139:
 2345              		.align	2
 2346              	.L138:
 2347 0270 00000000 		.word	lwip_stats
 2348 0274 00000000 		.word	arp_table
 2349 0278 C8000000 		.word	etharp_cached_entry
 2350              		.cfi_endproc
 2351              	.LFE12:
 2353              		.section	.text.etharp_raw,"ax",%progbits
 2354              		.align	2
 2355              		.thumb
 2356              		.thumb_func
 2358              	etharp_raw:
 2359              	.LFB13:
1156:../lwip-1.4.1/src/netif/etharp.c **** 
1157:../lwip-1.4.1/src/netif/etharp.c **** /**
1158:../lwip-1.4.1/src/netif/etharp.c ****  * Send a raw ARP packet (opcode and all addresses can be modified)
1159:../lwip-1.4.1/src/netif/etharp.c ****  *
1160:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif the lwip network interface on which to send the ARP packet
1161:../lwip-1.4.1/src/netif/etharp.c ****  * @param ethsrc_addr the source MAC address for the ethernet header
1162:../lwip-1.4.1/src/netif/etharp.c ****  * @param ethdst_addr the destination MAC address for the ethernet header
1163:../lwip-1.4.1/src/netif/etharp.c ****  * @param hwsrc_addr the source MAC address for the ARP protocol header
1164:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipsrc_addr the source IP address for the ARP protocol header
1165:../lwip-1.4.1/src/netif/etharp.c ****  * @param hwdst_addr the destination MAC address for the ARP protocol header
1166:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipdst_addr the destination IP address for the ARP protocol header
1167:../lwip-1.4.1/src/netif/etharp.c ****  * @param opcode the type of the ARP packet
1168:../lwip-1.4.1/src/netif/etharp.c ****  * @return ERR_OK if the ARP packet has been sent
1169:../lwip-1.4.1/src/netif/etharp.c ****  *         ERR_MEM if the ARP packet couldn't be allocated
1170:../lwip-1.4.1/src/netif/etharp.c ****  *         any other err_t on failure
1171:../lwip-1.4.1/src/netif/etharp.c ****  */
1172:../lwip-1.4.1/src/netif/etharp.c **** #if !LWIP_AUTOIP
1173:../lwip-1.4.1/src/netif/etharp.c **** static
1174:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1175:../lwip-1.4.1/src/netif/etharp.c **** err_t
1176:../lwip-1.4.1/src/netif/etharp.c **** etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
1177:../lwip-1.4.1/src/netif/etharp.c ****            const struct eth_addr *ethdst_addr,
1178:../lwip-1.4.1/src/netif/etharp.c ****            const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
1179:../lwip-1.4.1/src/netif/etharp.c ****            const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
1180:../lwip-1.4.1/src/netif/etharp.c ****            const u16_t opcode)
1181:../lwip-1.4.1/src/netif/etharp.c **** {
 2360              		.loc 1 1181 0
 2361              		.cfi_startproc
 2362              		@ args = 16, pretend = 0, frame = 32
 2363              		@ frame_needed = 1, uses_anonymous_args = 0
 2364 0000 80B5     		push	{r7, lr}
 2365              		.cfi_def_cfa_offset 8
 2366              		.cfi_offset 7, -8
 2367              		.cfi_offset 14, -4
 2368 0002 88B0     		sub	sp, sp, #32
 2369              		.cfi_def_cfa_offset 40
 2370 0004 00AF     		add	r7, sp, #0
 2371              		.cfi_def_cfa_register 7
 2372 0006 F860     		str	r0, [r7, #12]
 2373 0008 B960     		str	r1, [r7, #8]
 2374 000a 7A60     		str	r2, [r7, #4]
 2375 000c 3B60     		str	r3, [r7]
1182:../lwip-1.4.1/src/netif/etharp.c ****   struct pbuf *p;
1183:../lwip-1.4.1/src/netif/etharp.c ****   err_t result = ERR_OK;
 2376              		.loc 1 1183 0
 2377 000e 0023     		movs	r3, #0
 2378 0010 FB77     		strb	r3, [r7, #31]
1184:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_hdr *ethhdr;
1185:../lwip-1.4.1/src/netif/etharp.c ****   struct etharp_hdr *hdr;
1186:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
1187:../lwip-1.4.1/src/netif/etharp.c ****   const u8_t * ethdst_hwaddr;
1188:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1189:../lwip-1.4.1/src/netif/etharp.c **** 
1190:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
1191:../lwip-1.4.1/src/netif/etharp.c **** 
1192:../lwip-1.4.1/src/netif/etharp.c ****   /* allocate a pbuf for the outgoing ARP request packet */
1193:../lwip-1.4.1/src/netif/etharp.c ****   p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 2379              		.loc 1 1193 0
 2380 0012 0320     		movs	r0, #3
 2381 0014 2A21     		movs	r1, #42
 2382 0016 0022     		movs	r2, #0
 2383 0018 FFF7FEFF 		bl	pbuf_alloc
 2384 001c B861     		str	r0, [r7, #24]
1194:../lwip-1.4.1/src/netif/etharp.c ****   /* could allocate a pbuf for an ARP request? */
1195:../lwip-1.4.1/src/netif/etharp.c ****   if (p == NULL) {
 2385              		.loc 1 1195 0
 2386 001e BB69     		ldr	r3, [r7, #24]
 2387 0020 002B     		cmp	r3, #0
 2388 0022 06D1     		bne	.L141
1196:../lwip-1.4.1/src/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
1197:../lwip-1.4.1/src/netif/etharp.c ****       ("etharp_raw: could not allocate pbuf for ARP request.\n"));
1198:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.memerr);
 2389              		.loc 1 1198 0
 2390 0024 384B     		ldr	r3, .L143
 2391 0026 9B6C     		ldr	r3, [r3, #72]
 2392 0028 0133     		adds	r3, r3, #1
 2393 002a 374A     		ldr	r2, .L143
 2394 002c 9364     		str	r3, [r2, #72]
1199:../lwip-1.4.1/src/netif/etharp.c ****     return ERR_MEM;
 2395              		.loc 1 1199 0
 2396 002e FF23     		movs	r3, #255
 2397 0030 65E0     		b	.L142
 2398              	.L141:
1200:../lwip-1.4.1/src/netif/etharp.c ****   }
1201:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
1202:../lwip-1.4.1/src/netif/etharp.c ****               (p->len >= SIZEOF_ETHARP_PACKET));
1203:../lwip-1.4.1/src/netif/etharp.c **** 
1204:../lwip-1.4.1/src/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 2399              		.loc 1 1204 0
 2400 0032 BB69     		ldr	r3, [r7, #24]
 2401 0034 5B68     		ldr	r3, [r3, #4]
 2402 0036 7B61     		str	r3, [r7, #20]
1205:../lwip-1.4.1/src/netif/etharp.c ****   hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 2403              		.loc 1 1205 0
 2404 0038 7B69     		ldr	r3, [r7, #20]
 2405 003a 0E33     		adds	r3, r3, #14
 2406 003c 3B61     		str	r3, [r7, #16]
1206:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
1207:../lwip-1.4.1/src/netif/etharp.c ****   hdr->opcode = htons(opcode);
 2407              		.loc 1 1207 0
 2408 003e BB8E     		ldrh	r3, [r7, #52]
 2409 0040 1846     		mov	r0, r3
 2410 0042 FFF7FEFF 		bl	lwip_htons
 2411 0046 0346     		mov	r3, r0
 2412 0048 1A46     		mov	r2, r3
 2413 004a 3B69     		ldr	r3, [r7, #16]
 2414 004c DA80     		strh	r2, [r3, #6]	@ unaligned
1208:../lwip-1.4.1/src/netif/etharp.c **** 
1209:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
1210:../lwip-1.4.1/src/netif/etharp.c ****               (netif->hwaddr_len == ETHARP_HWADDR_LEN));
1211:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
1212:../lwip-1.4.1/src/netif/etharp.c ****   /* If we are using Link-Local, all ARP packets that contain a Link-Local
1213:../lwip-1.4.1/src/netif/etharp.c ****    * 'sender IP address' MUST be sent using link-layer broadcast instead of
1214:../lwip-1.4.1/src/netif/etharp.c ****    * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
1215:../lwip-1.4.1/src/netif/etharp.c ****   ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
1216:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1217:../lwip-1.4.1/src/netif/etharp.c ****   /* Write the ARP MAC-Addresses */
1218:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 2415              		.loc 1 1218 0
 2416 004e 3B69     		ldr	r3, [r7, #16]
 2417 0050 0833     		adds	r3, r3, #8
 2418 0052 1846     		mov	r0, r3
 2419 0054 3968     		ldr	r1, [r7]
 2420 0056 0622     		movs	r2, #6
 2421 0058 FFF7FEFF 		bl	memcpy
1219:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 2422              		.loc 1 1219 0
 2423 005c 3B69     		ldr	r3, [r7, #16]
 2424 005e 1233     		adds	r3, r3, #18
 2425 0060 1846     		mov	r0, r3
 2426 0062 F96A     		ldr	r1, [r7, #44]
 2427 0064 0622     		movs	r2, #6
 2428 0066 FFF7FEFF 		bl	memcpy
1220:../lwip-1.4.1/src/netif/etharp.c ****   /* Write the Ethernet MAC-Addresses */
1221:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_AUTOIP
1222:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
1223:../lwip-1.4.1/src/netif/etharp.c **** #else  /* LWIP_AUTOIP */
1224:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 2429              		.loc 1 1224 0
 2430 006a 7B69     		ldr	r3, [r7, #20]
 2431 006c 1846     		mov	r0, r3
 2432 006e 7968     		ldr	r1, [r7, #4]
 2433 0070 0622     		movs	r2, #6
 2434 0072 FFF7FEFF 		bl	memcpy
1225:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1226:../lwip-1.4.1/src/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 2435              		.loc 1 1226 0
 2436 0076 7B69     		ldr	r3, [r7, #20]
 2437 0078 0633     		adds	r3, r3, #6
 2438 007a 1846     		mov	r0, r3
 2439 007c B968     		ldr	r1, [r7, #8]
 2440 007e 0622     		movs	r2, #6
 2441 0080 FFF7FEFF 		bl	memcpy
1227:../lwip-1.4.1/src/netif/etharp.c ****   /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
1228:../lwip-1.4.1/src/netif/etharp.c ****    * structure packing. */ 
1229:../lwip-1.4.1/src/netif/etharp.c ****   IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 2442              		.loc 1 1229 0
 2443 0084 3B69     		ldr	r3, [r7, #16]
 2444 0086 0E33     		adds	r3, r3, #14
 2445 0088 1846     		mov	r0, r3
 2446 008a B96A     		ldr	r1, [r7, #40]
 2447 008c 0422     		movs	r2, #4
 2448 008e FFF7FEFF 		bl	memcpy
1230:../lwip-1.4.1/src/netif/etharp.c ****   IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 2449              		.loc 1 1230 0
 2450 0092 3B69     		ldr	r3, [r7, #16]
 2451 0094 1833     		adds	r3, r3, #24
 2452 0096 1846     		mov	r0, r3
 2453 0098 396B     		ldr	r1, [r7, #48]
 2454 009a 0422     		movs	r2, #4
 2455 009c FFF7FEFF 		bl	memcpy
1231:../lwip-1.4.1/src/netif/etharp.c **** 
1232:../lwip-1.4.1/src/netif/etharp.c ****   hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 2456              		.loc 1 1232 0
 2457 00a0 3B69     		ldr	r3, [r7, #16]
 2458 00a2 0022     		movs	r2, #0
 2459 00a4 1A70     		strb	r2, [r3]
 2460 00a6 0022     		movs	r2, #0
 2461 00a8 42F00102 		orr	r2, r2, #1
 2462 00ac 5A70     		strb	r2, [r3, #1]
1233:../lwip-1.4.1/src/netif/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 2463              		.loc 1 1233 0
 2464 00ae 3B69     		ldr	r3, [r7, #16]
 2465 00b0 0022     		movs	r2, #0
 2466 00b2 42F00802 		orr	r2, r2, #8
 2467 00b6 9A70     		strb	r2, [r3, #2]
 2468 00b8 0022     		movs	r2, #0
 2469 00ba DA70     		strb	r2, [r3, #3]
1234:../lwip-1.4.1/src/netif/etharp.c ****   /* set hwlen and protolen */
1235:../lwip-1.4.1/src/netif/etharp.c ****   hdr->hwlen = ETHARP_HWADDR_LEN;
 2470              		.loc 1 1235 0
 2471 00bc 3B69     		ldr	r3, [r7, #16]
 2472 00be 0622     		movs	r2, #6
 2473 00c0 1A71     		strb	r2, [r3, #4]
1236:../lwip-1.4.1/src/netif/etharp.c ****   hdr->protolen = sizeof(ip_addr_t);
 2474              		.loc 1 1236 0
 2475 00c2 3B69     		ldr	r3, [r7, #16]
 2476 00c4 0422     		movs	r2, #4
 2477 00c6 5A71     		strb	r2, [r3, #5]
1237:../lwip-1.4.1/src/netif/etharp.c **** 
1238:../lwip-1.4.1/src/netif/etharp.c ****   ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 2478              		.loc 1 1238 0
 2479 00c8 7B69     		ldr	r3, [r7, #20]
 2480 00ca 0022     		movs	r2, #0
 2481 00cc 42F00802 		orr	r2, r2, #8
 2482 00d0 1A73     		strb	r2, [r3, #12]
 2483 00d2 0022     		movs	r2, #0
 2484 00d4 42F00602 		orr	r2, r2, #6
 2485 00d8 5A73     		strb	r2, [r3, #13]
1239:../lwip-1.4.1/src/netif/etharp.c ****   /* send ARP query */
1240:../lwip-1.4.1/src/netif/etharp.c ****   result = netif->linkoutput(netif, p);
 2486              		.loc 1 1240 0
 2487 00da FB68     		ldr	r3, [r7, #12]
 2488 00dc 9B69     		ldr	r3, [r3, #24]
 2489 00de F868     		ldr	r0, [r7, #12]
 2490 00e0 B969     		ldr	r1, [r7, #24]
 2491 00e2 9847     		blx	r3
 2492 00e4 0346     		mov	r3, r0
 2493 00e6 FB77     		strb	r3, [r7, #31]
1241:../lwip-1.4.1/src/netif/etharp.c ****   ETHARP_STATS_INC(etharp.xmit);
 2494              		.loc 1 1241 0
 2495 00e8 074B     		ldr	r3, .L143
 2496 00ea 1B6B     		ldr	r3, [r3, #48]
 2497 00ec 0133     		adds	r3, r3, #1
 2498 00ee 064A     		ldr	r2, .L143
 2499 00f0 1363     		str	r3, [r2, #48]
1242:../lwip-1.4.1/src/netif/etharp.c ****   /* free ARP query packet */
1243:../lwip-1.4.1/src/netif/etharp.c ****   pbuf_free(p);
 2500              		.loc 1 1243 0
 2501 00f2 B869     		ldr	r0, [r7, #24]
 2502 00f4 FFF7FEFF 		bl	pbuf_free
1244:../lwip-1.4.1/src/netif/etharp.c ****   p = NULL;
 2503              		.loc 1 1244 0
 2504 00f8 0023     		movs	r3, #0
 2505 00fa BB61     		str	r3, [r7, #24]
1245:../lwip-1.4.1/src/netif/etharp.c ****   /* could not allocate pbuf for ARP request */
1246:../lwip-1.4.1/src/netif/etharp.c **** 
1247:../lwip-1.4.1/src/netif/etharp.c ****   return result;
 2506              		.loc 1 1247 0
 2507 00fc FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 2508              	.L142:
 2509 00fe 5BB2     		sxtb	r3, r3
1248:../lwip-1.4.1/src/netif/etharp.c **** }
 2510              		.loc 1 1248 0
 2511 0100 1846     		mov	r0, r3
 2512 0102 2037     		adds	r7, r7, #32
 2513              		.cfi_def_cfa_offset 8
 2514 0104 BD46     		mov	sp, r7
 2515              		.cfi_def_cfa_register 13
 2516              		@ sp needed
 2517 0106 80BD     		pop	{r7, pc}
 2518              	.L144:
 2519              		.align	2
 2520              	.L143:
 2521 0108 00000000 		.word	lwip_stats
 2522              		.cfi_endproc
 2523              	.LFE13:
 2525              		.section	.text.etharp_request,"ax",%progbits
 2526              		.align	2
 2527              		.global	etharp_request
 2528              		.thumb
 2529              		.thumb_func
 2531              	etharp_request:
 2532              	.LFB14:
1249:../lwip-1.4.1/src/netif/etharp.c **** 
1250:../lwip-1.4.1/src/netif/etharp.c **** /**
1251:../lwip-1.4.1/src/netif/etharp.c ****  * Send an ARP request packet asking for ipaddr.
1252:../lwip-1.4.1/src/netif/etharp.c ****  *
1253:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif the lwip network interface on which to send the request
1254:../lwip-1.4.1/src/netif/etharp.c ****  * @param ipaddr the IP address for which to ask
1255:../lwip-1.4.1/src/netif/etharp.c ****  * @return ERR_OK if the request has been sent
1256:../lwip-1.4.1/src/netif/etharp.c ****  *         ERR_MEM if the ARP packet couldn't be allocated
1257:../lwip-1.4.1/src/netif/etharp.c ****  *         any other err_t on failure
1258:../lwip-1.4.1/src/netif/etharp.c ****  */
1259:../lwip-1.4.1/src/netif/etharp.c **** err_t
1260:../lwip-1.4.1/src/netif/etharp.c **** etharp_request(struct netif *netif, ip_addr_t *ipaddr)
1261:../lwip-1.4.1/src/netif/etharp.c **** {
 2533              		.loc 1 1261 0
 2534              		.cfi_startproc
 2535              		@ args = 0, pretend = 0, frame = 8
 2536              		@ frame_needed = 1, uses_anonymous_args = 0
 2537 0000 90B5     		push	{r4, r7, lr}
 2538              		.cfi_def_cfa_offset 12
 2539              		.cfi_offset 4, -12
 2540              		.cfi_offset 7, -8
 2541              		.cfi_offset 14, -4
 2542 0002 87B0     		sub	sp, sp, #28
 2543              		.cfi_def_cfa_offset 40
 2544 0004 04AF     		add	r7, sp, #16
 2545              		.cfi_def_cfa 7, 24
 2546 0006 7860     		str	r0, [r7, #4]
 2547 0008 3960     		str	r1, [r7]
1262:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
1263:../lwip-1.4.1/src/netif/etharp.c ****   return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 2548              		.loc 1 1263 0
 2549 000a 7B68     		ldr	r3, [r7, #4]
 2550 000c 03F12302 		add	r2, r3, #35
1264:../lwip-1.4.1/src/netif/etharp.c ****                     (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 2551              		.loc 1 1264 0
 2552 0010 7B68     		ldr	r3, [r7, #4]
 2553 0012 03F12304 		add	r4, r3, #35
 2554 0016 7B68     		ldr	r3, [r7, #4]
 2555 0018 0433     		adds	r3, r3, #4
1263:../lwip-1.4.1/src/netif/etharp.c ****                     (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 2556              		.loc 1 1263 0
 2557 001a 0093     		str	r3, [sp]
 2558 001c 084B     		ldr	r3, .L147
 2559 001e 0193     		str	r3, [sp, #4]
 2560 0020 3B68     		ldr	r3, [r7]
 2561 0022 0293     		str	r3, [sp, #8]
 2562 0024 0123     		movs	r3, #1
 2563 0026 0393     		str	r3, [sp, #12]
 2564 0028 7868     		ldr	r0, [r7, #4]
 2565 002a 1146     		mov	r1, r2
 2566 002c 054A     		ldr	r2, .L147+4
 2567 002e 2346     		mov	r3, r4
 2568 0030 FFF7FEFF 		bl	etharp_raw
 2569 0034 0346     		mov	r3, r0
1265:../lwip-1.4.1/src/netif/etharp.c ****                     ipaddr, ARP_REQUEST);
1266:../lwip-1.4.1/src/netif/etharp.c **** }
 2570              		.loc 1 1266 0
 2571 0036 1846     		mov	r0, r3
 2572 0038 0C37     		adds	r7, r7, #12
 2573              		.cfi_def_cfa_offset 12
 2574 003a BD46     		mov	sp, r7
 2575              		.cfi_def_cfa_register 13
 2576              		@ sp needed
 2577 003c 90BD     		pop	{r4, r7, pc}
 2578              	.L148:
 2579 003e 00BF     		.align	2
 2580              	.L147:
 2581 0040 00000000 		.word	ethzero
 2582 0044 00000000 		.word	ethbroadcast
 2583              		.cfi_endproc
 2584              	.LFE14:
 2586              		.section	.text.ethernet_input,"ax",%progbits
 2587              		.align	2
 2588              		.global	ethernet_input
 2589              		.thumb
 2590              		.thumb_func
 2592              	ethernet_input:
 2593              	.LFB15:
1267:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_ARP */
1268:../lwip-1.4.1/src/netif/etharp.c **** 
1269:../lwip-1.4.1/src/netif/etharp.c **** /**
1270:../lwip-1.4.1/src/netif/etharp.c ****  * Process received ethernet frames. Using this function instead of directly
1271:../lwip-1.4.1/src/netif/etharp.c ****  * calling ip_input and passing ARP frames through etharp in ethernetif_input,
1272:../lwip-1.4.1/src/netif/etharp.c ****  * the ARP cache is protected from concurrent access.
1273:../lwip-1.4.1/src/netif/etharp.c ****  *
1274:../lwip-1.4.1/src/netif/etharp.c ****  * @param p the recevied packet, p->payload pointing to the ethernet header
1275:../lwip-1.4.1/src/netif/etharp.c ****  * @param netif the network interface on which the packet was received
1276:../lwip-1.4.1/src/netif/etharp.c ****  */
1277:../lwip-1.4.1/src/netif/etharp.c **** err_t
1278:../lwip-1.4.1/src/netif/etharp.c **** ethernet_input(struct pbuf *p, struct netif *netif)
1279:../lwip-1.4.1/src/netif/etharp.c **** {
 2594              		.loc 1 1279 0
 2595              		.cfi_startproc
 2596              		@ args = 0, pretend = 0, frame = 24
 2597              		@ frame_needed = 1, uses_anonymous_args = 0
 2598 0000 80B5     		push	{r7, lr}
 2599              		.cfi_def_cfa_offset 8
 2600              		.cfi_offset 7, -8
 2601              		.cfi_offset 14, -4
 2602 0002 86B0     		sub	sp, sp, #24
 2603              		.cfi_def_cfa_offset 32
 2604 0004 00AF     		add	r7, sp, #0
 2605              		.cfi_def_cfa_register 7
 2606 0006 7860     		str	r0, [r7, #4]
 2607 0008 3960     		str	r1, [r7]
1280:../lwip-1.4.1/src/netif/etharp.c ****   struct eth_hdr* ethhdr;
1281:../lwip-1.4.1/src/netif/etharp.c ****   u16_t type;
1282:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_ARP || ETHARP_SUPPORT_VLAN
1283:../lwip-1.4.1/src/netif/etharp.c ****   s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
 2608              		.loc 1 1283 0
 2609 000a 0E23     		movs	r3, #14
 2610 000c FB82     		strh	r3, [r7, #22]	@ movhi
1284:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
1285:../lwip-1.4.1/src/netif/etharp.c **** 
1286:../lwip-1.4.1/src/netif/etharp.c ****   if (p->len <= SIZEOF_ETH_HDR) {
 2611              		.loc 1 1286 0
 2612 000e 7B68     		ldr	r3, [r7, #4]
 2613 0010 5B89     		ldrh	r3, [r3, #10]
 2614 0012 0E2B     		cmp	r3, #14
 2615 0014 0AD8     		bhi	.L150
1287:../lwip-1.4.1/src/netif/etharp.c ****     /* a packet with only an ethernet header (or less) is not valid for us */
1288:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.proterr);
 2616              		.loc 1 1288 0
 2617 0016 444B     		ldr	r3, .L164
 2618 0018 1B6D     		ldr	r3, [r3, #80]
 2619 001a 0133     		adds	r3, r3, #1
 2620 001c 424A     		ldr	r2, .L164
 2621 001e 1365     		str	r3, [r2, #80]
1289:../lwip-1.4.1/src/netif/etharp.c ****     ETHARP_STATS_INC(etharp.drop);
 2622              		.loc 1 1289 0
 2623 0020 414B     		ldr	r3, .L164
 2624 0022 DB6B     		ldr	r3, [r3, #60]
 2625 0024 0133     		adds	r3, r3, #1
 2626 0026 404A     		ldr	r2, .L164
 2627 0028 D363     		str	r3, [r2, #60]
1290:../lwip-1.4.1/src/netif/etharp.c ****     goto free_and_return;
 2628              		.loc 1 1290 0
 2629 002a 74E0     		b	.L151
 2630              	.L150:
1291:../lwip-1.4.1/src/netif/etharp.c ****   }
1292:../lwip-1.4.1/src/netif/etharp.c **** 
1293:../lwip-1.4.1/src/netif/etharp.c ****   /* points to packet payload, which starts with an Ethernet header */
1294:../lwip-1.4.1/src/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 2631              		.loc 1 1294 0
 2632 002c 7B68     		ldr	r3, [r7, #4]
 2633 002e 5B68     		ldr	r3, [r3, #4]
 2634 0030 3B61     		str	r3, [r7, #16]
1295:../lwip-1.4.1/src/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
1296:../lwip-1.4.1/src/netif/etharp.c ****     ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X
1297:../lwip-1.4.1/src/netif/etharp.c ****      (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2]
1298:../lwip-1.4.1/src/netif/etharp.c ****      (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5]
1299:../lwip-1.4.1/src/netif/etharp.c ****      (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
1300:../lwip-1.4.1/src/netif/etharp.c ****      (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
1301:../lwip-1.4.1/src/netif/etharp.c ****      (unsigned)htons(ethhdr->type)));
1302:../lwip-1.4.1/src/netif/etharp.c **** 
1303:../lwip-1.4.1/src/netif/etharp.c ****   type = ethhdr->type;
 2635              		.loc 1 1303 0
 2636 0032 3B69     		ldr	r3, [r7, #16]
 2637 0034 1A7B     		ldrb	r2, [r3, #12]	@ zero_extendqisi2
 2638 0036 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 2639 0038 1B02     		lsls	r3, r3, #8
 2640 003a 1343     		orrs	r3, r3, r2
 2641 003c FB81     		strh	r3, [r7, #14]	@ movhi
1304:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_SUPPORT_VLAN
1305:../lwip-1.4.1/src/netif/etharp.c ****   if (type == PP_HTONS(ETHTYPE_VLAN)) {
1306:../lwip-1.4.1/src/netif/etharp.c ****     struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
1307:../lwip-1.4.1/src/netif/etharp.c ****     if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
1308:../lwip-1.4.1/src/netif/etharp.c ****       /* a packet with only an ethernet/vlan header (or less) is not valid for us */
1309:../lwip-1.4.1/src/netif/etharp.c ****       ETHARP_STATS_INC(etharp.proterr);
1310:../lwip-1.4.1/src/netif/etharp.c ****       ETHARP_STATS_INC(etharp.drop);
1311:../lwip-1.4.1/src/netif/etharp.c ****       goto free_and_return;
1312:../lwip-1.4.1/src/netif/etharp.c ****     }
1313:../lwip-1.4.1/src/netif/etharp.c **** #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
1314:../lwip-1.4.1/src/netif/etharp.c **** #ifdef ETHARP_VLAN_CHECK_FN
1315:../lwip-1.4.1/src/netif/etharp.c ****     if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
1316:../lwip-1.4.1/src/netif/etharp.c **** #elif defined(ETHARP_VLAN_CHECK)
1317:../lwip-1.4.1/src/netif/etharp.c ****     if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
1318:../lwip-1.4.1/src/netif/etharp.c **** #endif
1319:../lwip-1.4.1/src/netif/etharp.c ****       /* silently ignore this packet: not for our VLAN */
1320:../lwip-1.4.1/src/netif/etharp.c ****       pbuf_free(p);
1321:../lwip-1.4.1/src/netif/etharp.c ****       return ERR_OK;
1322:../lwip-1.4.1/src/netif/etharp.c ****     }
1323:../lwip-1.4.1/src/netif/etharp.c **** #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
1324:../lwip-1.4.1/src/netif/etharp.c ****     type = vlan->tpid;
1325:../lwip-1.4.1/src/netif/etharp.c ****     ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
1326:../lwip-1.4.1/src/netif/etharp.c ****   }
1327:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_SUPPORT_VLAN */
1328:../lwip-1.4.1/src/netif/etharp.c **** 
1329:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_ARP_FILTER_NETIF
1330:../lwip-1.4.1/src/netif/etharp.c ****   netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
1331:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_ARP_FILTER_NETIF*/
1332:../lwip-1.4.1/src/netif/etharp.c **** 
1333:../lwip-1.4.1/src/netif/etharp.c ****   if (ethhdr->dest.addr[0] & 1) {
 2642              		.loc 1 1333 0
 2643 003e 3B69     		ldr	r3, [r7, #16]
 2644 0040 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2645 0042 03F00103 		and	r3, r3, #1
 2646 0046 002B     		cmp	r3, #0
 2647 0048 23D0     		beq	.L152
1334:../lwip-1.4.1/src/netif/etharp.c ****     /* this might be a multicast or broadcast packet */
1335:../lwip-1.4.1/src/netif/etharp.c ****     if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 2648              		.loc 1 1335 0
 2649 004a 3B69     		ldr	r3, [r7, #16]
 2650 004c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2651 004e 012B     		cmp	r3, #1
 2652 0050 0FD1     		bne	.L153
1336:../lwip-1.4.1/src/netif/etharp.c ****       if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 2653              		.loc 1 1336 0
 2654 0052 3B69     		ldr	r3, [r7, #16]
 2655 0054 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2656 0056 002B     		cmp	r3, #0
 2657 0058 1BD1     		bne	.L152
1337:../lwip-1.4.1/src/netif/etharp.c ****           (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
 2658              		.loc 1 1337 0 discriminator 1
 2659 005a 3B69     		ldr	r3, [r7, #16]
 2660 005c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
1336:../lwip-1.4.1/src/netif/etharp.c ****       if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 2661              		.loc 1 1336 0 discriminator 1
 2662 005e 5E2B     		cmp	r3, #94
 2663 0060 17D1     		bne	.L152
1338:../lwip-1.4.1/src/netif/etharp.c ****         /* mark the pbuf as link-layer multicast */
1339:../lwip-1.4.1/src/netif/etharp.c ****         p->flags |= PBUF_FLAG_LLMCAST;
 2664              		.loc 1 1339 0
 2665 0062 7B68     		ldr	r3, [r7, #4]
 2666 0064 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 2667 0066 43F01003 		orr	r3, r3, #16
 2668 006a DAB2     		uxtb	r2, r3
 2669 006c 7B68     		ldr	r3, [r7, #4]
 2670 006e 5A73     		strb	r2, [r3, #13]
 2671 0070 0FE0     		b	.L152
 2672              	.L153:
1340:../lwip-1.4.1/src/netif/etharp.c ****       }
1341:../lwip-1.4.1/src/netif/etharp.c ****     } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 2673              		.loc 1 1341 0
 2674 0072 3B69     		ldr	r3, [r7, #16]
 2675 0074 1846     		mov	r0, r3
 2676 0076 2D49     		ldr	r1, .L164+4
 2677 0078 0622     		movs	r2, #6
 2678 007a FFF7FEFF 		bl	memcmp
 2679 007e 0346     		mov	r3, r0
 2680 0080 002B     		cmp	r3, #0
 2681 0082 06D1     		bne	.L152
1342:../lwip-1.4.1/src/netif/etharp.c ****       /* mark the pbuf as link-layer broadcast */
1343:../lwip-1.4.1/src/netif/etharp.c ****       p->flags |= PBUF_FLAG_LLBCAST;
 2682              		.loc 1 1343 0
 2683 0084 7B68     		ldr	r3, [r7, #4]
 2684 0086 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 2685 0088 43F00803 		orr	r3, r3, #8
 2686 008c DAB2     		uxtb	r2, r3
 2687 008e 7B68     		ldr	r3, [r7, #4]
 2688 0090 5A73     		strb	r2, [r3, #13]
 2689              	.L152:
1344:../lwip-1.4.1/src/netif/etharp.c ****     }
1345:../lwip-1.4.1/src/netif/etharp.c ****   }
1346:../lwip-1.4.1/src/netif/etharp.c **** 
1347:../lwip-1.4.1/src/netif/etharp.c ****   switch (type) {
 2690              		.loc 1 1347 0
 2691 0092 FB89     		ldrh	r3, [r7, #14]
 2692 0094 082B     		cmp	r3, #8
 2693 0096 03D0     		beq	.L156
 2694 0098 B3F5C16F 		cmp	r3, #1544
 2695 009c 1ED0     		beq	.L157
 2696 009e 2DE0     		b	.L163
 2697              	.L156:
1348:../lwip-1.4.1/src/netif/etharp.c **** #if LWIP_ARP
1349:../lwip-1.4.1/src/netif/etharp.c ****     /* IP packet? */
1350:../lwip-1.4.1/src/netif/etharp.c ****     case PP_HTONS(ETHTYPE_IP):
1351:../lwip-1.4.1/src/netif/etharp.c ****       if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 2698              		.loc 1 1351 0
 2699 00a0 3B68     		ldr	r3, [r7]
 2700 00a2 93F82930 		ldrb	r3, [r3, #41]	@ zero_extendqisi2
 2701 00a6 03F02003 		and	r3, r3, #32
 2702 00aa 002B     		cmp	r3, #0
 2703 00ac 00D1     		bne	.L158
1352:../lwip-1.4.1/src/netif/etharp.c ****         goto free_and_return;
 2704              		.loc 1 1352 0
 2705 00ae 32E0     		b	.L151
 2706              	.L158:
1353:../lwip-1.4.1/src/netif/etharp.c ****       }
1354:../lwip-1.4.1/src/netif/etharp.c **** #if ETHARP_TRUST_IP_MAC
1355:../lwip-1.4.1/src/netif/etharp.c ****       /* update ARP table */
1356:../lwip-1.4.1/src/netif/etharp.c ****       etharp_ip_input(netif, p);
 2707              		.loc 1 1356 0
 2708 00b0 3868     		ldr	r0, [r7]
 2709 00b2 7968     		ldr	r1, [r7, #4]
 2710 00b4 FFF7FEFF 		bl	etharp_ip_input
1357:../lwip-1.4.1/src/netif/etharp.c **** #endif /* ETHARP_TRUST_IP_MAC */
1358:../lwip-1.4.1/src/netif/etharp.c ****       /* skip Ethernet header */
1359:../lwip-1.4.1/src/netif/etharp.c ****       if(pbuf_header(p, -ip_hdr_offset)) {
 2711              		.loc 1 1359 0
 2712 00b8 FB8A     		ldrh	r3, [r7, #22]
 2713 00ba 5B42     		negs	r3, r3
 2714 00bc 9BB2     		uxth	r3, r3
 2715 00be 9BB2     		uxth	r3, r3
 2716 00c0 1BB2     		sxth	r3, r3
 2717 00c2 7868     		ldr	r0, [r7, #4]
 2718 00c4 1946     		mov	r1, r3
 2719 00c6 FFF7FEFF 		bl	pbuf_header
 2720 00ca 0346     		mov	r3, r0
 2721 00cc 002B     		cmp	r3, #0
 2722 00ce 00D0     		beq	.L159
1360:../lwip-1.4.1/src/netif/etharp.c ****         LWIP_ASSERT("Can't move over header in packet", 0);
1361:../lwip-1.4.1/src/netif/etharp.c ****         goto free_and_return;
 2723              		.loc 1 1361 0
 2724 00d0 21E0     		b	.L151
 2725              	.L159:
1362:../lwip-1.4.1/src/netif/etharp.c ****       } else {
1363:../lwip-1.4.1/src/netif/etharp.c ****         /* pass to IP layer */
1364:../lwip-1.4.1/src/netif/etharp.c ****         ip_input(p, netif);
 2726              		.loc 1 1364 0
 2727 00d2 7868     		ldr	r0, [r7, #4]
 2728 00d4 3968     		ldr	r1, [r7]
 2729 00d6 FFF7FEFF 		bl	ip_input
1365:../lwip-1.4.1/src/netif/etharp.c ****       }
1366:../lwip-1.4.1/src/netif/etharp.c ****       break;
 2730              		.loc 1 1366 0
 2731 00da 1AE0     		b	.L160
 2732              	.L157:
1367:../lwip-1.4.1/src/netif/etharp.c ****       
1368:../lwip-1.4.1/src/netif/etharp.c ****     case PP_HTONS(ETHTYPE_ARP):
1369:../lwip-1.4.1/src/netif/etharp.c ****       if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 2733              		.loc 1 1369 0
 2734 00dc 3B68     		ldr	r3, [r7]
 2735 00de 93F82930 		ldrb	r3, [r3, #41]	@ zero_extendqisi2
 2736 00e2 03F02003 		and	r3, r3, #32
 2737 00e6 002B     		cmp	r3, #0
 2738 00e8 00D1     		bne	.L161
1370:../lwip-1.4.1/src/netif/etharp.c ****         goto free_and_return;
 2739              		.loc 1 1370 0
 2740 00ea 14E0     		b	.L151
 2741              	.L161:
1371:../lwip-1.4.1/src/netif/etharp.c ****       }
1372:../lwip-1.4.1/src/netif/etharp.c ****       /* pass p to ARP module */
1373:../lwip-1.4.1/src/netif/etharp.c ****       etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 2742              		.loc 1 1373 0
 2743 00ec 3B68     		ldr	r3, [r7]
 2744 00ee 2333     		adds	r3, r3, #35
 2745 00f0 3868     		ldr	r0, [r7]
 2746 00f2 1946     		mov	r1, r3
 2747 00f4 7A68     		ldr	r2, [r7, #4]
 2748 00f6 FFF7FEFF 		bl	etharp_arp_input
1374:../lwip-1.4.1/src/netif/etharp.c ****       break;
 2749              		.loc 1 1374 0
 2750 00fa 0AE0     		b	.L160
 2751              	.L163:
1375:../lwip-1.4.1/src/netif/etharp.c **** #endif /* LWIP_ARP */
1376:../lwip-1.4.1/src/netif/etharp.c **** #if PPPOE_SUPPORT
1377:../lwip-1.4.1/src/netif/etharp.c ****     case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
1378:../lwip-1.4.1/src/netif/etharp.c ****       pppoe_disc_input(netif, p);
1379:../lwip-1.4.1/src/netif/etharp.c ****       break;
1380:../lwip-1.4.1/src/netif/etharp.c **** 
1381:../lwip-1.4.1/src/netif/etharp.c ****     case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
1382:../lwip-1.4.1/src/netif/etharp.c ****       pppoe_data_input(netif, p);
1383:../lwip-1.4.1/src/netif/etharp.c ****       break;
1384:../lwip-1.4.1/src/netif/etharp.c **** #endif /* PPPOE_SUPPORT */
1385:../lwip-1.4.1/src/netif/etharp.c **** 
1386:../lwip-1.4.1/src/netif/etharp.c ****     default:
1387:../lwip-1.4.1/src/netif/etharp.c ****       ETHARP_STATS_INC(etharp.proterr);
 2752              		.loc 1 1387 0
 2753 00fc 0A4B     		ldr	r3, .L164
 2754 00fe 1B6D     		ldr	r3, [r3, #80]
 2755 0100 0133     		adds	r3, r3, #1
 2756 0102 094A     		ldr	r2, .L164
 2757 0104 1365     		str	r3, [r2, #80]
1388:../lwip-1.4.1/src/netif/etharp.c ****       ETHARP_STATS_INC(etharp.drop);
 2758              		.loc 1 1388 0
 2759 0106 084B     		ldr	r3, .L164
 2760 0108 DB6B     		ldr	r3, [r3, #60]
 2761 010a 0133     		adds	r3, r3, #1
 2762 010c 064A     		ldr	r2, .L164
 2763 010e D363     		str	r3, [r2, #60]
1389:../lwip-1.4.1/src/netif/etharp.c ****       goto free_and_return;
 2764              		.loc 1 1389 0
 2765 0110 01E0     		b	.L151
 2766              	.L160:
1390:../lwip-1.4.1/src/netif/etharp.c ****   }
1391:../lwip-1.4.1/src/netif/etharp.c **** 
1392:../lwip-1.4.1/src/netif/etharp.c ****   /* This means the pbuf is freed or consumed,
1393:../lwip-1.4.1/src/netif/etharp.c ****      so the caller doesn't have to free it again */
1394:../lwip-1.4.1/src/netif/etharp.c ****   return ERR_OK;
 2767              		.loc 1 1394 0
 2768 0112 0023     		movs	r3, #0
 2769 0114 03E0     		b	.L162
 2770              	.L151:
1395:../lwip-1.4.1/src/netif/etharp.c **** 
1396:../lwip-1.4.1/src/netif/etharp.c **** free_and_return:
1397:../lwip-1.4.1/src/netif/etharp.c ****   pbuf_free(p);
 2771              		.loc 1 1397 0
 2772 0116 7868     		ldr	r0, [r7, #4]
 2773 0118 FFF7FEFF 		bl	pbuf_free
1398:../lwip-1.4.1/src/netif/etharp.c ****   return ERR_OK;
 2774              		.loc 1 1398 0
 2775 011c 0023     		movs	r3, #0
 2776              	.L162:
 2777 011e 5BB2     		sxtb	r3, r3
1399:../lwip-1.4.1/src/netif/etharp.c **** }
 2778              		.loc 1 1399 0
 2779 0120 1846     		mov	r0, r3
 2780 0122 1837     		adds	r7, r7, #24
 2781              		.cfi_def_cfa_offset 8
 2782 0124 BD46     		mov	sp, r7
 2783              		.cfi_def_cfa_register 13
 2784              		@ sp needed
 2785 0126 80BD     		pop	{r7, pc}
 2786              	.L165:
 2787              		.align	2
 2788              	.L164:
 2789 0128 00000000 		.word	lwip_stats
 2790 012c 00000000 		.word	ethbroadcast
 2791              		.cfi_endproc
 2792              	.LFE15:
 2794              		.text
 2795              	.Letext0:
 2796              		.file 2 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\port/arch/cc.h"
 2797              		.file 3 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip/
 2798              		.file 4 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/err.h"
 2799              		.file 5 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/pbuf.h
 2800              		.file 6 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/netif.
 2801              		.file 7 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip/
 2802              		.file 8 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/mem.h"
 2803              		.file 9 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/memp.h
 2804              		.file 10 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/stats
 2805              		.file 11 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/netif/etha
DEFINED SYMBOLS
                            *ABS*:00000000 etharp.c
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:23     .rodata:00000000 ethbroadcast
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:20     .rodata:00000000 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:34     .rodata:00000008 ethzero
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:37     .bss:00000000 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:38     .bss:00000000 arp_table
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:40     .bss:000000c8 etharp_cached_entry
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:43     .text.free_etharp_q:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:47     .text.free_etharp_q:00000000 free_etharp_q
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:98     .text.etharp_free_entry:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:102    .text.etharp_free_entry:00000000 etharp_free_entry
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:264    .text.etharp_free_entry:00000110 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:269    .text.etharp_tmr:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:274    .text.etharp_tmr:00000000 etharp_tmr
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:426    .text.etharp_tmr:000000e0 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:431    .text.etharp_find_entry:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:435    .text.etharp_find_entry:00000000 etharp_find_entry
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:761    .text.etharp_find_entry:000001f8 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:766    .text.etharp_send_ip:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:770    .text.etharp_send_ip:00000000 etharp_send_ip
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:831    .text.etharp_update_arp_entry:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:835    .text.etharp_update_arp_entry:00000000 etharp_update_arp_entry
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1019   .text.etharp_update_arp_entry:0000012c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1024   .text.etharp_cleanup_netif:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1029   .text.etharp_cleanup_netif:00000000 etharp_cleanup_netif
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1103   .text.etharp_cleanup_netif:0000005c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1108   .text.etharp_find_addr:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1113   .text.etharp_find_addr:00000000 etharp_find_addr
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1195   .text.etharp_find_addr:00000078 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1200   .text.etharp_ip_input:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1204   .text.etharp_ip_input:00000000 etharp_ip_input
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1272   .text.etharp_arp_input:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1276   .text.etharp_arp_input:00000000 etharp_arp_input
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1562   .text.etharp_arp_input:000001cc $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1567   .text.etharp_output_to_arp_index:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1571   .text.etharp_output_to_arp_index:00000000 etharp_output_to_arp_index
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2531   .text.etharp_request:00000000 etharp_request
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1678   .text.etharp_output_to_arp_index:000000a4 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1683   .text.etharp_output:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1688   .text.etharp_output:00000000 etharp_output
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1959   .text.etharp_query:00000000 etharp_query
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1946   .text.etharp_output:00000198 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:1954   .text.etharp_query:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2347   .text.etharp_query:00000270 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2354   .text.etharp_raw:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2358   .text.etharp_raw:00000000 etharp_raw
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2521   .text.etharp_raw:00000108 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2526   .text.etharp_request:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2581   .text.etharp_request:00000040 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2587   .text.ethernet_input:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2592   .text.ethernet_input:00000000 ethernet_input
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccuupsXb.s:2789   .text.ethernet_input:00000128 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.2d80f1b5ce3c69d13e258577ddf29668
                           .group:00000000 wm4.lwipopts.h.25.76e03deb318fbe54d896a83c1b611e55
                           .group:00000000 wm4.arch.h.33.6fa4aa86d33d1490ae882caef7316405
                           .group:00000000 wm4.cpu.h.33.0ec64ad8cd52614da6479c7936fa3efa
                           .group:00000000 wm4.cc.h.49.217a0c46a6dd8448cb36cccbf00f897f
                           .group:00000000 wm4.arch.h.52.2e97dbd839a1aa815d8c47878a7f8e2b
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.24.b2be5f53932a9c9d07787288b29b6d75
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.82.82b71f3f44c70e3a459d0f66642b05eb
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.68.ff6d7571d3ad75c55f15e26dbaa81e35
                           .group:00000000 wm4.debug.h.45.223028a5c052c9f879ffd43dd519f3f1
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.opt.h.76.0e16bb9c23144e1f631b5b5afa9a69f6
                           .group:00000000 wm4.def.h.33.d4208c3cd3e0fc64e20a8b9f95a681f3
                           .group:00000000 wm4.ip_addr.h.92.064dfb1f61acc5ba1dffbdba3104a668
                           .group:00000000 wm4.err.h.33.909ff4b35439192d64931f0a04fc8fdb
                           .group:00000000 wm4.pbuf.h.45.444f43edbf93d1b2ead9ba1554355b0e
                           .group:00000000 wm4.netif.h.33.f0b62f0135b4c001826f0908df525042
                           .group:00000000 wm4.ip.h.48.c2e3a3e3a9e009c03a30eff6a88b0a33
                           .group:00000000 wm4.mem.h.33.ae21028c0b1f3dc3305003fc71edaf5a
                           .group:00000000 wm4.memp.h.34.a409f52ec6d44b5681de26eb10b0c08b
                           .group:00000000 wm4.memp_std.h.15.637bb4287b70e9d70dbd8dd3c6f62f3b
                           .group:00000000 wm4.stats.h.51.0db2d210618aedce9edea4fb7e0fbaf1
                           .group:00000000 wm4.snmp.h.34.65cd272594ba53b669353bfbd8cfaef5
                           .group:00000000 wm4.etharp.h.36.01a1086ca2aee91a18155b6f03ca98c6

UNDEFINED SYMBOLS
pbuf_free
memp_free
memcpy
ip4_addr_isbroadcast
lwip_htons
lwip_stats
pbuf_header
pbuf_alloc
pbuf_copy
pbuf_ref
memp_malloc
memcmp
ip_input
