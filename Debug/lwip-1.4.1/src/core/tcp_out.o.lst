   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tcp_out.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.tcp_output_alloc_header,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	tcp_output_alloc_header:
  24              	.LFB0:
  25              		.file 1 "../lwip-1.4.1/src/core/tcp_out.c"
   1:../lwip-1.4.1/src/core/tcp_out.c **** /**
   2:../lwip-1.4.1/src/core/tcp_out.c ****  * @file
   3:../lwip-1.4.1/src/core/tcp_out.c ****  * Transmission Control Protocol, outgoing traffic
   4:../lwip-1.4.1/src/core/tcp_out.c ****  *
   5:../lwip-1.4.1/src/core/tcp_out.c ****  * The output functions of TCP.
   6:../lwip-1.4.1/src/core/tcp_out.c ****  *
   7:../lwip-1.4.1/src/core/tcp_out.c ****  */
   8:../lwip-1.4.1/src/core/tcp_out.c **** 
   9:../lwip-1.4.1/src/core/tcp_out.c **** /*
  10:../lwip-1.4.1/src/core/tcp_out.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  11:../lwip-1.4.1/src/core/tcp_out.c ****  * All rights reserved.
  12:../lwip-1.4.1/src/core/tcp_out.c ****  *
  13:../lwip-1.4.1/src/core/tcp_out.c ****  * Redistribution and use in source and binary forms, with or without modification,
  14:../lwip-1.4.1/src/core/tcp_out.c ****  * are permitted provided that the following conditions are met:
  15:../lwip-1.4.1/src/core/tcp_out.c ****  *
  16:../lwip-1.4.1/src/core/tcp_out.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../lwip-1.4.1/src/core/tcp_out.c ****  *    this list of conditions and the following disclaimer.
  18:../lwip-1.4.1/src/core/tcp_out.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../lwip-1.4.1/src/core/tcp_out.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:../lwip-1.4.1/src/core/tcp_out.c ****  *    and/or other materials provided with the distribution.
  21:../lwip-1.4.1/src/core/tcp_out.c ****  * 3. The name of the author may not be used to endorse or promote products
  22:../lwip-1.4.1/src/core/tcp_out.c ****  *    derived from this software without specific prior written permission.
  23:../lwip-1.4.1/src/core/tcp_out.c ****  *
  24:../lwip-1.4.1/src/core/tcp_out.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  25:../lwip-1.4.1/src/core/tcp_out.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  26:../lwip-1.4.1/src/core/tcp_out.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  27:../lwip-1.4.1/src/core/tcp_out.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  28:../lwip-1.4.1/src/core/tcp_out.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  29:../lwip-1.4.1/src/core/tcp_out.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  30:../lwip-1.4.1/src/core/tcp_out.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  31:../lwip-1.4.1/src/core/tcp_out.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  32:../lwip-1.4.1/src/core/tcp_out.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  33:../lwip-1.4.1/src/core/tcp_out.c ****  * OF SUCH DAMAGE.
  34:../lwip-1.4.1/src/core/tcp_out.c ****  *
  35:../lwip-1.4.1/src/core/tcp_out.c ****  * This file is part of the lwIP TCP/IP stack.
  36:../lwip-1.4.1/src/core/tcp_out.c ****  *
  37:../lwip-1.4.1/src/core/tcp_out.c ****  * Author: Adam Dunkels <adam@sics.se>
  38:../lwip-1.4.1/src/core/tcp_out.c ****  *
  39:../lwip-1.4.1/src/core/tcp_out.c ****  */
  40:../lwip-1.4.1/src/core/tcp_out.c **** 
  41:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/opt.h"
  42:../lwip-1.4.1/src/core/tcp_out.c **** 
  43:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
  44:../lwip-1.4.1/src/core/tcp_out.c **** 
  45:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/tcp_impl.h"
  46:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/def.h"
  47:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/mem.h"
  48:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/memp.h"
  49:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/ip_addr.h"
  50:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/netif.h"
  51:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/inet_chksum.h"
  52:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/stats.h"
  53:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/snmp.h"
  54:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
  55:../lwip-1.4.1/src/core/tcp_out.c **** #include "lwip/sys.h"
  56:../lwip-1.4.1/src/core/tcp_out.c **** #endif
  57:../lwip-1.4.1/src/core/tcp_out.c **** 
  58:../lwip-1.4.1/src/core/tcp_out.c **** #include <string.h>
  59:../lwip-1.4.1/src/core/tcp_out.c **** 
  60:../lwip-1.4.1/src/core/tcp_out.c **** /* Define some copy-macros for checksum-on-copy so that the code looks
  61:../lwip-1.4.1/src/core/tcp_out.c ****    nicer by preventing too many ifdef's. */
  62:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
  63:../lwip-1.4.1/src/core/tcp_out.c **** #define TCP_DATA_COPY(dst, src, len, seg) do { \
  64:../lwip-1.4.1/src/core/tcp_out.c ****   tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), \
  65:../lwip-1.4.1/src/core/tcp_out.c ****                      len, &seg->chksum, &seg->chksum_swapped); \
  66:../lwip-1.4.1/src/core/tcp_out.c ****   seg->flags |= TF_SEG_DATA_CHECKSUMMED; } while(0)
  67:../lwip-1.4.1/src/core/tcp_out.c **** #define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped)  \
  68:../lwip-1.4.1/src/core/tcp_out.c ****   tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), len, chksum, chksum_swapped);
  69:../lwip-1.4.1/src/core/tcp_out.c **** #else /* TCP_CHECKSUM_ON_COPY*/
  70:../lwip-1.4.1/src/core/tcp_out.c **** #define TCP_DATA_COPY(dst, src, len, seg)                     MEMCPY(dst, src, len)
  71:../lwip-1.4.1/src/core/tcp_out.c **** #define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped) MEMCPY(dst, src, len)
  72:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY*/
  73:../lwip-1.4.1/src/core/tcp_out.c **** 
  74:../lwip-1.4.1/src/core/tcp_out.c **** /** Define this to 1 for an extra check that the output checksum is valid
  75:../lwip-1.4.1/src/core/tcp_out.c ****  * (usefule when the checksum is generated by the application, not the stack) */
  76:../lwip-1.4.1/src/core/tcp_out.c **** #ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK
  77:../lwip-1.4.1/src/core/tcp_out.c **** #define TCP_CHECKSUM_ON_COPY_SANITY_CHECK   0
  78:../lwip-1.4.1/src/core/tcp_out.c **** #endif
  79:../lwip-1.4.1/src/core/tcp_out.c **** 
  80:../lwip-1.4.1/src/core/tcp_out.c **** /* Forward declarations.*/
  81:../lwip-1.4.1/src/core/tcp_out.c **** static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);
  82:../lwip-1.4.1/src/core/tcp_out.c **** 
  83:../lwip-1.4.1/src/core/tcp_out.c **** /** Allocate a pbuf and create a tcphdr at p->payload, used for output
  84:../lwip-1.4.1/src/core/tcp_out.c ****  * functions other than the default tcp_output -> tcp_output_segment
  85:../lwip-1.4.1/src/core/tcp_out.c ****  * (e.g. tcp_send_empty_ack, etc.)
  86:../lwip-1.4.1/src/core/tcp_out.c ****  *
  87:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb tcp pcb for which to send a packet (used to initialize tcp_hdr)
  88:../lwip-1.4.1/src/core/tcp_out.c ****  * @param optlen length of header-options
  89:../lwip-1.4.1/src/core/tcp_out.c ****  * @param datalen length of tcp data to reserve in pbuf
  90:../lwip-1.4.1/src/core/tcp_out.c ****  * @param seqno_be seqno in network byte order (big-endian)
  91:../lwip-1.4.1/src/core/tcp_out.c ****  * @return pbuf with p->payload being the tcp_hdr
  92:../lwip-1.4.1/src/core/tcp_out.c ****  */
  93:../lwip-1.4.1/src/core/tcp_out.c **** static struct pbuf *
  94:../lwip-1.4.1/src/core/tcp_out.c **** tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
  95:../lwip-1.4.1/src/core/tcp_out.c ****                       u32_t seqno_be /* already in network byte order */)
  96:../lwip-1.4.1/src/core/tcp_out.c **** {
  26              		.loc 1 96 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 24
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30 0000 80B5     		push	{r7, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 7, -8
  33              		.cfi_offset 14, -4
  34 0002 86B0     		sub	sp, sp, #24
  35              		.cfi_def_cfa_offset 32
  36 0004 00AF     		add	r7, sp, #0
  37              		.cfi_def_cfa_register 7
  38 0006 F860     		str	r0, [r7, #12]
  39 0008 7B60     		str	r3, [r7, #4]
  40 000a 0B46     		mov	r3, r1	@ movhi
  41 000c 7B81     		strh	r3, [r7, #10]	@ movhi
  42 000e 1346     		mov	r3, r2	@ movhi
  43 0010 3B81     		strh	r3, [r7, #8]	@ movhi
  97:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
  98:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  44              		.loc 1 98 0
  45 0012 7A89     		ldrh	r2, [r7, #10]	@ movhi
  46 0014 3B89     		ldrh	r3, [r7, #8]	@ movhi
  47 0016 1344     		add	r3, r3, r2
  48 0018 9BB2     		uxth	r3, r3
  49 001a 1433     		adds	r3, r3, #20
  50 001c 9BB2     		uxth	r3, r3
  51 001e 0120     		movs	r0, #1
  52 0020 1946     		mov	r1, r3
  53 0022 0022     		movs	r2, #0
  54 0024 FFF7FEFF 		bl	pbuf_alloc
  55 0028 7861     		str	r0, [r7, #20]
  99:../lwip-1.4.1/src/core/tcp_out.c ****   if (p != NULL) {
  56              		.loc 1 99 0
  57 002a 7B69     		ldr	r3, [r7, #20]
  58 002c 002B     		cmp	r3, #0
  59 002e 4AD0     		beq	.L2
 100:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 101:../lwip-1.4.1/src/core/tcp_out.c ****                  (p->len >= TCP_HLEN + optlen));
 102:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr = (struct tcp_hdr *)p->payload;
  60              		.loc 1 102 0
  61 0030 7B69     		ldr	r3, [r7, #20]
  62 0032 5B68     		ldr	r3, [r3, #4]
  63 0034 3B61     		str	r3, [r7, #16]
 103:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr->src = htons(pcb->local_port);
  64              		.loc 1 103 0
  65 0036 FB68     		ldr	r3, [r7, #12]
  66 0038 5B8B     		ldrh	r3, [r3, #26]
  67 003a 1846     		mov	r0, r3
  68 003c FFF7FEFF 		bl	lwip_htons
  69 0040 0346     		mov	r3, r0
  70 0042 1A46     		mov	r2, r3
  71 0044 3B69     		ldr	r3, [r7, #16]
  72 0046 1A80     		strh	r2, [r3]	@ unaligned
 104:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr->dest = htons(pcb->remote_port);
  73              		.loc 1 104 0
  74 0048 FB68     		ldr	r3, [r7, #12]
  75 004a 9B8B     		ldrh	r3, [r3, #28]
  76 004c 1846     		mov	r0, r3
  77 004e FFF7FEFF 		bl	lwip_htons
  78 0052 0346     		mov	r3, r0
  79 0054 1A46     		mov	r2, r3
  80 0056 3B69     		ldr	r3, [r7, #16]
  81 0058 5A80     		strh	r2, [r3, #2]	@ unaligned
 105:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr->seqno = seqno_be;
  82              		.loc 1 105 0
  83 005a 3B69     		ldr	r3, [r7, #16]
  84 005c 7A68     		ldr	r2, [r7, #4]
  85 005e 5A60     		str	r2, [r3, #4]	@ unaligned
 106:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr->ackno = htonl(pcb->rcv_nxt);
  86              		.loc 1 106 0
  87 0060 FB68     		ldr	r3, [r7, #12]
  88 0062 9B6A     		ldr	r3, [r3, #40]
  89 0064 1846     		mov	r0, r3
  90 0066 FFF7FEFF 		bl	lwip_htonl
  91 006a 0246     		mov	r2, r0
  92 006c 3B69     		ldr	r3, [r7, #16]
  93 006e 9A60     		str	r2, [r3, #8]	@ unaligned
 107:../lwip-1.4.1/src/core/tcp_out.c ****     TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
  94              		.loc 1 107 0
  95 0070 7B89     		ldrh	r3, [r7, #10]
  96 0072 9B08     		lsrs	r3, r3, #2
  97 0074 9BB2     		uxth	r3, r3
  98 0076 0533     		adds	r3, r3, #5
  99 0078 9BB2     		uxth	r3, r3
 100 007a 1B03     		lsls	r3, r3, #12
 101 007c 9BB2     		uxth	r3, r3
 102 007e 43F01003 		orr	r3, r3, #16
 103 0082 9BB2     		uxth	r3, r3
 104 0084 1846     		mov	r0, r3
 105 0086 FFF7FEFF 		bl	lwip_htons
 106 008a 0346     		mov	r3, r0
 107 008c 1A46     		mov	r2, r3
 108 008e 3B69     		ldr	r3, [r7, #16]
 109 0090 9A81     		strh	r2, [r3, #12]	@ unaligned
 108:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 110              		.loc 1 108 0
 111 0092 FB68     		ldr	r3, [r7, #12]
 112 0094 DB8D     		ldrh	r3, [r3, #46]
 113 0096 1846     		mov	r0, r3
 114 0098 FFF7FEFF 		bl	lwip_htons
 115 009c 0346     		mov	r3, r0
 116 009e 1A46     		mov	r2, r3
 117 00a0 3B69     		ldr	r3, [r7, #16]
 118 00a2 DA81     		strh	r2, [r3, #14]	@ unaligned
 109:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr->chksum = 0;
 119              		.loc 1 109 0
 120 00a4 3B69     		ldr	r3, [r7, #16]
 121 00a6 0022     		movs	r2, #0
 122 00a8 1A74     		strb	r2, [r3, #16]
 123 00aa 0022     		movs	r2, #0
 124 00ac 5A74     		strb	r2, [r3, #17]
 110:../lwip-1.4.1/src/core/tcp_out.c ****     tcphdr->urgp = 0;
 125              		.loc 1 110 0
 126 00ae 3B69     		ldr	r3, [r7, #16]
 127 00b0 0022     		movs	r2, #0
 128 00b2 9A74     		strb	r2, [r3, #18]
 129 00b4 0022     		movs	r2, #0
 130 00b6 DA74     		strb	r2, [r3, #19]
 111:../lwip-1.4.1/src/core/tcp_out.c **** 
 112:../lwip-1.4.1/src/core/tcp_out.c ****     /* If we're sending a packet, update the announced right window edge */
 113:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 131              		.loc 1 113 0
 132 00b8 FB68     		ldr	r3, [r7, #12]
 133 00ba 9B6A     		ldr	r3, [r3, #40]
 134 00bc FA68     		ldr	r2, [r7, #12]
 135 00be D28D     		ldrh	r2, [r2, #46]
 136 00c0 1A44     		add	r2, r2, r3
 137 00c2 FB68     		ldr	r3, [r7, #12]
 138 00c4 1A63     		str	r2, [r3, #48]
 139              	.L2:
 114:../lwip-1.4.1/src/core/tcp_out.c ****   }
 115:../lwip-1.4.1/src/core/tcp_out.c ****   return p;
 140              		.loc 1 115 0
 141 00c6 7B69     		ldr	r3, [r7, #20]
 116:../lwip-1.4.1/src/core/tcp_out.c **** }
 142              		.loc 1 116 0
 143 00c8 1846     		mov	r0, r3
 144 00ca 1837     		adds	r7, r7, #24
 145              		.cfi_def_cfa_offset 8
 146 00cc BD46     		mov	sp, r7
 147              		.cfi_def_cfa_register 13
 148              		@ sp needed
 149 00ce 80BD     		pop	{r7, pc}
 150              		.cfi_endproc
 151              	.LFE0:
 153              		.section	.text.tcp_send_fin,"ax",%progbits
 154              		.align	2
 155              		.global	tcp_send_fin
 156              		.thumb
 157              		.thumb_func
 159              	tcp_send_fin:
 160              	.LFB1:
 117:../lwip-1.4.1/src/core/tcp_out.c **** 
 118:../lwip-1.4.1/src/core/tcp_out.c **** /**
 119:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_close() to send a segment including FIN flag but not data.
 120:../lwip-1.4.1/src/core/tcp_out.c ****  *
 121:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp_pcb over which to send a segment
 122:../lwip-1.4.1/src/core/tcp_out.c ****  * @return ERR_OK if sent, another err_t otherwise
 123:../lwip-1.4.1/src/core/tcp_out.c ****  */
 124:../lwip-1.4.1/src/core/tcp_out.c **** err_t
 125:../lwip-1.4.1/src/core/tcp_out.c **** tcp_send_fin(struct tcp_pcb *pcb)
 126:../lwip-1.4.1/src/core/tcp_out.c **** {
 161              		.loc 1 126 0
 162              		.cfi_startproc
 163              		@ args = 0, pretend = 0, frame = 16
 164              		@ frame_needed = 1, uses_anonymous_args = 0
 165 0000 B0B5     		push	{r4, r5, r7, lr}
 166              		.cfi_def_cfa_offset 16
 167              		.cfi_offset 4, -16
 168              		.cfi_offset 5, -12
 169              		.cfi_offset 7, -8
 170              		.cfi_offset 14, -4
 171 0002 84B0     		sub	sp, sp, #16
 172              		.cfi_def_cfa_offset 32
 173 0004 00AF     		add	r7, sp, #0
 174              		.cfi_def_cfa_register 7
 175 0006 7860     		str	r0, [r7, #4]
 127:../lwip-1.4.1/src/core/tcp_out.c ****   /* first, try to add the fin to the last unsent segment */
 128:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->unsent != NULL) {
 176              		.loc 1 128 0
 177 0008 7B68     		ldr	r3, [r7, #4]
 178 000a DB6E     		ldr	r3, [r3, #108]
 179 000c 002B     		cmp	r3, #0
 180 000e 2CD0     		beq	.L5
 181              	.LBB2:
 129:../lwip-1.4.1/src/core/tcp_out.c ****     struct tcp_seg *last_unsent;
 130:../lwip-1.4.1/src/core/tcp_out.c ****     for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 182              		.loc 1 130 0
 183 0010 7B68     		ldr	r3, [r7, #4]
 184 0012 DB6E     		ldr	r3, [r3, #108]
 185 0014 FB60     		str	r3, [r7, #12]
 186 0016 02E0     		b	.L6
 187              	.L7:
 131:../lwip-1.4.1/src/core/tcp_out.c ****          last_unsent = last_unsent->next);
 188              		.loc 1 131 0
 189 0018 FB68     		ldr	r3, [r7, #12]
 190 001a 1B68     		ldr	r3, [r3]
 191 001c FB60     		str	r3, [r7, #12]
 192              	.L6:
 130:../lwip-1.4.1/src/core/tcp_out.c ****          last_unsent = last_unsent->next);
 193              		.loc 1 130 0 discriminator 1
 194 001e FB68     		ldr	r3, [r7, #12]
 195 0020 1B68     		ldr	r3, [r3]
 196 0022 002B     		cmp	r3, #0
 197 0024 F8D1     		bne	.L7
 132:../lwip-1.4.1/src/core/tcp_out.c **** 
 133:../lwip-1.4.1/src/core/tcp_out.c ****     if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 198              		.loc 1 133 0
 199 0026 FB68     		ldr	r3, [r7, #12]
 200 0028 1B69     		ldr	r3, [r3, #16]
 201 002a 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 202 002c 9BB2     		uxth	r3, r3
 203 002e 1846     		mov	r0, r3
 204 0030 FFF7FEFF 		bl	lwip_ntohs
 205 0034 0346     		mov	r3, r0
 206 0036 03F00703 		and	r3, r3, #7
 207 003a 002B     		cmp	r3, #0
 208 003c 15D1     		bne	.L5
 134:../lwip-1.4.1/src/core/tcp_out.c ****       /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
 135:../lwip-1.4.1/src/core/tcp_out.c ****       TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 209              		.loc 1 135 0
 210 003e FB68     		ldr	r3, [r7, #12]
 211 0040 1C69     		ldr	r4, [r3, #16]
 212 0042 FB68     		ldr	r3, [r7, #12]
 213 0044 1B69     		ldr	r3, [r3, #16]
 214 0046 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 215 0048 9DB2     		uxth	r5, r3
 216 004a 0120     		movs	r0, #1
 217 004c FFF7FEFF 		bl	lwip_htons
 218 0050 0346     		mov	r3, r0
 219 0052 2B43     		orrs	r3, r3, r5
 220 0054 9BB2     		uxth	r3, r3
 221 0056 A381     		strh	r3, [r4, #12]	@ unaligned
 136:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->flags |= TF_FIN;
 222              		.loc 1 136 0
 223 0058 7B68     		ldr	r3, [r7, #4]
 224 005a 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 225 005c 43F02003 		orr	r3, r3, #32
 226 0060 DAB2     		uxtb	r2, r3
 227 0062 7B68     		ldr	r3, [r7, #4]
 228 0064 9A77     		strb	r2, [r3, #30]
 137:../lwip-1.4.1/src/core/tcp_out.c ****       return ERR_OK;
 229              		.loc 1 137 0
 230 0066 0023     		movs	r3, #0
 231 0068 04E0     		b	.L8
 232              	.L5:
 233              	.LBE2:
 138:../lwip-1.4.1/src/core/tcp_out.c ****     }
 139:../lwip-1.4.1/src/core/tcp_out.c ****   }
 140:../lwip-1.4.1/src/core/tcp_out.c ****   /* no data, no length, flags, copy=1, no optdata */
 141:../lwip-1.4.1/src/core/tcp_out.c ****   return tcp_enqueue_flags(pcb, TCP_FIN);
 234              		.loc 1 141 0
 235 006a 7868     		ldr	r0, [r7, #4]
 236 006c 0121     		movs	r1, #1
 237 006e FFF7FEFF 		bl	tcp_enqueue_flags
 238 0072 0346     		mov	r3, r0
 239              	.L8:
 240 0074 5BB2     		sxtb	r3, r3
 142:../lwip-1.4.1/src/core/tcp_out.c **** }
 241              		.loc 1 142 0
 242 0076 1846     		mov	r0, r3
 243 0078 1037     		adds	r7, r7, #16
 244              		.cfi_def_cfa_offset 16
 245 007a BD46     		mov	sp, r7
 246              		.cfi_def_cfa_register 13
 247              		@ sp needed
 248 007c B0BD     		pop	{r4, r5, r7, pc}
 249              		.cfi_endproc
 250              	.LFE1:
 252 007e 00BF     		.section	.text.tcp_create_segment,"ax",%progbits
 253              		.align	2
 254              		.thumb
 255              		.thumb_func
 257              	tcp_create_segment:
 258              	.LFB2:
 143:../lwip-1.4.1/src/core/tcp_out.c **** 
 144:../lwip-1.4.1/src/core/tcp_out.c **** /**
 145:../lwip-1.4.1/src/core/tcp_out.c ****  * Create a TCP segment with prefilled header.
 146:../lwip-1.4.1/src/core/tcp_out.c ****  *
 147:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_write and tcp_enqueue_flags.
 148:../lwip-1.4.1/src/core/tcp_out.c ****  *
 149:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection.
 150:../lwip-1.4.1/src/core/tcp_out.c ****  * @param p pbuf that is used to hold the TCP header.
 151:../lwip-1.4.1/src/core/tcp_out.c ****  * @param flags TCP flags for header.
 152:../lwip-1.4.1/src/core/tcp_out.c ****  * @param seqno TCP sequence number of this packet
 153:../lwip-1.4.1/src/core/tcp_out.c ****  * @param optflags options to include in TCP header
 154:../lwip-1.4.1/src/core/tcp_out.c ****  * @return a new tcp_seg pointing to p, or NULL.
 155:../lwip-1.4.1/src/core/tcp_out.c ****  * The TCP header is filled in except ackno and wnd.
 156:../lwip-1.4.1/src/core/tcp_out.c ****  * p is freed on failure.
 157:../lwip-1.4.1/src/core/tcp_out.c ****  */
 158:../lwip-1.4.1/src/core/tcp_out.c **** static struct tcp_seg *
 159:../lwip-1.4.1/src/core/tcp_out.c **** tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
 160:../lwip-1.4.1/src/core/tcp_out.c **** {
 259              		.loc 1 160 0
 260              		.cfi_startproc
 261              		@ args = 4, pretend = 0, frame = 24
 262              		@ frame_needed = 1, uses_anonymous_args = 0
 263 0000 90B5     		push	{r4, r7, lr}
 264              		.cfi_def_cfa_offset 12
 265              		.cfi_offset 4, -12
 266              		.cfi_offset 7, -8
 267              		.cfi_offset 14, -4
 268 0002 87B0     		sub	sp, sp, #28
 269              		.cfi_def_cfa_offset 40
 270 0004 00AF     		add	r7, sp, #0
 271              		.cfi_def_cfa_register 7
 272 0006 F860     		str	r0, [r7, #12]
 273 0008 B960     		str	r1, [r7, #8]
 274 000a 3B60     		str	r3, [r7]
 275 000c 1346     		mov	r3, r2
 276 000e FB71     		strb	r3, [r7, #7]
 161:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg *seg;
 162:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 277              		.loc 1 162 0
 278 0010 97F82830 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 279 0014 03F00103 		and	r3, r3, #1
 280 0018 002B     		cmp	r3, #0
 281 001a 01D0     		beq	.L10
 282              		.loc 1 162 0 is_stmt 0 discriminator 1
 283 001c 0422     		movs	r2, #4
 284 001e 00E0     		b	.L11
 285              	.L10:
 286              		.loc 1 162 0 discriminator 2
 287 0020 0022     		movs	r2, #0
 288              	.L11:
 289              		.loc 1 162 0 discriminator 4
 290 0022 97F82830 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 291 0026 03F00203 		and	r3, r3, #2
 292 002a 002B     		cmp	r3, #0
 293 002c 01D0     		beq	.L12
 294              		.loc 1 162 0 discriminator 5
 295 002e 0C23     		movs	r3, #12
 296 0030 00E0     		b	.L13
 297              	.L12:
 298              		.loc 1 162 0 discriminator 6
 299 0032 0023     		movs	r3, #0
 300              	.L13:
 301              		.loc 1 162 0 discriminator 8
 302 0034 1344     		add	r3, r3, r2
 303 0036 FB75     		strb	r3, [r7, #23]
 163:../lwip-1.4.1/src/core/tcp_out.c **** 
 164:../lwip-1.4.1/src/core/tcp_out.c ****   if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 304              		.loc 1 164 0 is_stmt 1 discriminator 8
 305 0038 0420     		movs	r0, #4
 306 003a FFF7FEFF 		bl	memp_malloc
 307 003e 3861     		str	r0, [r7, #16]
 308 0040 3B69     		ldr	r3, [r7, #16]
 309 0042 002B     		cmp	r3, #0
 310 0044 04D1     		bne	.L14
 165:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
 166:../lwip-1.4.1/src/core/tcp_out.c ****     pbuf_free(p);
 311              		.loc 1 166 0
 312 0046 B868     		ldr	r0, [r7, #8]
 313 0048 FFF7FEFF 		bl	pbuf_free
 167:../lwip-1.4.1/src/core/tcp_out.c ****     return NULL;
 314              		.loc 1 167 0
 315 004c 0023     		movs	r3, #0
 316 004e 5EE0     		b	.L15
 317              	.L14:
 168:../lwip-1.4.1/src/core/tcp_out.c ****   }
 169:../lwip-1.4.1/src/core/tcp_out.c ****   seg->flags = optflags;
 318              		.loc 1 169 0
 319 0050 3B69     		ldr	r3, [r7, #16]
 320 0052 97F82820 		ldrb	r2, [r7, #40]
 321 0056 1A73     		strb	r2, [r3, #12]
 170:../lwip-1.4.1/src/core/tcp_out.c ****   seg->next = NULL;
 322              		.loc 1 170 0
 323 0058 3B69     		ldr	r3, [r7, #16]
 324 005a 0022     		movs	r2, #0
 325 005c 1A60     		str	r2, [r3]
 171:../lwip-1.4.1/src/core/tcp_out.c ****   seg->p = p;
 326              		.loc 1 171 0
 327 005e 3B69     		ldr	r3, [r7, #16]
 328 0060 BA68     		ldr	r2, [r7, #8]
 329 0062 5A60     		str	r2, [r3, #4]
 172:../lwip-1.4.1/src/core/tcp_out.c ****   seg->len = p->tot_len - optlen;
 330              		.loc 1 172 0
 331 0064 BB68     		ldr	r3, [r7, #8]
 332 0066 1A89     		ldrh	r2, [r3, #8]
 333 0068 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 334 006a 9BB2     		uxth	r3, r3
 335 006c D31A     		subs	r3, r2, r3
 336 006e 9AB2     		uxth	r2, r3
 337 0070 3B69     		ldr	r3, [r7, #16]
 338 0072 1A81     		strh	r2, [r3, #8]	@ movhi
 173:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 174:../lwip-1.4.1/src/core/tcp_out.c ****   seg->oversize_left = 0;
 339              		.loc 1 174 0
 340 0074 3B69     		ldr	r3, [r7, #16]
 341 0076 0022     		movs	r2, #0
 342 0078 5A81     		strh	r2, [r3, #10]	@ movhi
 175:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 176:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 177:../lwip-1.4.1/src/core/tcp_out.c ****   seg->chksum = 0;
 178:../lwip-1.4.1/src/core/tcp_out.c ****   seg->chksum_swapped = 0;
 179:../lwip-1.4.1/src/core/tcp_out.c ****   /* check optflags */
 180:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
 181:../lwip-1.4.1/src/core/tcp_out.c ****               (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
 182:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 183:../lwip-1.4.1/src/core/tcp_out.c **** 
 184:../lwip-1.4.1/src/core/tcp_out.c ****   /* build TCP header */
 185:../lwip-1.4.1/src/core/tcp_out.c ****   if (pbuf_header(p, TCP_HLEN)) {
 343              		.loc 1 185 0
 344 007a B868     		ldr	r0, [r7, #8]
 345 007c 1421     		movs	r1, #20
 346 007e FFF7FEFF 		bl	pbuf_header
 347 0082 0346     		mov	r3, r0
 348 0084 002B     		cmp	r3, #0
 349 0086 0BD0     		beq	.L16
 186:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
 187:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_STATS_INC(tcp.err);
 350              		.loc 1 187 0
 351 0088 234B     		ldr	r3, .L17
 352 008a D3F84831 		ldr	r3, [r3, #328]
 353 008e 0133     		adds	r3, r3, #1
 354 0090 214A     		ldr	r2, .L17
 355 0092 C2F84831 		str	r3, [r2, #328]
 188:../lwip-1.4.1/src/core/tcp_out.c ****     tcp_seg_free(seg);
 356              		.loc 1 188 0
 357 0096 3869     		ldr	r0, [r7, #16]
 358 0098 FFF7FEFF 		bl	tcp_seg_free
 189:../lwip-1.4.1/src/core/tcp_out.c ****     return NULL;
 359              		.loc 1 189 0
 360 009c 0023     		movs	r3, #0
 361 009e 36E0     		b	.L15
 362              	.L16:
 190:../lwip-1.4.1/src/core/tcp_out.c ****   }
 191:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 363              		.loc 1 191 0
 364 00a0 3B69     		ldr	r3, [r7, #16]
 365 00a2 5B68     		ldr	r3, [r3, #4]
 366 00a4 5A68     		ldr	r2, [r3, #4]
 367 00a6 3B69     		ldr	r3, [r7, #16]
 368 00a8 1A61     		str	r2, [r3, #16]
 192:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->src = htons(pcb->local_port);
 369              		.loc 1 192 0
 370 00aa 3B69     		ldr	r3, [r7, #16]
 371 00ac 1C69     		ldr	r4, [r3, #16]
 372 00ae FB68     		ldr	r3, [r7, #12]
 373 00b0 5B8B     		ldrh	r3, [r3, #26]
 374 00b2 1846     		mov	r0, r3
 375 00b4 FFF7FEFF 		bl	lwip_htons
 376 00b8 0346     		mov	r3, r0
 377 00ba 2380     		strh	r3, [r4]	@ unaligned
 193:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->dest = htons(pcb->remote_port);
 378              		.loc 1 193 0
 379 00bc 3B69     		ldr	r3, [r7, #16]
 380 00be 1C69     		ldr	r4, [r3, #16]
 381 00c0 FB68     		ldr	r3, [r7, #12]
 382 00c2 9B8B     		ldrh	r3, [r3, #28]
 383 00c4 1846     		mov	r0, r3
 384 00c6 FFF7FEFF 		bl	lwip_htons
 385 00ca 0346     		mov	r3, r0
 386 00cc 6380     		strh	r3, [r4, #2]	@ unaligned
 194:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->seqno = htonl(seqno);
 387              		.loc 1 194 0
 388 00ce 3B69     		ldr	r3, [r7, #16]
 389 00d0 1C69     		ldr	r4, [r3, #16]
 390 00d2 3868     		ldr	r0, [r7]
 391 00d4 FFF7FEFF 		bl	lwip_htonl
 392 00d8 0346     		mov	r3, r0
 393 00da 6360     		str	r3, [r4, #4]	@ unaligned
 195:../lwip-1.4.1/src/core/tcp_out.c ****   /* ackno is set in tcp_output */
 196:../lwip-1.4.1/src/core/tcp_out.c ****   TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 394              		.loc 1 196 0
 395 00dc 3B69     		ldr	r3, [r7, #16]
 396 00de 1C69     		ldr	r4, [r3, #16]
 397 00e0 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 398 00e2 9B08     		lsrs	r3, r3, #2
 399 00e4 DBB2     		uxtb	r3, r3
 400 00e6 0533     		adds	r3, r3, #5
 401 00e8 1B03     		lsls	r3, r3, #12
 402 00ea 9AB2     		uxth	r2, r3
 403 00ec FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 404 00ee 9BB2     		uxth	r3, r3
 405 00f0 1343     		orrs	r3, r3, r2
 406 00f2 9BB2     		uxth	r3, r3
 407 00f4 9BB2     		uxth	r3, r3
 408 00f6 1846     		mov	r0, r3
 409 00f8 FFF7FEFF 		bl	lwip_htons
 410 00fc 0346     		mov	r3, r0
 411 00fe A381     		strh	r3, [r4, #12]	@ unaligned
 197:../lwip-1.4.1/src/core/tcp_out.c ****   /* wnd and chksum are set in tcp_output */
 198:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->urgp = 0;
 412              		.loc 1 198 0
 413 0100 3B69     		ldr	r3, [r7, #16]
 414 0102 1B69     		ldr	r3, [r3, #16]
 415 0104 0022     		movs	r2, #0
 416 0106 9A74     		strb	r2, [r3, #18]
 417 0108 0022     		movs	r2, #0
 418 010a DA74     		strb	r2, [r3, #19]
 199:../lwip-1.4.1/src/core/tcp_out.c ****   return seg;
 419              		.loc 1 199 0
 420 010c 3B69     		ldr	r3, [r7, #16]
 421              	.L15:
 200:../lwip-1.4.1/src/core/tcp_out.c **** } 
 422              		.loc 1 200 0
 423 010e 1846     		mov	r0, r3
 424 0110 1C37     		adds	r7, r7, #28
 425              		.cfi_def_cfa_offset 12
 426 0112 BD46     		mov	sp, r7
 427              		.cfi_def_cfa_register 13
 428              		@ sp needed
 429 0114 90BD     		pop	{r4, r7, pc}
 430              	.L18:
 431 0116 00BF     		.align	2
 432              	.L17:
 433 0118 00000000 		.word	lwip_stats
 434              		.cfi_endproc
 435              	.LFE2:
 437              		.section	.text.tcp_pbuf_prealloc,"ax",%progbits
 438              		.align	2
 439              		.thumb
 440              		.thumb_func
 442              	tcp_pbuf_prealloc:
 443              	.LFB3:
 201:../lwip-1.4.1/src/core/tcp_out.c **** 
 202:../lwip-1.4.1/src/core/tcp_out.c **** /**
 203:../lwip-1.4.1/src/core/tcp_out.c ****  * Allocate a PBUF_RAM pbuf, perhaps with extra space at the end.
 204:../lwip-1.4.1/src/core/tcp_out.c ****  *
 205:../lwip-1.4.1/src/core/tcp_out.c ****  * This function is like pbuf_alloc(layer, length, PBUF_RAM) except
 206:../lwip-1.4.1/src/core/tcp_out.c ****  * there may be extra bytes available at the end.
 207:../lwip-1.4.1/src/core/tcp_out.c ****  *
 208:../lwip-1.4.1/src/core/tcp_out.c ****  * @param layer flag to define header size.
 209:../lwip-1.4.1/src/core/tcp_out.c ****  * @param length size of the pbuf's payload.
 210:../lwip-1.4.1/src/core/tcp_out.c ****  * @param max_length maximum usable size of payload+oversize.
 211:../lwip-1.4.1/src/core/tcp_out.c ****  * @param oversize pointer to a u16_t that will receive the number of usable tail bytes.
 212:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb The TCP connection that willo enqueue the pbuf.
 213:../lwip-1.4.1/src/core/tcp_out.c ****  * @param apiflags API flags given to tcp_write.
 214:../lwip-1.4.1/src/core/tcp_out.c ****  * @param first_seg true when this pbuf will be used in the first enqueued segment.
 215:../lwip-1.4.1/src/core/tcp_out.c ****  * @param 
 216:../lwip-1.4.1/src/core/tcp_out.c ****  */
 217:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
 218:../lwip-1.4.1/src/core/tcp_out.c **** static struct pbuf *
 219:../lwip-1.4.1/src/core/tcp_out.c **** tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
 220:../lwip-1.4.1/src/core/tcp_out.c ****                   u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
 221:../lwip-1.4.1/src/core/tcp_out.c ****                   u8_t first_seg)
 222:../lwip-1.4.1/src/core/tcp_out.c **** {
 444              		.loc 1 222 0
 445              		.cfi_startproc
 446              		@ args = 12, pretend = 0, frame = 24
 447              		@ frame_needed = 1, uses_anonymous_args = 0
 448 0000 80B5     		push	{r7, lr}
 449              		.cfi_def_cfa_offset 8
 450              		.cfi_offset 7, -8
 451              		.cfi_offset 14, -4
 452 0002 86B0     		sub	sp, sp, #24
 453              		.cfi_def_cfa_offset 32
 454 0004 00AF     		add	r7, sp, #0
 455              		.cfi_def_cfa_register 7
 456 0006 7B60     		str	r3, [r7, #4]
 457 0008 0346     		mov	r3, r0
 458 000a FB73     		strb	r3, [r7, #15]
 459 000c 0B46     		mov	r3, r1	@ movhi
 460 000e BB81     		strh	r3, [r7, #12]	@ movhi
 461 0010 1346     		mov	r3, r2	@ movhi
 462 0012 7B81     		strh	r3, [r7, #10]	@ movhi
 223:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *p;
 224:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t alloc = length;
 463              		.loc 1 224 0
 464 0014 BB89     		ldrh	r3, [r7, #12]	@ movhi
 465 0016 FB82     		strh	r3, [r7, #22]	@ movhi
 225:../lwip-1.4.1/src/core/tcp_out.c **** 
 226:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_NETIF_TX_SINGLE_PBUF
 227:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_UNUSED_ARG(max_length);
 228:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_UNUSED_ARG(pcb);
 229:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_UNUSED_ARG(apiflags);
 230:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_UNUSED_ARG(first_seg);
 231:../lwip-1.4.1/src/core/tcp_out.c ****   /* always create MSS-sized pbufs */
 232:../lwip-1.4.1/src/core/tcp_out.c ****   alloc = max_length;
 233:../lwip-1.4.1/src/core/tcp_out.c **** #else /* LWIP_NETIF_TX_SINGLE_PBUF */
 234:../lwip-1.4.1/src/core/tcp_out.c ****   if (length < max_length) {
 466              		.loc 1 234 0
 467 0018 BA89     		ldrh	r2, [r7, #12]
 468 001a 7B89     		ldrh	r3, [r7, #10]
 469 001c 9A42     		cmp	r2, r3
 470 001e 21D2     		bcs	.L20
 235:../lwip-1.4.1/src/core/tcp_out.c ****     /* Should we allocate an oversized pbuf, or just the minimum
 236:../lwip-1.4.1/src/core/tcp_out.c ****      * length required? If tcp_write is going to be called again
 237:../lwip-1.4.1/src/core/tcp_out.c ****      * before this segment is transmitted, we want the oversized
 238:../lwip-1.4.1/src/core/tcp_out.c ****      * buffer. If the segment will be transmitted immediately, we can
 239:../lwip-1.4.1/src/core/tcp_out.c ****      * save memory by allocating only length. We use a simple
 240:../lwip-1.4.1/src/core/tcp_out.c ****      * heuristic based on the following information:
 241:../lwip-1.4.1/src/core/tcp_out.c ****      *
 242:../lwip-1.4.1/src/core/tcp_out.c ****      * Did the user set TCP_WRITE_FLAG_MORE?
 243:../lwip-1.4.1/src/core/tcp_out.c ****      *
 244:../lwip-1.4.1/src/core/tcp_out.c ****      * Will the Nagle algorithm defer transmission of this segment?
 245:../lwip-1.4.1/src/core/tcp_out.c ****      */
 246:../lwip-1.4.1/src/core/tcp_out.c ****     if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 471              		.loc 1 246 0
 472 0020 97F82430 		ldrb	r3, [r7, #36]	@ zero_extendqisi2
 473 0024 03F00203 		and	r3, r3, #2
 474 0028 002B     		cmp	r3, #0
 475 002a 11D1     		bne	.L21
 247:../lwip-1.4.1/src/core/tcp_out.c ****         (!(pcb->flags & TF_NODELAY) &&
 476              		.loc 1 247 0 discriminator 1
 477 002c 3B6A     		ldr	r3, [r7, #32]
 478 002e 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 479 0030 03F04003 		and	r3, r3, #64
 246:../lwip-1.4.1/src/core/tcp_out.c ****         (!(pcb->flags & TF_NODELAY) &&
 480              		.loc 1 246 0 discriminator 1
 481 0034 002B     		cmp	r3, #0
 482 0036 15D1     		bne	.L20
 483              		.loc 1 247 0
 484 0038 97F82830 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 485 003c 002B     		cmp	r3, #0
 486 003e 07D0     		beq	.L21
 248:../lwip-1.4.1/src/core/tcp_out.c ****          (!first_seg ||
 249:../lwip-1.4.1/src/core/tcp_out.c ****           pcb->unsent != NULL ||
 487              		.loc 1 249 0
 488 0040 3B6A     		ldr	r3, [r7, #32]
 489 0042 DB6E     		ldr	r3, [r3, #108]
 248:../lwip-1.4.1/src/core/tcp_out.c ****          (!first_seg ||
 490              		.loc 1 248 0
 491 0044 002B     		cmp	r3, #0
 492 0046 03D1     		bne	.L21
 250:../lwip-1.4.1/src/core/tcp_out.c ****           pcb->unacked != NULL))) {
 493              		.loc 1 250 0
 494 0048 3B6A     		ldr	r3, [r7, #32]
 495 004a 1B6F     		ldr	r3, [r3, #112]
 249:../lwip-1.4.1/src/core/tcp_out.c ****           pcb->unacked != NULL))) {
 496              		.loc 1 249 0
 497 004c 002B     		cmp	r3, #0
 498 004e 09D0     		beq	.L20
 499              	.L21:
 251:../lwip-1.4.1/src/core/tcp_out.c ****       alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
 500              		.loc 1 251 0
 501 0050 BB89     		ldrh	r3, [r7, #12]
 502 0052 03F2B753 		addw	r3, r3, #1463
 503 0056 23F00302 		bic	r2, r3, #3
 504 005a 7B89     		ldrh	r3, [r7, #10]
 505 005c 9342     		cmp	r3, r2
 506 005e A8BF     		it	ge
 507 0060 1346     		movge	r3, r2
 508 0062 FB82     		strh	r3, [r7, #22]	@ movhi
 509              	.L20:
 252:../lwip-1.4.1/src/core/tcp_out.c ****     }
 253:../lwip-1.4.1/src/core/tcp_out.c ****   }
 254:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 255:../lwip-1.4.1/src/core/tcp_out.c ****   p = pbuf_alloc(layer, alloc, PBUF_RAM);
 510              		.loc 1 255 0
 511 0064 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 512 0066 FB8A     		ldrh	r3, [r7, #22]
 513 0068 1046     		mov	r0, r2
 514 006a 1946     		mov	r1, r3
 515 006c 0022     		movs	r2, #0
 516 006e FFF7FEFF 		bl	pbuf_alloc
 517 0072 3861     		str	r0, [r7, #16]
 256:../lwip-1.4.1/src/core/tcp_out.c ****   if (p == NULL) {
 518              		.loc 1 256 0
 519 0074 3B69     		ldr	r3, [r7, #16]
 520 0076 002B     		cmp	r3, #0
 521 0078 01D1     		bne	.L22
 257:../lwip-1.4.1/src/core/tcp_out.c ****     return NULL;
 522              		.loc 1 257 0
 523 007a 0023     		movs	r3, #0
 524 007c 0EE0     		b	.L23
 525              	.L22:
 258:../lwip-1.4.1/src/core/tcp_out.c ****   }
 259:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 260:../lwip-1.4.1/src/core/tcp_out.c ****   *oversize = p->len - length;
 526              		.loc 1 260 0
 527 007e 3B69     		ldr	r3, [r7, #16]
 528 0080 5A89     		ldrh	r2, [r3, #10]
 529 0082 BB89     		ldrh	r3, [r7, #12]	@ movhi
 530 0084 D31A     		subs	r3, r2, r3
 531 0086 9AB2     		uxth	r2, r3
 532 0088 7B68     		ldr	r3, [r7, #4]
 533 008a 1A80     		strh	r2, [r3]	@ movhi
 261:../lwip-1.4.1/src/core/tcp_out.c ****   /* trim p->len to the currently used size */
 262:../lwip-1.4.1/src/core/tcp_out.c ****   p->len = p->tot_len = length;
 534              		.loc 1 262 0
 535 008c 3B69     		ldr	r3, [r7, #16]
 536 008e BA89     		ldrh	r2, [r7, #12]	@ movhi
 537 0090 1A81     		strh	r2, [r3, #8]	@ movhi
 538 0092 3B69     		ldr	r3, [r7, #16]
 539 0094 1A89     		ldrh	r2, [r3, #8]
 540 0096 3B69     		ldr	r3, [r7, #16]
 541 0098 5A81     		strh	r2, [r3, #10]	@ movhi
 263:../lwip-1.4.1/src/core/tcp_out.c ****   return p;
 542              		.loc 1 263 0
 543 009a 3B69     		ldr	r3, [r7, #16]
 544              	.L23:
 264:../lwip-1.4.1/src/core/tcp_out.c **** }
 545              		.loc 1 264 0
 546 009c 1846     		mov	r0, r3
 547 009e 1837     		adds	r7, r7, #24
 548              		.cfi_def_cfa_offset 8
 549 00a0 BD46     		mov	sp, r7
 550              		.cfi_def_cfa_register 13
 551              		@ sp needed
 552 00a2 80BD     		pop	{r7, pc}
 553              		.cfi_endproc
 554              	.LFE3:
 556              		.section	.text.tcp_write_checks,"ax",%progbits
 557              		.align	2
 558              		.thumb
 559              		.thumb_func
 561              	tcp_write_checks:
 562              	.LFB4:
 265:../lwip-1.4.1/src/core/tcp_out.c **** #else /* TCP_OVERSIZE */
 266:../lwip-1.4.1/src/core/tcp_out.c **** #define tcp_pbuf_prealloc(layer, length, mx, os, pcb, api, fst) pbuf_alloc((layer), (length), PBUF_
 267:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 268:../lwip-1.4.1/src/core/tcp_out.c **** 
 269:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 270:../lwip-1.4.1/src/core/tcp_out.c **** /** Add a checksum of newly added data to the segment */
 271:../lwip-1.4.1/src/core/tcp_out.c **** static void
 272:../lwip-1.4.1/src/core/tcp_out.c **** tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
 273:../lwip-1.4.1/src/core/tcp_out.c ****                    u8_t *seg_chksum_swapped)
 274:../lwip-1.4.1/src/core/tcp_out.c **** {
 275:../lwip-1.4.1/src/core/tcp_out.c ****   u32_t helper;
 276:../lwip-1.4.1/src/core/tcp_out.c ****   /* add chksum to old chksum and fold to u16_t */
 277:../lwip-1.4.1/src/core/tcp_out.c ****   helper = chksum + *seg_chksum;
 278:../lwip-1.4.1/src/core/tcp_out.c ****   chksum = FOLD_U32T(helper);
 279:../lwip-1.4.1/src/core/tcp_out.c ****   if ((len & 1) != 0) {
 280:../lwip-1.4.1/src/core/tcp_out.c ****     *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 281:../lwip-1.4.1/src/core/tcp_out.c ****     chksum = SWAP_BYTES_IN_WORD(chksum);
 282:../lwip-1.4.1/src/core/tcp_out.c ****   }
 283:../lwip-1.4.1/src/core/tcp_out.c ****   *seg_chksum = chksum;
 284:../lwip-1.4.1/src/core/tcp_out.c **** }
 285:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 286:../lwip-1.4.1/src/core/tcp_out.c **** 
 287:../lwip-1.4.1/src/core/tcp_out.c **** /** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
 288:../lwip-1.4.1/src/core/tcp_out.c ****  *
 289:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp pcb to check for
 290:../lwip-1.4.1/src/core/tcp_out.c ****  * @param len length of data to send (checked agains snd_buf)
 291:../lwip-1.4.1/src/core/tcp_out.c ****  * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 292:../lwip-1.4.1/src/core/tcp_out.c ****  */
 293:../lwip-1.4.1/src/core/tcp_out.c **** static err_t
 294:../lwip-1.4.1/src/core/tcp_out.c **** tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
 295:../lwip-1.4.1/src/core/tcp_out.c **** {
 563              		.loc 1 295 0
 564              		.cfi_startproc
 565              		@ args = 0, pretend = 0, frame = 8
 566              		@ frame_needed = 1, uses_anonymous_args = 0
 567              		@ link register save eliminated.
 568 0000 80B4     		push	{r7}
 569              		.cfi_def_cfa_offset 4
 570              		.cfi_offset 7, -4
 571 0002 83B0     		sub	sp, sp, #12
 572              		.cfi_def_cfa_offset 16
 573 0004 00AF     		add	r7, sp, #0
 574              		.cfi_def_cfa_register 7
 575 0006 7860     		str	r0, [r7, #4]
 576 0008 0B46     		mov	r3, r1
 577 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 296:../lwip-1.4.1/src/core/tcp_out.c ****   /* connection is in invalid state for data transmission? */
 297:../lwip-1.4.1/src/core/tcp_out.c ****   if ((pcb->state != ESTABLISHED) &&
 578              		.loc 1 297 0
 579 000c 7B68     		ldr	r3, [r7, #4]
 580 000e 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 581 0010 042B     		cmp	r3, #4
 582 0012 0DD0     		beq	.L25
 298:../lwip-1.4.1/src/core/tcp_out.c ****       (pcb->state != CLOSE_WAIT) &&
 583              		.loc 1 298 0 discriminator 1
 584 0014 7B68     		ldr	r3, [r7, #4]
 585 0016 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 297:../lwip-1.4.1/src/core/tcp_out.c ****       (pcb->state != CLOSE_WAIT) &&
 586              		.loc 1 297 0 discriminator 1
 587 0018 072B     		cmp	r3, #7
 588 001a 09D0     		beq	.L25
 299:../lwip-1.4.1/src/core/tcp_out.c ****       (pcb->state != SYN_SENT) &&
 589              		.loc 1 299 0
 590 001c 7B68     		ldr	r3, [r7, #4]
 591 001e 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 298:../lwip-1.4.1/src/core/tcp_out.c ****       (pcb->state != CLOSE_WAIT) &&
 592              		.loc 1 298 0
 593 0020 022B     		cmp	r3, #2
 594 0022 05D0     		beq	.L25
 300:../lwip-1.4.1/src/core/tcp_out.c ****       (pcb->state != SYN_RCVD)) {
 595              		.loc 1 300 0
 596 0024 7B68     		ldr	r3, [r7, #4]
 597 0026 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 299:../lwip-1.4.1/src/core/tcp_out.c ****       (pcb->state != SYN_SENT) &&
 598              		.loc 1 299 0
 599 0028 032B     		cmp	r3, #3
 600 002a 01D0     		beq	.L25
 301:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in 
 302:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_CONN;
 601              		.loc 1 302 0
 602 002c F323     		movs	r3, #243
 603 002e 3CE0     		b	.L26
 604              	.L25:
 303:../lwip-1.4.1/src/core/tcp_out.c ****   } else if (len == 0) {
 605              		.loc 1 303 0
 606 0030 7B88     		ldrh	r3, [r7, #2]
 607 0032 002B     		cmp	r3, #0
 608 0034 01D1     		bne	.L27
 304:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_OK;
 609              		.loc 1 304 0
 610 0036 0023     		movs	r3, #0
 611 0038 37E0     		b	.L26
 612              	.L27:
 305:../lwip-1.4.1/src/core/tcp_out.c ****   }
 306:../lwip-1.4.1/src/core/tcp_out.c **** 
 307:../lwip-1.4.1/src/core/tcp_out.c ****   /* fail on too much data */
 308:../lwip-1.4.1/src/core/tcp_out.c ****   if (len > pcb->snd_buf) {
 613              		.loc 1 308 0
 614 003a 7B68     		ldr	r3, [r7, #4]
 615 003c B3F86630 		ldrh	r3, [r3, #102]
 616 0040 7A88     		ldrh	r2, [r7, #2]
 617 0042 9A42     		cmp	r2, r3
 618 0044 08D9     		bls	.L28
 309:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\
 310:../lwip-1.4.1/src/core/tcp_out.c ****       len, pcb->snd_buf));
 311:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->flags |= TF_NAGLEMEMERR;
 619              		.loc 1 311 0
 620 0046 7B68     		ldr	r3, [r7, #4]
 621 0048 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 622 004a 63F07F03 		orn	r3, r3, #127
 623 004e DAB2     		uxtb	r2, r3
 624 0050 7B68     		ldr	r3, [r7, #4]
 625 0052 9A77     		strb	r2, [r3, #30]
 312:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_MEM;
 626              		.loc 1 312 0
 627 0054 FF23     		movs	r3, #255
 628 0056 28E0     		b	.L26
 629              	.L28:
 313:../lwip-1.4.1/src/core/tcp_out.c ****   }
 314:../lwip-1.4.1/src/core/tcp_out.c **** 
 315:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
 316:../lwip-1.4.1/src/core/tcp_out.c **** 
 317:../lwip-1.4.1/src/core/tcp_out.c ****   /* If total number of pbufs on the unsent/unacked queues exceeds the
 318:../lwip-1.4.1/src/core/tcp_out.c ****    * configured maximum, return an error */
 319:../lwip-1.4.1/src/core/tcp_out.c ****   /* check for configured max queuelen and possible overflow */
 320:../lwip-1.4.1/src/core/tcp_out.c ****   if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 630              		.loc 1 320 0
 631 0058 7B68     		ldr	r3, [r7, #4]
 632 005a B3F86830 		ldrh	r3, [r3, #104]
 633 005e 072B     		cmp	r3, #7
 634 0060 06D8     		bhi	.L29
 635              		.loc 1 320 0 is_stmt 0 discriminator 1
 636 0062 7B68     		ldr	r3, [r7, #4]
 637 0064 B3F86830 		ldrh	r3, [r3, #104]
 638 0068 4FF6FC72 		movw	r2, #65532
 639 006c 9342     		cmp	r3, r2
 640 006e 0FD9     		bls	.L30
 641              	.L29:
 321:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
 322:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->snd_queuelen, TCP_SND_QUEUELEN));
 323:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
 642              		.loc 1 323 0 is_stmt 1
 643 0070 114B     		ldr	r3, .L33
 644 0072 D3F83831 		ldr	r3, [r3, #312]
 645 0076 0133     		adds	r3, r3, #1
 646 0078 0F4A     		ldr	r2, .L33
 647 007a C2F83831 		str	r3, [r2, #312]
 324:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->flags |= TF_NAGLEMEMERR;
 648              		.loc 1 324 0
 649 007e 7B68     		ldr	r3, [r7, #4]
 650 0080 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 651 0082 63F07F03 		orn	r3, r3, #127
 652 0086 DAB2     		uxtb	r2, r3
 653 0088 7B68     		ldr	r3, [r7, #4]
 654 008a 9A77     		strb	r2, [r3, #30]
 325:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_MEM;
 655              		.loc 1 325 0
 656 008c FF23     		movs	r3, #255
 657 008e 0CE0     		b	.L26
 658              	.L30:
 326:../lwip-1.4.1/src/core/tcp_out.c ****   }
 327:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
 659              		.loc 1 327 0
 660 0090 7B68     		ldr	r3, [r7, #4]
 661 0092 B3F86830 		ldrh	r3, [r3, #104]
 662 0096 002B     		cmp	r3, #0
 663 0098 03D0     		beq	.L31
 328:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 664              		.loc 1 328 0
 665 009a 7B68     		ldr	r3, [r7, #4]
 666 009c 1B6F     		ldr	r3, [r3, #112]
 667 009e 002B     		cmp	r3, #0
 668 00a0 02E0     		b	.L32
 669              	.L31:
 329:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->unacked != NULL || pcb->unsent != NULL);
 330:../lwip-1.4.1/src/core/tcp_out.c ****   } else {
 331:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 670              		.loc 1 331 0
 671 00a2 7B68     		ldr	r3, [r7, #4]
 672 00a4 1B6F     		ldr	r3, [r3, #112]
 673 00a6 002B     		cmp	r3, #0
 674              	.L32:
 332:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->unacked == NULL && pcb->unsent == NULL);
 333:../lwip-1.4.1/src/core/tcp_out.c ****   }
 334:../lwip-1.4.1/src/core/tcp_out.c ****   return ERR_OK;
 675              		.loc 1 334 0
 676 00a8 0023     		movs	r3, #0
 677              	.L26:
 678 00aa 5BB2     		sxtb	r3, r3
 335:../lwip-1.4.1/src/core/tcp_out.c **** }
 679              		.loc 1 335 0
 680 00ac 1846     		mov	r0, r3
 681 00ae 0C37     		adds	r7, r7, #12
 682              		.cfi_def_cfa_offset 4
 683 00b0 BD46     		mov	sp, r7
 684              		.cfi_def_cfa_register 13
 685              		@ sp needed
 686 00b2 5DF8047B 		ldr	r7, [sp], #4
 687              		.cfi_restore 7
 688              		.cfi_def_cfa_offset 0
 689 00b6 7047     		bx	lr
 690              	.L34:
 691              		.align	2
 692              	.L33:
 693 00b8 00000000 		.word	lwip_stats
 694              		.cfi_endproc
 695              	.LFE4:
 697              		.section	.text.tcp_write,"ax",%progbits
 698              		.align	2
 699              		.global	tcp_write
 700              		.thumb
 701              		.thumb_func
 703              	tcp_write:
 704              	.LFB5:
 336:../lwip-1.4.1/src/core/tcp_out.c **** 
 337:../lwip-1.4.1/src/core/tcp_out.c **** /**
 338:../lwip-1.4.1/src/core/tcp_out.c ****  * Write data for sending (but does not send it immediately).
 339:../lwip-1.4.1/src/core/tcp_out.c ****  *
 340:../lwip-1.4.1/src/core/tcp_out.c ****  * It waits in the expectation of more data being sent soon (as
 341:../lwip-1.4.1/src/core/tcp_out.c ****  * it can send them more efficiently by combining them together).
 342:../lwip-1.4.1/src/core/tcp_out.c ****  * To prompt the system to send data now, call tcp_output() after
 343:../lwip-1.4.1/src/core/tcp_out.c ****  * calling tcp_write().
 344:../lwip-1.4.1/src/core/tcp_out.c ****  *
 345:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection to enqueue data for.
 346:../lwip-1.4.1/src/core/tcp_out.c ****  * @param arg Pointer to the data to be enqueued for sending.
 347:../lwip-1.4.1/src/core/tcp_out.c ****  * @param len Data length in bytes
 348:../lwip-1.4.1/src/core/tcp_out.c ****  * @param apiflags combination of following flags :
 349:../lwip-1.4.1/src/core/tcp_out.c ****  * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 350:../lwip-1.4.1/src/core/tcp_out.c ****  * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 351:../lwip-1.4.1/src/core/tcp_out.c ****  * @return ERR_OK if enqueued, another err_t on error
 352:../lwip-1.4.1/src/core/tcp_out.c ****  */
 353:../lwip-1.4.1/src/core/tcp_out.c **** err_t
 354:../lwip-1.4.1/src/core/tcp_out.c **** tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
 355:../lwip-1.4.1/src/core/tcp_out.c **** {
 705              		.loc 1 355 0
 706              		.cfi_startproc
 707              		@ args = 0, pretend = 0, frame = 80
 708              		@ frame_needed = 1, uses_anonymous_args = 0
 709 0000 B0B5     		push	{r4, r5, r7, lr}
 710              		.cfi_def_cfa_offset 16
 711              		.cfi_offset 4, -16
 712              		.cfi_offset 5, -12
 713              		.cfi_offset 7, -8
 714              		.cfi_offset 14, -4
 715 0002 98B0     		sub	sp, sp, #96
 716              		.cfi_def_cfa_offset 112
 717 0004 04AF     		add	r7, sp, #16
 718              		.cfi_def_cfa 7, 96
 719 0006 F860     		str	r0, [r7, #12]
 720 0008 B960     		str	r1, [r7, #8]
 721 000a 1146     		mov	r1, r2
 722 000c 1A46     		mov	r2, r3
 723 000e 0B46     		mov	r3, r1	@ movhi
 724 0010 FB80     		strh	r3, [r7, #6]	@ movhi
 725 0012 1346     		mov	r3, r2
 726 0014 7B71     		strb	r3, [r7, #5]
 356:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *concat_p = NULL;
 727              		.loc 1 356 0
 728 0016 0023     		movs	r3, #0
 729 0018 FB64     		str	r3, [r7, #76]
 357:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 730              		.loc 1 357 0
 731 001a 0023     		movs	r3, #0
 732 001c BB64     		str	r3, [r7, #72]
 733 001e 0023     		movs	r3, #0
 734 0020 7B64     		str	r3, [r7, #68]
 735 0022 0023     		movs	r3, #0
 736 0024 3B64     		str	r3, [r7, #64]
 737 0026 0023     		movs	r3, #0
 738 0028 FB63     		str	r3, [r7, #60]
 358:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t pos = 0; /* position in 'arg' data */
 739              		.loc 1 358 0
 740 002a 0023     		movs	r3, #0
 741 002c 7B87     		strh	r3, [r7, #58]	@ movhi
 359:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t queuelen;
 360:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t optlen = 0;
 742              		.loc 1 360 0
 743 002e 0023     		movs	r3, #0
 744 0030 87F82B30 		strb	r3, [r7, #43]
 361:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t optflags = 0;
 745              		.loc 1 361 0
 746 0034 0023     		movs	r3, #0
 747 0036 87F82A30 		strb	r3, [r7, #42]
 362:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
 363:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t oversize = 0;
 748              		.loc 1 363 0
 749 003a 0023     		movs	r3, #0
 750 003c FB82     		strh	r3, [r7, #22]	@ movhi
 364:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t oversize_used = 0;
 751              		.loc 1 364 0
 752 003e 0023     		movs	r3, #0
 753 0040 FB86     		strh	r3, [r7, #54]	@ movhi
 365:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 366:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 367:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t concat_chksum = 0;
 368:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t concat_chksum_swapped = 0;
 369:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t concat_chksummed = 0;
 370:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 371:../lwip-1.4.1/src/core/tcp_out.c ****   err_t err;
 372:../lwip-1.4.1/src/core/tcp_out.c ****   /* don't allocate segments bigger than half the maximum window we ever received */
 373:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 754              		.loc 1 373 0
 755 0042 FB68     		ldr	r3, [r7, #12]
 756 0044 B3F86230 		ldrh	r3, [r3, #98]
 757 0048 5B08     		lsrs	r3, r3, #1
 758 004a 9AB2     		uxth	r2, r3
 759 004c FB68     		ldr	r3, [r7, #12]
 760 004e DB8E     		ldrh	r3, [r3, #54]
 761 0050 9342     		cmp	r3, r2
 762 0052 28BF     		it	cs
 763 0054 1346     		movcs	r3, r2
 764 0056 3B85     		strh	r3, [r7, #40]	@ movhi
 374:../lwip-1.4.1/src/core/tcp_out.c **** 
 375:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_NETIF_TX_SINGLE_PBUF
 376:../lwip-1.4.1/src/core/tcp_out.c ****   /* Always copy to try to create single pbufs for TX */
 377:../lwip-1.4.1/src/core/tcp_out.c ****   apiflags |= TCP_WRITE_FLAG_COPY;
 378:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 379:../lwip-1.4.1/src/core/tcp_out.c **** 
 380:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
 381:../lwip-1.4.1/src/core/tcp_out.c ****     (void *)pcb, arg, len, (u16_t)apiflags));
 382:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 765              		.loc 1 382 0
 766 0058 BB68     		ldr	r3, [r7, #8]
 767 005a 002B     		cmp	r3, #0
 768 005c 01D1     		bne	.L36
 769              		.loc 1 382 0 is_stmt 0 discriminator 1
 770 005e F223     		movs	r3, #242
 771 0060 0BE2     		b	.L78
 772              	.L36:
 383:../lwip-1.4.1/src/core/tcp_out.c ****              arg != NULL, return ERR_ARG;);
 384:../lwip-1.4.1/src/core/tcp_out.c **** 
 385:../lwip-1.4.1/src/core/tcp_out.c ****   err = tcp_write_checks(pcb, len);
 773              		.loc 1 385 0 is_stmt 1
 774 0062 FB88     		ldrh	r3, [r7, #6]
 775 0064 F868     		ldr	r0, [r7, #12]
 776 0066 1946     		mov	r1, r3
 777 0068 FFF7FEFF 		bl	tcp_write_checks
 778 006c 0346     		mov	r3, r0
 779 006e 87F82730 		strb	r3, [r7, #39]
 386:../lwip-1.4.1/src/core/tcp_out.c ****   if (err != ERR_OK) {
 780              		.loc 1 386 0
 781 0072 97F92730 		ldrsb	r3, [r7, #39]
 782 0076 002B     		cmp	r3, #0
 783 0078 02D0     		beq	.L38
 387:../lwip-1.4.1/src/core/tcp_out.c ****     return err;
 784              		.loc 1 387 0
 785 007a 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 786 007e FCE1     		b	.L78
 787              	.L38:
 388:../lwip-1.4.1/src/core/tcp_out.c ****   }
 389:../lwip-1.4.1/src/core/tcp_out.c ****   queuelen = pcb->snd_queuelen;
 788              		.loc 1 389 0
 789 0080 FB68     		ldr	r3, [r7, #12]
 790 0082 B3F86830 		ldrh	r3, [r3, #104]	@ movhi
 791 0086 3B87     		strh	r3, [r7, #56]	@ movhi
 390:../lwip-1.4.1/src/core/tcp_out.c **** 
 391:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
 392:../lwip-1.4.1/src/core/tcp_out.c ****   if ((pcb->flags & TF_TIMESTAMP)) {
 393:../lwip-1.4.1/src/core/tcp_out.c ****     optflags = TF_SEG_OPTS_TS;
 394:../lwip-1.4.1/src/core/tcp_out.c ****     optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
 395:../lwip-1.4.1/src/core/tcp_out.c ****   }
 396:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_TCP_TIMESTAMPS */
 397:../lwip-1.4.1/src/core/tcp_out.c **** 
 398:../lwip-1.4.1/src/core/tcp_out.c **** 
 399:../lwip-1.4.1/src/core/tcp_out.c ****   /*
 400:../lwip-1.4.1/src/core/tcp_out.c ****    * TCP segmentation is done in three phases with increasing complexity:
 401:../lwip-1.4.1/src/core/tcp_out.c ****    *
 402:../lwip-1.4.1/src/core/tcp_out.c ****    * 1. Copy data directly into an oversized pbuf.
 403:../lwip-1.4.1/src/core/tcp_out.c ****    * 2. Chain a new pbuf to the end of pcb->unsent.
 404:../lwip-1.4.1/src/core/tcp_out.c ****    * 3. Create new segments.
 405:../lwip-1.4.1/src/core/tcp_out.c ****    *
 406:../lwip-1.4.1/src/core/tcp_out.c ****    * We may run out of memory at any point. In that case we must
 407:../lwip-1.4.1/src/core/tcp_out.c ****    * return ERR_MEM and not change anything in pcb. Therefore, all
 408:../lwip-1.4.1/src/core/tcp_out.c ****    * changes are recorded in local variables and committed at the end
 409:../lwip-1.4.1/src/core/tcp_out.c ****    * of the function. Some pcb fields are maintained in local copies:
 410:../lwip-1.4.1/src/core/tcp_out.c ****    *
 411:../lwip-1.4.1/src/core/tcp_out.c ****    * queuelen = pcb->snd_queuelen
 412:../lwip-1.4.1/src/core/tcp_out.c ****    * oversize = pcb->unsent_oversize
 413:../lwip-1.4.1/src/core/tcp_out.c ****    *
 414:../lwip-1.4.1/src/core/tcp_out.c ****    * These variables are set consistently by the phases:
 415:../lwip-1.4.1/src/core/tcp_out.c ****    *
 416:../lwip-1.4.1/src/core/tcp_out.c ****    * seg points to the last segment tampered with.
 417:../lwip-1.4.1/src/core/tcp_out.c ****    *
 418:../lwip-1.4.1/src/core/tcp_out.c ****    * pos records progress as data is segmented.
 419:../lwip-1.4.1/src/core/tcp_out.c ****    */
 420:../lwip-1.4.1/src/core/tcp_out.c **** 
 421:../lwip-1.4.1/src/core/tcp_out.c ****   /* Find the tail of the unsent queue. */
 422:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->unsent != NULL) {
 792              		.loc 1 422 0
 793 0088 FB68     		ldr	r3, [r7, #12]
 794 008a DB6E     		ldr	r3, [r3, #108]
 795 008c 002B     		cmp	r3, #0
 796 008e 00F0A080 		beq	.L53
 797              	.LBB3:
 423:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t space;
 424:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t unsent_optlen;
 425:../lwip-1.4.1/src/core/tcp_out.c **** 
 426:../lwip-1.4.1/src/core/tcp_out.c ****     /* @todo: this could be sped up by keeping last_unsent in the pcb */
 427:../lwip-1.4.1/src/core/tcp_out.c ****     for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 798              		.loc 1 427 0
 799 0092 FB68     		ldr	r3, [r7, #12]
 800 0094 DB6E     		ldr	r3, [r3, #108]
 801 0096 BB64     		str	r3, [r7, #72]
 802 0098 02E0     		b	.L40
 803              	.L41:
 428:../lwip-1.4.1/src/core/tcp_out.c ****          last_unsent = last_unsent->next);
 804              		.loc 1 428 0
 805 009a BB6C     		ldr	r3, [r7, #72]
 806 009c 1B68     		ldr	r3, [r3]
 807 009e BB64     		str	r3, [r7, #72]
 808              	.L40:
 427:../lwip-1.4.1/src/core/tcp_out.c ****          last_unsent = last_unsent->next);
 809              		.loc 1 427 0 discriminator 1
 810 00a0 BB6C     		ldr	r3, [r7, #72]
 811 00a2 1B68     		ldr	r3, [r3]
 812 00a4 002B     		cmp	r3, #0
 813 00a6 F8D1     		bne	.L41
 429:../lwip-1.4.1/src/core/tcp_out.c **** 
 430:../lwip-1.4.1/src/core/tcp_out.c ****     /* Usable space at the end of the last unsent segment */
 431:../lwip-1.4.1/src/core/tcp_out.c ****     unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 814              		.loc 1 431 0
 815 00a8 BB6C     		ldr	r3, [r7, #72]
 816 00aa 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 817 00ac 03F00103 		and	r3, r3, #1
 818 00b0 002B     		cmp	r3, #0
 819 00b2 01D0     		beq	.L42
 820              		.loc 1 431 0 is_stmt 0 discriminator 1
 821 00b4 0422     		movs	r2, #4
 822 00b6 00E0     		b	.L43
 823              	.L42:
 824              		.loc 1 431 0 discriminator 2
 825 00b8 0022     		movs	r2, #0
 826              	.L43:
 827              		.loc 1 431 0 discriminator 4
 828 00ba BB6C     		ldr	r3, [r7, #72]
 829 00bc 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 830 00be 03F00203 		and	r3, r3, #2
 831 00c2 002B     		cmp	r3, #0
 832 00c4 01D0     		beq	.L44
 833              		.loc 1 431 0 discriminator 5
 834 00c6 0C23     		movs	r3, #12
 835 00c8 00E0     		b	.L45
 836              	.L44:
 837              		.loc 1 431 0 discriminator 6
 838 00ca 0023     		movs	r3, #0
 839              	.L45:
 840              		.loc 1 431 0 discriminator 8
 841 00cc 1344     		add	r3, r3, r2
 842 00ce BB84     		strh	r3, [r7, #36]	@ movhi
 432:../lwip-1.4.1/src/core/tcp_out.c ****     space = mss_local - (last_unsent->len + unsent_optlen);
 843              		.loc 1 432 0 is_stmt 1 discriminator 8
 844 00d0 BB6C     		ldr	r3, [r7, #72]
 845 00d2 1A89     		ldrh	r2, [r3, #8]
 846 00d4 BB8C     		ldrh	r3, [r7, #36]	@ movhi
 847 00d6 1344     		add	r3, r3, r2
 848 00d8 9BB2     		uxth	r3, r3
 849 00da 3A8D     		ldrh	r2, [r7, #40]	@ movhi
 850 00dc D31A     		subs	r3, r2, r3
 851 00de BB86     		strh	r3, [r7, #52]	@ movhi
 433:../lwip-1.4.1/src/core/tcp_out.c **** 
 434:../lwip-1.4.1/src/core/tcp_out.c ****     /*
 435:../lwip-1.4.1/src/core/tcp_out.c ****      * Phase 1: Copy data directly into an oversized pbuf.
 436:../lwip-1.4.1/src/core/tcp_out.c ****      *
 437:../lwip-1.4.1/src/core/tcp_out.c ****      * The number of bytes copied is recorded in the oversize_used
 438:../lwip-1.4.1/src/core/tcp_out.c ****      * variable. The actual copying is done at the bottom of the
 439:../lwip-1.4.1/src/core/tcp_out.c ****      * function.
 440:../lwip-1.4.1/src/core/tcp_out.c ****      */
 441:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
 442:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 443:../lwip-1.4.1/src/core/tcp_out.c ****     /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
 444:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 445:../lwip-1.4.1/src/core/tcp_out.c ****                 pcb->unsent_oversize == last_unsent->oversize_left);
 446:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 447:../lwip-1.4.1/src/core/tcp_out.c ****     oversize = pcb->unsent_oversize;
 852              		.loc 1 447 0 discriminator 8
 853 00e0 FB68     		ldr	r3, [r7, #12]
 854 00e2 B3F86A30 		ldrh	r3, [r3, #106]
 855 00e6 FB82     		strh	r3, [r7, #22]	@ movhi
 448:../lwip-1.4.1/src/core/tcp_out.c ****     if (oversize > 0) {
 856              		.loc 1 448 0 discriminator 8
 857 00e8 FB8A     		ldrh	r3, [r7, #22]
 858 00ea 002B     		cmp	r3, #0
 859 00ec 14D0     		beq	.L46
 449:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
 450:../lwip-1.4.1/src/core/tcp_out.c ****       seg = last_unsent;
 860              		.loc 1 450 0
 861 00ee BB6C     		ldr	r3, [r7, #72]
 862 00f0 7B64     		str	r3, [r7, #68]
 451:../lwip-1.4.1/src/core/tcp_out.c ****       oversize_used = oversize < len ? oversize : len;
 863              		.loc 1 451 0
 864 00f2 FB8A     		ldrh	r3, [r7, #22]
 865 00f4 FA88     		ldrh	r2, [r7, #6]
 866 00f6 9342     		cmp	r3, r2
 867 00f8 28BF     		it	cs
 868 00fa 1346     		movcs	r3, r2
 869 00fc FB86     		strh	r3, [r7, #54]	@ movhi
 452:../lwip-1.4.1/src/core/tcp_out.c ****       pos += oversize_used;
 870              		.loc 1 452 0
 871 00fe 7A8F     		ldrh	r2, [r7, #58]	@ movhi
 872 0100 FB8E     		ldrh	r3, [r7, #54]	@ movhi
 873 0102 1344     		add	r3, r3, r2
 874 0104 7B87     		strh	r3, [r7, #58]	@ movhi
 453:../lwip-1.4.1/src/core/tcp_out.c ****       oversize -= oversize_used;
 875              		.loc 1 453 0
 876 0106 FA8A     		ldrh	r2, [r7, #22]
 877 0108 FB8E     		ldrh	r3, [r7, #54]	@ movhi
 878 010a D31A     		subs	r3, r2, r3
 879 010c 9BB2     		uxth	r3, r3
 880 010e FB82     		strh	r3, [r7, #22]	@ movhi
 454:../lwip-1.4.1/src/core/tcp_out.c ****       space -= oversize_used;
 881              		.loc 1 454 0
 882 0110 BA8E     		ldrh	r2, [r7, #52]	@ movhi
 883 0112 FB8E     		ldrh	r3, [r7, #54]	@ movhi
 884 0114 D31A     		subs	r3, r2, r3
 885 0116 BB86     		strh	r3, [r7, #52]	@ movhi
 886              	.L46:
 455:../lwip-1.4.1/src/core/tcp_out.c ****     }
 456:../lwip-1.4.1/src/core/tcp_out.c ****     /* now we are either finished or oversize is zero */
 457:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
 458:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 459:../lwip-1.4.1/src/core/tcp_out.c **** 
 460:../lwip-1.4.1/src/core/tcp_out.c ****     /*
 461:../lwip-1.4.1/src/core/tcp_out.c ****      * Phase 2: Chain a new pbuf to the end of pcb->unsent.
 462:../lwip-1.4.1/src/core/tcp_out.c ****      *
 463:../lwip-1.4.1/src/core/tcp_out.c ****      * We don't extend segments containing SYN/FIN flags or options
 464:../lwip-1.4.1/src/core/tcp_out.c ****      * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
 465:../lwip-1.4.1/src/core/tcp_out.c ****      * the end.
 466:../lwip-1.4.1/src/core/tcp_out.c ****      */
 467:../lwip-1.4.1/src/core/tcp_out.c ****     if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 887              		.loc 1 467 0
 888 0118 7A8F     		ldrh	r2, [r7, #58]
 889 011a FB88     		ldrh	r3, [r7, #6]
 890 011c 9A42     		cmp	r2, r3
 891 011e 58D2     		bcs	.L47
 892              		.loc 1 467 0 is_stmt 0 discriminator 1
 893 0120 BB8E     		ldrh	r3, [r7, #52]
 894 0122 002B     		cmp	r3, #0
 895 0124 55D0     		beq	.L47
 896              		.loc 1 467 0 discriminator 2
 897 0126 BB6C     		ldr	r3, [r7, #72]
 898 0128 1B89     		ldrh	r3, [r3, #8]
 899 012a 002B     		cmp	r3, #0
 900 012c 51D0     		beq	.L47
 901              	.LBB4:
 468:../lwip-1.4.1/src/core/tcp_out.c ****       u16_t seglen = space < len - pos ? space : len - pos;
 902              		.loc 1 468 0 is_stmt 1
 903 012e FA88     		ldrh	r2, [r7, #6]
 904 0130 7B8F     		ldrh	r3, [r7, #58]
 905 0132 D21A     		subs	r2, r2, r3
 906 0134 BB8E     		ldrh	r3, [r7, #52]
 907 0136 9342     		cmp	r3, r2
 908 0138 A8BF     		it	ge
 909 013a 1346     		movge	r3, r2
 910 013c 7B84     		strh	r3, [r7, #34]	@ movhi
 469:../lwip-1.4.1/src/core/tcp_out.c ****       seg = last_unsent;
 911              		.loc 1 469 0
 912 013e BB6C     		ldr	r3, [r7, #72]
 913 0140 7B64     		str	r3, [r7, #68]
 470:../lwip-1.4.1/src/core/tcp_out.c **** 
 471:../lwip-1.4.1/src/core/tcp_out.c ****       /* Create a pbuf with a copy or reference to seglen bytes. We
 472:../lwip-1.4.1/src/core/tcp_out.c ****        * can use PBUF_RAW here since the data appears in the middle of
 473:../lwip-1.4.1/src/core/tcp_out.c ****        * a segment. A header will never be prepended. */
 474:../lwip-1.4.1/src/core/tcp_out.c ****       if (apiflags & TCP_WRITE_FLAG_COPY) {
 914              		.loc 1 474 0
 915 0142 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 916 0144 03F00103 		and	r3, r3, #1
 917 0148 002B     		cmp	r3, #0
 918 014a 25D0     		beq	.L48
 475:../lwip-1.4.1/src/core/tcp_out.c ****         /* Data is copied */
 476:../lwip-1.4.1/src/core/tcp_out.c ****         if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) ==
 919              		.loc 1 476 0
 920 014c 798C     		ldrh	r1, [r7, #34]
 921 014e BA8E     		ldrh	r2, [r7, #52]
 922 0150 07F11604 		add	r4, r7, #22
 923 0154 FB68     		ldr	r3, [r7, #12]
 924 0156 0093     		str	r3, [sp]
 925 0158 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 926 015a 0193     		str	r3, [sp, #4]
 927 015c 0123     		movs	r3, #1
 928 015e 0293     		str	r3, [sp, #8]
 929 0160 0320     		movs	r0, #3
 930 0162 2346     		mov	r3, r4
 931 0164 FFF7FEFF 		bl	tcp_pbuf_prealloc
 932 0168 F864     		str	r0, [r7, #76]
 933 016a FB6C     		ldr	r3, [r7, #76]
 934 016c 002B     		cmp	r3, #0
 935 016e 00D1     		bne	.L49
 477:../lwip-1.4.1/src/core/tcp_out.c ****           LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
 478:../lwip-1.4.1/src/core/tcp_out.c ****                       ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
 479:../lwip-1.4.1/src/core/tcp_out.c ****                        seglen));
 480:../lwip-1.4.1/src/core/tcp_out.c ****           goto memerr;
 936              		.loc 1 480 0
 937 0170 60E1     		b	.L50
 938              	.L49:
 481:../lwip-1.4.1/src/core/tcp_out.c ****         }
 482:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 483:../lwip-1.4.1/src/core/tcp_out.c ****         last_unsent->oversize_left += oversize;
 939              		.loc 1 483 0
 940 0172 BB6C     		ldr	r3, [r7, #72]
 941 0174 5A89     		ldrh	r2, [r3, #10]
 942 0176 FB8A     		ldrh	r3, [r7, #22]
 943 0178 1344     		add	r3, r3, r2
 944 017a 9AB2     		uxth	r2, r3
 945 017c BB6C     		ldr	r3, [r7, #72]
 946 017e 5A81     		strh	r2, [r3, #10]	@ movhi
 484:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 485:../lwip-1.4.1/src/core/tcp_out.c ****         TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_
 947              		.loc 1 485 0
 948 0180 FB6C     		ldr	r3, [r7, #76]
 949 0182 5968     		ldr	r1, [r3, #4]
 950 0184 7B8F     		ldrh	r3, [r7, #58]
 951 0186 BA68     		ldr	r2, [r7, #8]
 952 0188 1A44     		add	r2, r2, r3
 953 018a 7B8C     		ldrh	r3, [r7, #34]
 954 018c 0846     		mov	r0, r1
 955 018e 1146     		mov	r1, r2
 956 0190 1A46     		mov	r2, r3
 957 0192 FFF7FEFF 		bl	memcpy
 958 0196 0FE0     		b	.L51
 959              	.L48:
 486:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 487:../lwip-1.4.1/src/core/tcp_out.c ****         concat_chksummed += seglen;
 488:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 489:../lwip-1.4.1/src/core/tcp_out.c ****       } else {
 490:../lwip-1.4.1/src/core/tcp_out.c ****         /* Data is not copied */
 491:../lwip-1.4.1/src/core/tcp_out.c ****         if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 960              		.loc 1 491 0
 961 0198 7B8C     		ldrh	r3, [r7, #34]
 962 019a 0320     		movs	r0, #3
 963 019c 1946     		mov	r1, r3
 964 019e 0122     		movs	r2, #1
 965 01a0 FFF7FEFF 		bl	pbuf_alloc
 966 01a4 F864     		str	r0, [r7, #76]
 967 01a6 FB6C     		ldr	r3, [r7, #76]
 968 01a8 002B     		cmp	r3, #0
 969 01aa 00D1     		bne	.L52
 492:../lwip-1.4.1/src/core/tcp_out.c ****           LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
 493:../lwip-1.4.1/src/core/tcp_out.c ****                       ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
 494:../lwip-1.4.1/src/core/tcp_out.c ****           goto memerr;
 970              		.loc 1 494 0
 971 01ac 42E1     		b	.L50
 972              	.L52:
 495:../lwip-1.4.1/src/core/tcp_out.c ****         }
 496:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 497:../lwip-1.4.1/src/core/tcp_out.c ****         /* calculate the checksum of nocopy-data */
 498:../lwip-1.4.1/src/core/tcp_out.c ****         tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
 499:../lwip-1.4.1/src/core/tcp_out.c ****           &concat_chksum, &concat_chksum_swapped);
 500:../lwip-1.4.1/src/core/tcp_out.c ****         concat_chksummed += seglen;
 501:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 502:../lwip-1.4.1/src/core/tcp_out.c ****         /* reference the non-volatile payload data */
 503:../lwip-1.4.1/src/core/tcp_out.c ****         concat_p->payload = (u8_t*)arg + pos;
 973              		.loc 1 503 0
 974 01ae 7B8F     		ldrh	r3, [r7, #58]
 975 01b0 BA68     		ldr	r2, [r7, #8]
 976 01b2 1A44     		add	r2, r2, r3
 977 01b4 FB6C     		ldr	r3, [r7, #76]
 978 01b6 5A60     		str	r2, [r3, #4]
 979              	.L51:
 504:../lwip-1.4.1/src/core/tcp_out.c ****       }
 505:../lwip-1.4.1/src/core/tcp_out.c **** 
 506:../lwip-1.4.1/src/core/tcp_out.c ****       pos += seglen;
 980              		.loc 1 506 0
 981 01b8 7A8F     		ldrh	r2, [r7, #58]	@ movhi
 982 01ba 7B8C     		ldrh	r3, [r7, #34]	@ movhi
 983 01bc 1344     		add	r3, r3, r2
 984 01be 7B87     		strh	r3, [r7, #58]	@ movhi
 507:../lwip-1.4.1/src/core/tcp_out.c ****       queuelen += pbuf_clen(concat_p);
 985              		.loc 1 507 0
 986 01c0 F86C     		ldr	r0, [r7, #76]
 987 01c2 FFF7FEFF 		bl	pbuf_clen
 988 01c6 0346     		mov	r3, r0
 989 01c8 9AB2     		uxth	r2, r3
 990 01ca 3B8F     		ldrh	r3, [r7, #56]	@ movhi
 991 01cc 1344     		add	r3, r3, r2
 992 01ce 3B87     		strh	r3, [r7, #56]	@ movhi
 993              	.LBE4:
 994              	.LBE3:
 995 01d0 FFE7     		b	.L53
 996              	.L47:
 997              	.L53:
 508:../lwip-1.4.1/src/core/tcp_out.c ****     }
 509:../lwip-1.4.1/src/core/tcp_out.c ****   } else {
 510:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
 511:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 512:../lwip-1.4.1/src/core/tcp_out.c ****                 pcb->unsent_oversize == 0);
 513:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 514:../lwip-1.4.1/src/core/tcp_out.c ****   }
 515:../lwip-1.4.1/src/core/tcp_out.c **** 
 516:../lwip-1.4.1/src/core/tcp_out.c ****   /*
 517:../lwip-1.4.1/src/core/tcp_out.c ****    * Phase 3: Create new segments.
 518:../lwip-1.4.1/src/core/tcp_out.c ****    *
 519:../lwip-1.4.1/src/core/tcp_out.c ****    * The new segments are chained together in the local 'queue'
 520:../lwip-1.4.1/src/core/tcp_out.c ****    * variable, ready to be appended to pcb->unsent.
 521:../lwip-1.4.1/src/core/tcp_out.c ****    */
 522:../lwip-1.4.1/src/core/tcp_out.c ****   while (pos < len) {
 998              		.loc 1 522 0 discriminator 4
 999 01d2 9DE0     		b	.L54
 1000              	.L65:
 1001              	.LBB5:
 523:../lwip-1.4.1/src/core/tcp_out.c ****     struct pbuf *p;
 524:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t left = len - pos;
 1002              		.loc 1 524 0
 1003 01d4 FA88     		ldrh	r2, [r7, #6]	@ movhi
 1004 01d6 7B8F     		ldrh	r3, [r7, #58]	@ movhi
 1005 01d8 D31A     		subs	r3, r2, r3
 1006 01da 3B84     		strh	r3, [r7, #32]	@ movhi
 525:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t max_len = mss_local - optlen;
 1007              		.loc 1 525 0
 1008 01dc 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 1009 01e0 9BB2     		uxth	r3, r3
 1010 01e2 3A8D     		ldrh	r2, [r7, #40]	@ movhi
 1011 01e4 D31A     		subs	r3, r2, r3
 1012 01e6 FB83     		strh	r3, [r7, #30]	@ movhi
 526:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t seglen = left > max_len ? max_len : left;
 1013              		.loc 1 526 0
 1014 01e8 3A8C     		ldrh	r2, [r7, #32]
 1015 01ea FB8B     		ldrh	r3, [r7, #30]
 1016 01ec 9342     		cmp	r3, r2
 1017 01ee 28BF     		it	cs
 1018 01f0 1346     		movcs	r3, r2
 1019 01f2 BB83     		strh	r3, [r7, #28]	@ movhi
 527:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 528:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t chksum = 0;
 529:../lwip-1.4.1/src/core/tcp_out.c ****     u8_t chksum_swapped = 0;
 530:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 531:../lwip-1.4.1/src/core/tcp_out.c **** 
 532:../lwip-1.4.1/src/core/tcp_out.c ****     if (apiflags & TCP_WRITE_FLAG_COPY) {
 1020              		.loc 1 532 0
 1021 01f4 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1022 01f6 03F00103 		and	r3, r3, #1
 1023 01fa 002B     		cmp	r3, #0
 1024 01fc 2CD0     		beq	.L55
 533:../lwip-1.4.1/src/core/tcp_out.c ****       /* If copy is set, memory should be allocated and data copied
 534:../lwip-1.4.1/src/core/tcp_out.c ****        * into pbuf */
 535:../lwip-1.4.1/src/core/tcp_out.c ****       if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apifla
 1025              		.loc 1 535 0
 1026 01fe 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 1027 0202 9AB2     		uxth	r2, r3
 1028 0204 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 1029 0206 1344     		add	r3, r3, r2
 1030 0208 99B2     		uxth	r1, r3
 1031 020a FB6B     		ldr	r3, [r7, #60]
 1032 020c 002B     		cmp	r3, #0
 1033 020e 0CBF     		ite	eq
 1034 0210 0123     		moveq	r3, #1
 1035 0212 0023     		movne	r3, #0
 1036 0214 DBB2     		uxtb	r3, r3
 1037 0216 1846     		mov	r0, r3
 1038 0218 3A8D     		ldrh	r2, [r7, #40]
 1039 021a 07F11604 		add	r4, r7, #22
 1040 021e FB68     		ldr	r3, [r7, #12]
 1041 0220 0093     		str	r3, [sp]
 1042 0222 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1043 0224 0193     		str	r3, [sp, #4]
 1044 0226 0290     		str	r0, [sp, #8]
 1045 0228 0020     		movs	r0, #0
 1046 022a 2346     		mov	r3, r4
 1047 022c FFF7FEFF 		bl	tcp_pbuf_prealloc
 1048 0230 3863     		str	r0, [r7, #48]
 1049 0232 3B6B     		ldr	r3, [r7, #48]
 1050 0234 002B     		cmp	r3, #0
 1051 0236 00D1     		bne	.L56
 536:../lwip-1.4.1/src/core/tcp_out.c ****         LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy siz
 537:../lwip-1.4.1/src/core/tcp_out.c ****         goto memerr;
 1052              		.loc 1 537 0
 1053 0238 FCE0     		b	.L50
 1054              	.L56:
 538:../lwip-1.4.1/src/core/tcp_out.c ****       }
 539:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 540:../lwip-1.4.1/src/core/tcp_out.c ****                   (p->len >= seglen));
 541:../lwip-1.4.1/src/core/tcp_out.c ****       TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swappe
 1055              		.loc 1 541 0
 1056 023a 3B6B     		ldr	r3, [r7, #48]
 1057 023c 5A68     		ldr	r2, [r3, #4]
 1058 023e 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 1059 0242 D118     		adds	r1, r2, r3
 1060 0244 7B8F     		ldrh	r3, [r7, #58]
 1061 0246 BA68     		ldr	r2, [r7, #8]
 1062 0248 1A44     		add	r2, r2, r3
 1063 024a BB8B     		ldrh	r3, [r7, #28]
 1064 024c 0846     		mov	r0, r1
 1065 024e 1146     		mov	r1, r2
 1066 0250 1A46     		mov	r2, r3
 1067 0252 FFF7FEFF 		bl	memcpy
 1068 0256 23E0     		b	.L57
 1069              	.L55:
 1070              	.LBB6:
 542:../lwip-1.4.1/src/core/tcp_out.c ****     } else {
 543:../lwip-1.4.1/src/core/tcp_out.c ****       /* Copy is not set: First allocate a pbuf for holding the data.
 544:../lwip-1.4.1/src/core/tcp_out.c ****        * Since the referenced data is available at least until it is
 545:../lwip-1.4.1/src/core/tcp_out.c ****        * sent out on the link (as it has to be ACKed by the remote
 546:../lwip-1.4.1/src/core/tcp_out.c ****        * party) we can safely use PBUF_ROM instead of PBUF_REF here.
 547:../lwip-1.4.1/src/core/tcp_out.c ****        */
 548:../lwip-1.4.1/src/core/tcp_out.c ****       struct pbuf *p2;
 549:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
 550:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_ASSERT("oversize == 0", oversize == 0);
 551:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 552:../lwip-1.4.1/src/core/tcp_out.c ****       if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 1071              		.loc 1 552 0
 1072 0258 BB8B     		ldrh	r3, [r7, #28]
 1073 025a 0020     		movs	r0, #0
 1074 025c 1946     		mov	r1, r3
 1075 025e 0122     		movs	r2, #1
 1076 0260 FFF7FEFF 		bl	pbuf_alloc
 1077 0264 B861     		str	r0, [r7, #24]
 1078 0266 BB69     		ldr	r3, [r7, #24]
 1079 0268 002B     		cmp	r3, #0
 1080 026a 00D1     		bne	.L58
 553:../lwip-1.4.1/src/core/tcp_out.c ****         LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf
 554:../lwip-1.4.1/src/core/tcp_out.c ****         goto memerr;
 1081              		.loc 1 554 0
 1082 026c E2E0     		b	.L50
 1083              	.L58:
 555:../lwip-1.4.1/src/core/tcp_out.c ****       }
 556:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 557:../lwip-1.4.1/src/core/tcp_out.c ****       /* calculate the checksum of nocopy-data */
 558:../lwip-1.4.1/src/core/tcp_out.c ****       chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
 559:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 560:../lwip-1.4.1/src/core/tcp_out.c ****       /* reference the non-volatile payload data */
 561:../lwip-1.4.1/src/core/tcp_out.c ****       p2->payload = (u8_t*)arg + pos;
 1084              		.loc 1 561 0
 1085 026e 7B8F     		ldrh	r3, [r7, #58]
 1086 0270 BA68     		ldr	r2, [r7, #8]
 1087 0272 1A44     		add	r2, r2, r3
 1088 0274 BB69     		ldr	r3, [r7, #24]
 1089 0276 5A60     		str	r2, [r3, #4]
 562:../lwip-1.4.1/src/core/tcp_out.c **** 
 563:../lwip-1.4.1/src/core/tcp_out.c ****       /* Second, allocate a pbuf for the headers. */
 564:../lwip-1.4.1/src/core/tcp_out.c ****       if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 1090              		.loc 1 564 0
 1091 0278 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 1092 027c 9BB2     		uxth	r3, r3
 1093 027e 0020     		movs	r0, #0
 1094 0280 1946     		mov	r1, r3
 1095 0282 0022     		movs	r2, #0
 1096 0284 FFF7FEFF 		bl	pbuf_alloc
 1097 0288 3863     		str	r0, [r7, #48]
 1098 028a 3B6B     		ldr	r3, [r7, #48]
 1099 028c 002B     		cmp	r3, #0
 1100 028e 03D1     		bne	.L59
 565:../lwip-1.4.1/src/core/tcp_out.c ****         /* If allocation fails, we have to deallocate the data pbuf as
 566:../lwip-1.4.1/src/core/tcp_out.c ****          * well. */
 567:../lwip-1.4.1/src/core/tcp_out.c ****         pbuf_free(p2);
 1101              		.loc 1 567 0
 1102 0290 B869     		ldr	r0, [r7, #24]
 1103 0292 FFF7FEFF 		bl	pbuf_free
 568:../lwip-1.4.1/src/core/tcp_out.c ****         LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"
 569:../lwip-1.4.1/src/core/tcp_out.c ****         goto memerr;
 1104              		.loc 1 569 0
 1105 0296 CDE0     		b	.L50
 1106              	.L59:
 570:../lwip-1.4.1/src/core/tcp_out.c ****       }
 571:../lwip-1.4.1/src/core/tcp_out.c ****       /* Concatenate the headers and data pbufs together. */
 572:../lwip-1.4.1/src/core/tcp_out.c ****       pbuf_cat(p/*header*/, p2/*data*/);
 1107              		.loc 1 572 0
 1108 0298 386B     		ldr	r0, [r7, #48]
 1109 029a B969     		ldr	r1, [r7, #24]
 1110 029c FFF7FEFF 		bl	pbuf_cat
 1111              	.L57:
 1112              	.LBE6:
 573:../lwip-1.4.1/src/core/tcp_out.c ****     }
 574:../lwip-1.4.1/src/core/tcp_out.c **** 
 575:../lwip-1.4.1/src/core/tcp_out.c ****     queuelen += pbuf_clen(p);
 1113              		.loc 1 575 0
 1114 02a0 386B     		ldr	r0, [r7, #48]
 1115 02a2 FFF7FEFF 		bl	pbuf_clen
 1116 02a6 0346     		mov	r3, r0
 1117 02a8 9AB2     		uxth	r2, r3
 1118 02aa 3B8F     		ldrh	r3, [r7, #56]	@ movhi
 1119 02ac 1344     		add	r3, r3, r2
 1120 02ae 3B87     		strh	r3, [r7, #56]	@ movhi
 576:../lwip-1.4.1/src/core/tcp_out.c **** 
 577:../lwip-1.4.1/src/core/tcp_out.c ****     /* Now that there are more segments queued, we check again if the
 578:../lwip-1.4.1/src/core/tcp_out.c ****      * length of the queue exceeds the configured maximum or
 579:../lwip-1.4.1/src/core/tcp_out.c ****      * overflows. */
 580:../lwip-1.4.1/src/core/tcp_out.c ****     if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 1121              		.loc 1 580 0
 1122 02b0 3B8F     		ldrh	r3, [r7, #56]
 1123 02b2 082B     		cmp	r3, #8
 1124 02b4 04D8     		bhi	.L60
 1125              		.loc 1 580 0 is_stmt 0 discriminator 1
 1126 02b6 3B8F     		ldrh	r3, [r7, #56]
 1127 02b8 4FF6FC72 		movw	r2, #65532
 1128 02bc 9342     		cmp	r3, r2
 1129 02be 03D9     		bls	.L61
 1130              	.L60:
 581:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuele
 582:../lwip-1.4.1/src/core/tcp_out.c ****       pbuf_free(p);
 1131              		.loc 1 582 0 is_stmt 1
 1132 02c0 386B     		ldr	r0, [r7, #48]
 1133 02c2 FFF7FEFF 		bl	pbuf_free
 583:../lwip-1.4.1/src/core/tcp_out.c ****       goto memerr;
 1134              		.loc 1 583 0
 1135 02c6 B5E0     		b	.L50
 1136              	.L61:
 584:../lwip-1.4.1/src/core/tcp_out.c ****     }
 585:../lwip-1.4.1/src/core/tcp_out.c **** 
 586:../lwip-1.4.1/src/core/tcp_out.c ****     if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 1137              		.loc 1 586 0
 1138 02c8 FB68     		ldr	r3, [r7, #12]
 1139 02ca DA6D     		ldr	r2, [r3, #92]
 1140 02cc 7B8F     		ldrh	r3, [r7, #58]
 1141 02ce D418     		adds	r4, r2, r3
 1142 02d0 97F82A30 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 1143 02d4 0093     		str	r3, [sp]
 1144 02d6 F868     		ldr	r0, [r7, #12]
 1145 02d8 396B     		ldr	r1, [r7, #48]
 1146 02da 0022     		movs	r2, #0
 1147 02dc 2346     		mov	r3, r4
 1148 02de FFF7FEFF 		bl	tcp_create_segment
 1149 02e2 7864     		str	r0, [r7, #68]
 1150 02e4 7B6C     		ldr	r3, [r7, #68]
 1151 02e6 002B     		cmp	r3, #0
 1152 02e8 00D1     		bne	.L62
 587:../lwip-1.4.1/src/core/tcp_out.c ****       goto memerr;
 1153              		.loc 1 587 0
 1154 02ea A3E0     		b	.L50
 1155              	.L62:
 588:../lwip-1.4.1/src/core/tcp_out.c ****     }
 589:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 590:../lwip-1.4.1/src/core/tcp_out.c ****     seg->oversize_left = oversize;
 1156              		.loc 1 590 0
 1157 02ec FA8A     		ldrh	r2, [r7, #22]
 1158 02ee 7B6C     		ldr	r3, [r7, #68]
 1159 02f0 5A81     		strh	r2, [r3, #10]	@ movhi
 591:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 592:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 593:../lwip-1.4.1/src/core/tcp_out.c ****     seg->chksum = chksum;
 594:../lwip-1.4.1/src/core/tcp_out.c ****     seg->chksum_swapped = chksum_swapped;
 595:../lwip-1.4.1/src/core/tcp_out.c ****     seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 596:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 597:../lwip-1.4.1/src/core/tcp_out.c **** 
 598:../lwip-1.4.1/src/core/tcp_out.c ****     /* first segment of to-be-queued data? */
 599:../lwip-1.4.1/src/core/tcp_out.c ****     if (queue == NULL) {
 1160              		.loc 1 599 0
 1161 02f2 FB6B     		ldr	r3, [r7, #60]
 1162 02f4 002B     		cmp	r3, #0
 1163 02f6 02D1     		bne	.L63
 600:../lwip-1.4.1/src/core/tcp_out.c ****       queue = seg;
 1164              		.loc 1 600 0
 1165 02f8 7B6C     		ldr	r3, [r7, #68]
 1166 02fa FB63     		str	r3, [r7, #60]
 1167 02fc 02E0     		b	.L64
 1168              	.L63:
 601:../lwip-1.4.1/src/core/tcp_out.c ****     } else {
 602:../lwip-1.4.1/src/core/tcp_out.c ****       /* Attach the segment to the end of the queued segments */
 603:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 604:../lwip-1.4.1/src/core/tcp_out.c ****       prev_seg->next = seg;
 1169              		.loc 1 604 0
 1170 02fe 3B6C     		ldr	r3, [r7, #64]
 1171 0300 7A6C     		ldr	r2, [r7, #68]
 1172 0302 1A60     		str	r2, [r3]
 1173              	.L64:
 605:../lwip-1.4.1/src/core/tcp_out.c ****     }
 606:../lwip-1.4.1/src/core/tcp_out.c ****     /* remember last segment of to-be-queued data for next iteration */
 607:../lwip-1.4.1/src/core/tcp_out.c ****     prev_seg = seg;
 1174              		.loc 1 607 0
 1175 0304 7B6C     		ldr	r3, [r7, #68]
 1176 0306 3B64     		str	r3, [r7, #64]
 608:../lwip-1.4.1/src/core/tcp_out.c **** 
 609:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
 610:../lwip-1.4.1/src/core/tcp_out.c ****       ntohl(seg->tcphdr->seqno),
 611:../lwip-1.4.1/src/core/tcp_out.c ****       ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
 612:../lwip-1.4.1/src/core/tcp_out.c **** 
 613:../lwip-1.4.1/src/core/tcp_out.c ****     pos += seglen;
 1177              		.loc 1 613 0
 1178 0308 7A8F     		ldrh	r2, [r7, #58]	@ movhi
 1179 030a BB8B     		ldrh	r3, [r7, #28]	@ movhi
 1180 030c 1344     		add	r3, r3, r2
 1181 030e 7B87     		strh	r3, [r7, #58]	@ movhi
 1182              	.L54:
 1183              	.LBE5:
 522:../lwip-1.4.1/src/core/tcp_out.c ****     struct pbuf *p;
 1184              		.loc 1 522 0
 1185 0310 7A8F     		ldrh	r2, [r7, #58]
 1186 0312 FB88     		ldrh	r3, [r7, #6]
 1187 0314 9A42     		cmp	r2, r3
 1188 0316 FFF45DAF 		bcc	.L65
 614:../lwip-1.4.1/src/core/tcp_out.c ****   }
 615:../lwip-1.4.1/src/core/tcp_out.c **** 
 616:../lwip-1.4.1/src/core/tcp_out.c ****   /*
 617:../lwip-1.4.1/src/core/tcp_out.c ****    * All three segmentation phases were successful. We can commit the
 618:../lwip-1.4.1/src/core/tcp_out.c ****    * transaction.
 619:../lwip-1.4.1/src/core/tcp_out.c ****    */
 620:../lwip-1.4.1/src/core/tcp_out.c **** 
 621:../lwip-1.4.1/src/core/tcp_out.c ****   /*
 622:../lwip-1.4.1/src/core/tcp_out.c ****    * Phase 1: If data has been added to the preallocated tail of
 623:../lwip-1.4.1/src/core/tcp_out.c ****    * last_unsent, we update the length fields of the pbuf chain.
 624:../lwip-1.4.1/src/core/tcp_out.c ****    */
 625:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
 626:../lwip-1.4.1/src/core/tcp_out.c ****   if (oversize_used > 0) {
 1189              		.loc 1 626 0
 1190 031a FB8E     		ldrh	r3, [r7, #54]
 1191 031c 002B     		cmp	r3, #0
 1192 031e 34D0     		beq	.L66
 1193              	.LBB7:
 627:../lwip-1.4.1/src/core/tcp_out.c ****     struct pbuf *p;
 628:../lwip-1.4.1/src/core/tcp_out.c ****     /* Bump tot_len of whole chain, len of tail */
 629:../lwip-1.4.1/src/core/tcp_out.c ****     for (p = last_unsent->p; p; p = p->next) {
 1194              		.loc 1 629 0
 1195 0320 BB6C     		ldr	r3, [r7, #72]
 1196 0322 5B68     		ldr	r3, [r3, #4]
 1197 0324 FB62     		str	r3, [r7, #44]
 1198 0326 1FE0     		b	.L67
 1199              	.L69:
 630:../lwip-1.4.1/src/core/tcp_out.c ****       p->tot_len += oversize_used;
 1200              		.loc 1 630 0
 1201 0328 FB6A     		ldr	r3, [r7, #44]
 1202 032a 1A89     		ldrh	r2, [r3, #8]
 1203 032c FB8E     		ldrh	r3, [r7, #54]	@ movhi
 1204 032e 1344     		add	r3, r3, r2
 1205 0330 9AB2     		uxth	r2, r3
 1206 0332 FB6A     		ldr	r3, [r7, #44]
 1207 0334 1A81     		strh	r2, [r3, #8]	@ movhi
 631:../lwip-1.4.1/src/core/tcp_out.c ****       if (p->next == NULL) {
 1208              		.loc 1 631 0
 1209 0336 FB6A     		ldr	r3, [r7, #44]
 1210 0338 1B68     		ldr	r3, [r3]
 1211 033a 002B     		cmp	r3, #0
 1212 033c 11D1     		bne	.L68
 632:../lwip-1.4.1/src/core/tcp_out.c ****         TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 1213              		.loc 1 632 0
 1214 033e FB6A     		ldr	r3, [r7, #44]
 1215 0340 5B68     		ldr	r3, [r3, #4]
 1216 0342 FA6A     		ldr	r2, [r7, #44]
 1217 0344 5289     		ldrh	r2, [r2, #10]
 1218 0346 1A44     		add	r2, r2, r3
 1219 0348 FB8E     		ldrh	r3, [r7, #54]
 1220 034a 1046     		mov	r0, r2
 1221 034c B968     		ldr	r1, [r7, #8]
 1222 034e 1A46     		mov	r2, r3
 1223 0350 FFF7FEFF 		bl	memcpy
 633:../lwip-1.4.1/src/core/tcp_out.c ****         p->len += oversize_used;
 1224              		.loc 1 633 0
 1225 0354 FB6A     		ldr	r3, [r7, #44]
 1226 0356 5A89     		ldrh	r2, [r3, #10]
 1227 0358 FB8E     		ldrh	r3, [r7, #54]	@ movhi
 1228 035a 1344     		add	r3, r3, r2
 1229 035c 9AB2     		uxth	r2, r3
 1230 035e FB6A     		ldr	r3, [r7, #44]
 1231 0360 5A81     		strh	r2, [r3, #10]	@ movhi
 1232              	.L68:
 629:../lwip-1.4.1/src/core/tcp_out.c ****       p->tot_len += oversize_used;
 1233              		.loc 1 629 0 discriminator 2
 1234 0362 FB6A     		ldr	r3, [r7, #44]
 1235 0364 1B68     		ldr	r3, [r3]
 1236 0366 FB62     		str	r3, [r7, #44]
 1237              	.L67:
 629:../lwip-1.4.1/src/core/tcp_out.c ****       p->tot_len += oversize_used;
 1238              		.loc 1 629 0 is_stmt 0 discriminator 1
 1239 0368 FB6A     		ldr	r3, [r7, #44]
 1240 036a 002B     		cmp	r3, #0
 1241 036c DCD1     		bne	.L69
 634:../lwip-1.4.1/src/core/tcp_out.c ****       }
 635:../lwip-1.4.1/src/core/tcp_out.c ****     }
 636:../lwip-1.4.1/src/core/tcp_out.c ****     last_unsent->len += oversize_used;
 1242              		.loc 1 636 0 is_stmt 1
 1243 036e BB6C     		ldr	r3, [r7, #72]
 1244 0370 1A89     		ldrh	r2, [r3, #8]
 1245 0372 FB8E     		ldrh	r3, [r7, #54]	@ movhi
 1246 0374 1344     		add	r3, r3, r2
 1247 0376 9AB2     		uxth	r2, r3
 1248 0378 BB6C     		ldr	r3, [r7, #72]
 1249 037a 1A81     		strh	r2, [r3, #8]	@ movhi
 637:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 638:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 639:../lwip-1.4.1/src/core/tcp_out.c ****                 last_unsent->oversize_left >= oversize_used);
 640:../lwip-1.4.1/src/core/tcp_out.c ****     last_unsent->oversize_left -= oversize_used;
 1250              		.loc 1 640 0
 1251 037c BB6C     		ldr	r3, [r7, #72]
 1252 037e 5A89     		ldrh	r2, [r3, #10]
 1253 0380 FB8E     		ldrh	r3, [r7, #54]	@ movhi
 1254 0382 D31A     		subs	r3, r2, r3
 1255 0384 9AB2     		uxth	r2, r3
 1256 0386 BB6C     		ldr	r3, [r7, #72]
 1257 0388 5A81     		strh	r2, [r3, #10]	@ movhi
 1258              	.L66:
 1259              	.LBE7:
 641:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 642:../lwip-1.4.1/src/core/tcp_out.c ****   }
 643:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->unsent_oversize = oversize;
 1260              		.loc 1 643 0
 1261 038a FA8A     		ldrh	r2, [r7, #22]
 1262 038c FB68     		ldr	r3, [r7, #12]
 1263 038e A3F86A20 		strh	r2, [r3, #106]	@ movhi
 644:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 645:../lwip-1.4.1/src/core/tcp_out.c **** 
 646:../lwip-1.4.1/src/core/tcp_out.c ****   /*
 647:../lwip-1.4.1/src/core/tcp_out.c ****    * Phase 2: concat_p can be concatenated onto last_unsent->p
 648:../lwip-1.4.1/src/core/tcp_out.c ****    */
 649:../lwip-1.4.1/src/core/tcp_out.c ****   if (concat_p != NULL) {
 1264              		.loc 1 649 0
 1265 0392 FB6C     		ldr	r3, [r7, #76]
 1266 0394 002B     		cmp	r3, #0
 1267 0396 0DD0     		beq	.L70
 650:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 651:../lwip-1.4.1/src/core/tcp_out.c ****       (last_unsent != NULL));
 652:../lwip-1.4.1/src/core/tcp_out.c ****     pbuf_cat(last_unsent->p, concat_p);
 1268              		.loc 1 652 0
 1269 0398 BB6C     		ldr	r3, [r7, #72]
 1270 039a 5B68     		ldr	r3, [r3, #4]
 1271 039c 1846     		mov	r0, r3
 1272 039e F96C     		ldr	r1, [r7, #76]
 1273 03a0 FFF7FEFF 		bl	pbuf_cat
 653:../lwip-1.4.1/src/core/tcp_out.c ****     last_unsent->len += concat_p->tot_len;
 1274              		.loc 1 653 0
 1275 03a4 BB6C     		ldr	r3, [r7, #72]
 1276 03a6 1A89     		ldrh	r2, [r3, #8]
 1277 03a8 FB6C     		ldr	r3, [r7, #76]
 1278 03aa 1B89     		ldrh	r3, [r3, #8]
 1279 03ac 1344     		add	r3, r3, r2
 1280 03ae 9AB2     		uxth	r2, r3
 1281 03b0 BB6C     		ldr	r3, [r7, #72]
 1282 03b2 1A81     		strh	r2, [r3, #8]	@ movhi
 1283              	.L70:
 654:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 655:../lwip-1.4.1/src/core/tcp_out.c ****     if (concat_chksummed) {
 656:../lwip-1.4.1/src/core/tcp_out.c ****       tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 657:../lwip-1.4.1/src/core/tcp_out.c ****         &last_unsent->chksum_swapped);
 658:../lwip-1.4.1/src/core/tcp_out.c ****       last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 659:../lwip-1.4.1/src/core/tcp_out.c ****     }
 660:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 661:../lwip-1.4.1/src/core/tcp_out.c ****   }
 662:../lwip-1.4.1/src/core/tcp_out.c **** 
 663:../lwip-1.4.1/src/core/tcp_out.c ****   /*
 664:../lwip-1.4.1/src/core/tcp_out.c ****    * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
 665:../lwip-1.4.1/src/core/tcp_out.c ****    * is harmless
 666:../lwip-1.4.1/src/core/tcp_out.c ****    */
 667:../lwip-1.4.1/src/core/tcp_out.c ****   if (last_unsent == NULL) {
 1284              		.loc 1 667 0
 1285 03b4 BB6C     		ldr	r3, [r7, #72]
 1286 03b6 002B     		cmp	r3, #0
 1287 03b8 03D1     		bne	.L71
 668:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->unsent = queue;
 1288              		.loc 1 668 0
 1289 03ba FB68     		ldr	r3, [r7, #12]
 1290 03bc FA6B     		ldr	r2, [r7, #60]
 1291 03be DA66     		str	r2, [r3, #108]
 1292 03c0 02E0     		b	.L72
 1293              	.L71:
 669:../lwip-1.4.1/src/core/tcp_out.c ****   } else {
 670:../lwip-1.4.1/src/core/tcp_out.c ****     last_unsent->next = queue;
 1294              		.loc 1 670 0
 1295 03c2 BB6C     		ldr	r3, [r7, #72]
 1296 03c4 FA6B     		ldr	r2, [r7, #60]
 1297 03c6 1A60     		str	r2, [r3]
 1298              	.L72:
 671:../lwip-1.4.1/src/core/tcp_out.c ****   }
 672:../lwip-1.4.1/src/core/tcp_out.c **** 
 673:../lwip-1.4.1/src/core/tcp_out.c ****   /*
 674:../lwip-1.4.1/src/core/tcp_out.c ****    * Finally update the pcb state.
 675:../lwip-1.4.1/src/core/tcp_out.c ****    */
 676:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->snd_lbb += len;
 1299              		.loc 1 676 0
 1300 03c8 FB68     		ldr	r3, [r7, #12]
 1301 03ca DA6D     		ldr	r2, [r3, #92]
 1302 03cc FB88     		ldrh	r3, [r7, #6]
 1303 03ce 1A44     		add	r2, r2, r3
 1304 03d0 FB68     		ldr	r3, [r7, #12]
 1305 03d2 DA65     		str	r2, [r3, #92]
 677:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->snd_buf -= len;
 1306              		.loc 1 677 0
 1307 03d4 FB68     		ldr	r3, [r7, #12]
 1308 03d6 B3F86620 		ldrh	r2, [r3, #102]
 1309 03da FB88     		ldrh	r3, [r7, #6]	@ movhi
 1310 03dc D31A     		subs	r3, r2, r3
 1311 03de 9AB2     		uxth	r2, r3
 1312 03e0 FB68     		ldr	r3, [r7, #12]
 1313 03e2 A3F86620 		strh	r2, [r3, #102]	@ movhi
 678:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->snd_queuelen = queuelen;
 1314              		.loc 1 678 0
 1315 03e6 FB68     		ldr	r3, [r7, #12]
 1316 03e8 3A8F     		ldrh	r2, [r7, #56]	@ movhi
 1317 03ea A3F86820 		strh	r2, [r3, #104]	@ movhi
 679:../lwip-1.4.1/src/core/tcp_out.c **** 
 680:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
 681:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->snd_queuelen));
 682:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
 1318              		.loc 1 682 0
 1319 03ee FB68     		ldr	r3, [r7, #12]
 1320 03f0 B3F86830 		ldrh	r3, [r3, #104]
 1321 03f4 002B     		cmp	r3, #0
 1322 03f6 02D0     		beq	.L73
 683:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: valid queue length",
 1323              		.loc 1 683 0
 1324 03f8 FB68     		ldr	r3, [r7, #12]
 1325 03fa 1B6F     		ldr	r3, [r3, #112]
 1326 03fc 002B     		cmp	r3, #0
 1327              	.L73:
 684:../lwip-1.4.1/src/core/tcp_out.c ****                 pcb->unacked != NULL || pcb->unsent != NULL);
 685:../lwip-1.4.1/src/core/tcp_out.c ****   }
 686:../lwip-1.4.1/src/core/tcp_out.c **** 
 687:../lwip-1.4.1/src/core/tcp_out.c ****   /* Set the PSH flag in the last segment that we enqueued. */
 688:../lwip-1.4.1/src/core/tcp_out.c ****   if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 1328              		.loc 1 688 0
 1329 03fe 7B6C     		ldr	r3, [r7, #68]
 1330 0400 002B     		cmp	r3, #0
 1331 0402 15D0     		beq	.L74
 1332              		.loc 1 688 0 is_stmt 0 discriminator 1
 1333 0404 7B6C     		ldr	r3, [r7, #68]
 1334 0406 1B69     		ldr	r3, [r3, #16]
 1335 0408 002B     		cmp	r3, #0
 1336 040a 11D0     		beq	.L74
 1337              		.loc 1 688 0 discriminator 2
 1338 040c 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1339 040e 03F00203 		and	r3, r3, #2
 1340 0412 002B     		cmp	r3, #0
 1341 0414 0CD1     		bne	.L74
 689:../lwip-1.4.1/src/core/tcp_out.c ****     TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 1342              		.loc 1 689 0 is_stmt 1
 1343 0416 7B6C     		ldr	r3, [r7, #68]
 1344 0418 1C69     		ldr	r4, [r3, #16]
 1345 041a 7B6C     		ldr	r3, [r7, #68]
 1346 041c 1B69     		ldr	r3, [r3, #16]
 1347 041e 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 1348 0420 9DB2     		uxth	r5, r3
 1349 0422 0820     		movs	r0, #8
 1350 0424 FFF7FEFF 		bl	lwip_htons
 1351 0428 0346     		mov	r3, r0
 1352 042a 2B43     		orrs	r3, r3, r5
 1353 042c 9BB2     		uxth	r3, r3
 1354 042e A381     		strh	r3, [r4, #12]	@ unaligned
 1355              	.L74:
 690:../lwip-1.4.1/src/core/tcp_out.c ****   }
 691:../lwip-1.4.1/src/core/tcp_out.c **** 
 692:../lwip-1.4.1/src/core/tcp_out.c ****   return ERR_OK;
 1356              		.loc 1 692 0
 1357 0430 0023     		movs	r3, #0
 1358 0432 22E0     		b	.L78
 1359              	.L50:
 693:../lwip-1.4.1/src/core/tcp_out.c **** memerr:
 694:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->flags |= TF_NAGLEMEMERR;
 1360              		.loc 1 694 0
 1361 0434 FB68     		ldr	r3, [r7, #12]
 1362 0436 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1363 0438 63F07F03 		orn	r3, r3, #127
 1364 043c DAB2     		uxtb	r2, r3
 1365 043e FB68     		ldr	r3, [r7, #12]
 1366 0440 9A77     		strb	r2, [r3, #30]
 695:../lwip-1.4.1/src/core/tcp_out.c ****   TCP_STATS_INC(tcp.memerr);
 1367              		.loc 1 695 0
 1368 0442 104B     		ldr	r3, .L79
 1369 0444 D3F83831 		ldr	r3, [r3, #312]
 1370 0448 0133     		adds	r3, r3, #1
 1371 044a 0E4A     		ldr	r2, .L79
 1372 044c C2F83831 		str	r3, [r2, #312]
 696:../lwip-1.4.1/src/core/tcp_out.c **** 
 697:../lwip-1.4.1/src/core/tcp_out.c ****   if (concat_p != NULL) {
 1373              		.loc 1 697 0
 1374 0450 FB6C     		ldr	r3, [r7, #76]
 1375 0452 002B     		cmp	r3, #0
 1376 0454 02D0     		beq	.L75
 698:../lwip-1.4.1/src/core/tcp_out.c ****     pbuf_free(concat_p);
 1377              		.loc 1 698 0
 1378 0456 F86C     		ldr	r0, [r7, #76]
 1379 0458 FFF7FEFF 		bl	pbuf_free
 1380              	.L75:
 699:../lwip-1.4.1/src/core/tcp_out.c ****   }
 700:../lwip-1.4.1/src/core/tcp_out.c ****   if (queue != NULL) {
 1381              		.loc 1 700 0
 1382 045c FB6B     		ldr	r3, [r7, #60]
 1383 045e 002B     		cmp	r3, #0
 1384 0460 02D0     		beq	.L76
 701:../lwip-1.4.1/src/core/tcp_out.c ****     tcp_segs_free(queue);
 1385              		.loc 1 701 0
 1386 0462 F86B     		ldr	r0, [r7, #60]
 1387 0464 FFF7FEFF 		bl	tcp_segs_free
 1388              	.L76:
 702:../lwip-1.4.1/src/core/tcp_out.c ****   }
 703:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
 1389              		.loc 1 703 0
 1390 0468 FB68     		ldr	r3, [r7, #12]
 1391 046a B3F86830 		ldrh	r3, [r3, #104]
 1392 046e 002B     		cmp	r3, #0
 1393 0470 02D0     		beq	.L77
 704:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 1394              		.loc 1 704 0
 1395 0472 FB68     		ldr	r3, [r7, #12]
 1396 0474 1B6F     		ldr	r3, [r3, #112]
 1397 0476 002B     		cmp	r3, #0
 1398              	.L77:
 705:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->unsent != NULL);
 706:../lwip-1.4.1/src/core/tcp_out.c ****   }
 707:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_qu
 708:../lwip-1.4.1/src/core/tcp_out.c ****   return ERR_MEM;
 1399              		.loc 1 708 0
 1400 0478 FF23     		movs	r3, #255
 1401              	.L78:
 1402 047a 5BB2     		sxtb	r3, r3
 709:../lwip-1.4.1/src/core/tcp_out.c **** }
 1403              		.loc 1 709 0 discriminator 12
 1404 047c 1846     		mov	r0, r3
 1405 047e 5037     		adds	r7, r7, #80
 1406              		.cfi_def_cfa_offset 16
 1407 0480 BD46     		mov	sp, r7
 1408              		.cfi_def_cfa_register 13
 1409              		@ sp needed
 1410 0482 B0BD     		pop	{r4, r5, r7, pc}
 1411              	.L80:
 1412              		.align	2
 1413              	.L79:
 1414 0484 00000000 		.word	lwip_stats
 1415              		.cfi_endproc
 1416              	.LFE5:
 1418              		.section	.text.tcp_enqueue_flags,"ax",%progbits
 1419              		.align	2
 1420              		.global	tcp_enqueue_flags
 1421              		.thumb
 1422              		.thumb_func
 1424              	tcp_enqueue_flags:
 1425              	.LFB6:
 710:../lwip-1.4.1/src/core/tcp_out.c **** 
 711:../lwip-1.4.1/src/core/tcp_out.c **** /**
 712:../lwip-1.4.1/src/core/tcp_out.c ****  * Enqueue TCP options for transmission.
 713:../lwip-1.4.1/src/core/tcp_out.c ****  *
 714:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_connect(), tcp_listen_input(), and tcp_send_ctrl().
 715:../lwip-1.4.1/src/core/tcp_out.c ****  *
 716:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection.
 717:../lwip-1.4.1/src/core/tcp_out.c ****  * @param flags TCP header flags to set in the outgoing segment.
 718:../lwip-1.4.1/src/core/tcp_out.c ****  * @param optdata pointer to TCP options, or NULL.
 719:../lwip-1.4.1/src/core/tcp_out.c ****  * @param optlen length of TCP options in bytes.
 720:../lwip-1.4.1/src/core/tcp_out.c ****  */
 721:../lwip-1.4.1/src/core/tcp_out.c **** err_t
 722:../lwip-1.4.1/src/core/tcp_out.c **** tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
 723:../lwip-1.4.1/src/core/tcp_out.c **** {
 1426              		.loc 1 723 0
 1427              		.cfi_startproc
 1428              		@ args = 0, pretend = 0, frame = 32
 1429              		@ frame_needed = 1, uses_anonymous_args = 0
 1430 0000 90B5     		push	{r4, r7, lr}
 1431              		.cfi_def_cfa_offset 12
 1432              		.cfi_offset 4, -12
 1433              		.cfi_offset 7, -8
 1434              		.cfi_offset 14, -4
 1435 0002 8BB0     		sub	sp, sp, #44
 1436              		.cfi_def_cfa_offset 56
 1437 0004 02AF     		add	r7, sp, #8
 1438              		.cfi_def_cfa 7, 48
 1439 0006 7860     		str	r0, [r7, #4]
 1440 0008 0B46     		mov	r3, r1
 1441 000a FB70     		strb	r3, [r7, #3]
 724:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *p;
 725:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg *seg;
 726:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t optflags = 0;
 1442              		.loc 1 726 0
 1443 000c 0023     		movs	r3, #0
 1444 000e FB77     		strb	r3, [r7, #31]
 727:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t optlen = 0;
 1445              		.loc 1 727 0
 1446 0010 0023     		movs	r3, #0
 1447 0012 FB75     		strb	r3, [r7, #23]
 728:../lwip-1.4.1/src/core/tcp_out.c **** 
 729:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen)
 730:../lwip-1.4.1/src/core/tcp_out.c **** 
 731:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)
 732:../lwip-1.4.1/src/core/tcp_out.c ****               (flags & (TCP_SYN | TCP_FIN)) != 0);
 733:../lwip-1.4.1/src/core/tcp_out.c **** 
 734:../lwip-1.4.1/src/core/tcp_out.c ****   /* check for configured max queuelen and possible overflow */
 735:../lwip-1.4.1/src/core/tcp_out.c ****   if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 1448              		.loc 1 735 0
 1449 0014 7B68     		ldr	r3, [r7, #4]
 1450 0016 B3F86830 		ldrh	r3, [r3, #104]
 1451 001a 072B     		cmp	r3, #7
 1452 001c 06D8     		bhi	.L82
 1453              		.loc 1 735 0 is_stmt 0 discriminator 1
 1454 001e 7B68     		ldr	r3, [r7, #4]
 1455 0020 B3F86830 		ldrh	r3, [r3, #104]
 1456 0024 4FF6FC72 		movw	r2, #65532
 1457 0028 9342     		cmp	r3, r2
 1458 002a 0FD9     		bls	.L83
 1459              	.L82:
 736:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n
 737:../lwip-1.4.1/src/core/tcp_out.c ****                                        pcb->snd_queuelen, TCP_SND_QUEUELEN));
 738:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
 1460              		.loc 1 738 0 is_stmt 1
 1461 002c 654B     		ldr	r3, .L101
 1462 002e D3F83831 		ldr	r3, [r3, #312]
 1463 0032 0133     		adds	r3, r3, #1
 1464 0034 634A     		ldr	r2, .L101
 1465 0036 C2F83831 		str	r3, [r2, #312]
 739:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->flags |= TF_NAGLEMEMERR;
 1466              		.loc 1 739 0
 1467 003a 7B68     		ldr	r3, [r7, #4]
 1468 003c 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1469 003e 63F07F03 		orn	r3, r3, #127
 1470 0042 DAB2     		uxtb	r2, r3
 1471 0044 7B68     		ldr	r3, [r7, #4]
 1472 0046 9A77     		strb	r2, [r3, #30]
 740:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_MEM;
 1473              		.loc 1 740 0
 1474 0048 FF23     		movs	r3, #255
 1475 004a B5E0     		b	.L84
 1476              	.L83:
 741:../lwip-1.4.1/src/core/tcp_out.c ****   }
 742:../lwip-1.4.1/src/core/tcp_out.c **** 
 743:../lwip-1.4.1/src/core/tcp_out.c ****   if (flags & TCP_SYN) {
 1477              		.loc 1 743 0
 1478 004c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1479 004e 03F00203 		and	r3, r3, #2
 1480 0052 002B     		cmp	r3, #0
 1481 0054 01D0     		beq	.L85
 744:../lwip-1.4.1/src/core/tcp_out.c ****     optflags = TF_SEG_OPTS_MSS;
 1482              		.loc 1 744 0
 1483 0056 0123     		movs	r3, #1
 1484 0058 FB77     		strb	r3, [r7, #31]
 1485              	.L85:
 745:../lwip-1.4.1/src/core/tcp_out.c ****   }
 746:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
 747:../lwip-1.4.1/src/core/tcp_out.c ****   if ((pcb->flags & TF_TIMESTAMP)) {
 748:../lwip-1.4.1/src/core/tcp_out.c ****     optflags |= TF_SEG_OPTS_TS;
 749:../lwip-1.4.1/src/core/tcp_out.c ****   }
 750:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_TCP_TIMESTAMPS */
 751:../lwip-1.4.1/src/core/tcp_out.c ****   optlen = LWIP_TCP_OPT_LENGTH(optflags);
 1486              		.loc 1 751 0
 1487 005a FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 1488 005c 03F00103 		and	r3, r3, #1
 1489 0060 002B     		cmp	r3, #0
 1490 0062 01D0     		beq	.L86
 1491              		.loc 1 751 0 is_stmt 0 discriminator 1
 1492 0064 0422     		movs	r2, #4
 1493 0066 00E0     		b	.L87
 1494              	.L86:
 1495              		.loc 1 751 0 discriminator 2
 1496 0068 0022     		movs	r2, #0
 1497              	.L87:
 1498              		.loc 1 751 0 discriminator 4
 1499 006a FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 1500 006c 03F00203 		and	r3, r3, #2
 1501 0070 002B     		cmp	r3, #0
 1502 0072 01D0     		beq	.L88
 1503              		.loc 1 751 0 discriminator 5
 1504 0074 0C23     		movs	r3, #12
 1505 0076 00E0     		b	.L89
 1506              	.L88:
 1507              		.loc 1 751 0 discriminator 6
 1508 0078 0023     		movs	r3, #0
 1509              	.L89:
 1510              		.loc 1 751 0 discriminator 8
 1511 007a 1344     		add	r3, r3, r2
 1512 007c FB75     		strb	r3, [r7, #23]
 752:../lwip-1.4.1/src/core/tcp_out.c **** 
 753:../lwip-1.4.1/src/core/tcp_out.c ****   /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
 754:../lwip-1.4.1/src/core/tcp_out.c ****    * We need one available snd_buf byte to do that.
 755:../lwip-1.4.1/src/core/tcp_out.c ****    * This means we can't send FIN while snd_buf==0. A better fix would be to
 756:../lwip-1.4.1/src/core/tcp_out.c ****    * not include SYN and FIN sequence numbers in the snd_buf count. */
 757:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->snd_buf == 0) {
 1513              		.loc 1 757 0 is_stmt 1 discriminator 8
 1514 007e 7B68     		ldr	r3, [r7, #4]
 1515 0080 B3F86630 		ldrh	r3, [r3, #102]
 1516 0084 002B     		cmp	r3, #0
 1517 0086 08D1     		bne	.L90
 758:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
 759:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
 1518              		.loc 1 759 0
 1519 0088 4E4B     		ldr	r3, .L101
 1520 008a D3F83831 		ldr	r3, [r3, #312]
 1521 008e 0133     		adds	r3, r3, #1
 1522 0090 4C4A     		ldr	r2, .L101
 1523 0092 C2F83831 		str	r3, [r2, #312]
 760:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_MEM;
 1524              		.loc 1 760 0
 1525 0096 FF23     		movs	r3, #255
 1526 0098 8EE0     		b	.L84
 1527              	.L90:
 761:../lwip-1.4.1/src/core/tcp_out.c ****   }
 762:../lwip-1.4.1/src/core/tcp_out.c **** 
 763:../lwip-1.4.1/src/core/tcp_out.c ****   /* Allocate pbuf with room for TCP header + options */
 764:../lwip-1.4.1/src/core/tcp_out.c ****   if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 1528              		.loc 1 764 0
 1529 009a FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1530 009c 9BB2     		uxth	r3, r3
 1531 009e 0020     		movs	r0, #0
 1532 00a0 1946     		mov	r1, r3
 1533 00a2 0022     		movs	r2, #0
 1534 00a4 FFF7FEFF 		bl	pbuf_alloc
 1535 00a8 3861     		str	r0, [r7, #16]
 1536 00aa 3B69     		ldr	r3, [r7, #16]
 1537 00ac 002B     		cmp	r3, #0
 1538 00ae 0FD1     		bne	.L91
 765:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->flags |= TF_NAGLEMEMERR;
 1539              		.loc 1 765 0
 1540 00b0 7B68     		ldr	r3, [r7, #4]
 1541 00b2 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1542 00b4 63F07F03 		orn	r3, r3, #127
 1543 00b8 DAB2     		uxtb	r2, r3
 1544 00ba 7B68     		ldr	r3, [r7, #4]
 1545 00bc 9A77     		strb	r2, [r3, #30]
 766:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
 1546              		.loc 1 766 0
 1547 00be 414B     		ldr	r3, .L101
 1548 00c0 D3F83831 		ldr	r3, [r3, #312]
 1549 00c4 0133     		adds	r3, r3, #1
 1550 00c6 3F4A     		ldr	r2, .L101
 1551 00c8 C2F83831 		str	r3, [r2, #312]
 767:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_MEM;
 1552              		.loc 1 767 0
 1553 00cc FF23     		movs	r3, #255
 1554 00ce 73E0     		b	.L84
 1555              	.L91:
 768:../lwip-1.4.1/src/core/tcp_out.c ****   }
 769:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 770:../lwip-1.4.1/src/core/tcp_out.c ****               (p->len >= optlen));
 771:../lwip-1.4.1/src/core/tcp_out.c **** 
 772:../lwip-1.4.1/src/core/tcp_out.c ****   /* Allocate memory for tcp_seg, and fill in fields. */
 773:../lwip-1.4.1/src/core/tcp_out.c ****   if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 1556              		.loc 1 773 0
 1557 00d0 7B68     		ldr	r3, [r7, #4]
 1558 00d2 DC6D     		ldr	r4, [r3, #92]
 1559 00d4 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1560 00d6 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 1561 00d8 0093     		str	r3, [sp]
 1562 00da 7868     		ldr	r0, [r7, #4]
 1563 00dc 3969     		ldr	r1, [r7, #16]
 1564 00de 2346     		mov	r3, r4
 1565 00e0 FFF7FEFF 		bl	tcp_create_segment
 1566 00e4 F860     		str	r0, [r7, #12]
 1567 00e6 FB68     		ldr	r3, [r7, #12]
 1568 00e8 002B     		cmp	r3, #0
 1569 00ea 0FD1     		bne	.L92
 774:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->flags |= TF_NAGLEMEMERR;
 1570              		.loc 1 774 0
 1571 00ec 7B68     		ldr	r3, [r7, #4]
 1572 00ee 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1573 00f0 63F07F03 		orn	r3, r3, #127
 1574 00f4 DAB2     		uxtb	r2, r3
 1575 00f6 7B68     		ldr	r3, [r7, #4]
 1576 00f8 9A77     		strb	r2, [r3, #30]
 775:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
 1577              		.loc 1 775 0
 1578 00fa 324B     		ldr	r3, .L101
 1579 00fc D3F83831 		ldr	r3, [r3, #312]
 1580 0100 0133     		adds	r3, r3, #1
 1581 0102 304A     		ldr	r2, .L101
 1582 0104 C2F83831 		str	r3, [r2, #312]
 776:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_MEM;
 1583              		.loc 1 776 0
 1584 0108 FF23     		movs	r3, #255
 1585 010a 55E0     		b	.L84
 1586              	.L92:
 777:../lwip-1.4.1/src/core/tcp_out.c ****   }
 778:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
 779:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 780:../lwip-1.4.1/src/core/tcp_out.c **** 
 781:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
 782:../lwip-1.4.1/src/core/tcp_out.c ****               ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
 783:../lwip-1.4.1/src/core/tcp_out.c ****                ntohl(seg->tcphdr->seqno),
 784:../lwip-1.4.1/src/core/tcp_out.c ****                ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
 785:../lwip-1.4.1/src/core/tcp_out.c ****                (u16_t)flags));
 786:../lwip-1.4.1/src/core/tcp_out.c **** 
 787:../lwip-1.4.1/src/core/tcp_out.c ****   /* Now append seg to pcb->unsent queue */
 788:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->unsent == NULL) {
 1587              		.loc 1 788 0
 1588 010c 7B68     		ldr	r3, [r7, #4]
 1589 010e DB6E     		ldr	r3, [r3, #108]
 1590 0110 002B     		cmp	r3, #0
 1591 0112 03D1     		bne	.L93
 789:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->unsent = seg;
 1592              		.loc 1 789 0
 1593 0114 7B68     		ldr	r3, [r7, #4]
 1594 0116 FA68     		ldr	r2, [r7, #12]
 1595 0118 DA66     		str	r2, [r3, #108]
 1596 011a 0DE0     		b	.L94
 1597              	.L93:
 1598              	.LBB8:
 790:../lwip-1.4.1/src/core/tcp_out.c ****   } else {
 791:../lwip-1.4.1/src/core/tcp_out.c ****     struct tcp_seg *useg;
 792:../lwip-1.4.1/src/core/tcp_out.c ****     for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 1599              		.loc 1 792 0
 1600 011c 7B68     		ldr	r3, [r7, #4]
 1601 011e DB6E     		ldr	r3, [r3, #108]
 1602 0120 BB61     		str	r3, [r7, #24]
 1603 0122 02E0     		b	.L95
 1604              	.L96:
 1605              		.loc 1 792 0 is_stmt 0 discriminator 3
 1606 0124 BB69     		ldr	r3, [r7, #24]
 1607 0126 1B68     		ldr	r3, [r3]
 1608 0128 BB61     		str	r3, [r7, #24]
 1609              	.L95:
 1610              		.loc 1 792 0 discriminator 1
 1611 012a BB69     		ldr	r3, [r7, #24]
 1612 012c 1B68     		ldr	r3, [r3]
 1613 012e 002B     		cmp	r3, #0
 1614 0130 F8D1     		bne	.L96
 793:../lwip-1.4.1/src/core/tcp_out.c ****     useg->next = seg;
 1615              		.loc 1 793 0 is_stmt 1
 1616 0132 BB69     		ldr	r3, [r7, #24]
 1617 0134 FA68     		ldr	r2, [r7, #12]
 1618 0136 1A60     		str	r2, [r3]
 1619              	.L94:
 1620              	.LBE8:
 794:../lwip-1.4.1/src/core/tcp_out.c ****   }
 795:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
 796:../lwip-1.4.1/src/core/tcp_out.c ****   /* The new unsent tail has no space */
 797:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->unsent_oversize = 0;
 1621              		.loc 1 797 0
 1622 0138 7B68     		ldr	r3, [r7, #4]
 1623 013a 0022     		movs	r2, #0
 1624 013c A3F86A20 		strh	r2, [r3, #106]	@ movhi
 798:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 799:../lwip-1.4.1/src/core/tcp_out.c **** 
 800:../lwip-1.4.1/src/core/tcp_out.c ****   /* SYN and FIN bump the sequence number */
 801:../lwip-1.4.1/src/core/tcp_out.c ****   if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 1625              		.loc 1 801 0
 1626 0140 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1627 0142 03F00203 		and	r3, r3, #2
 1628 0146 002B     		cmp	r3, #0
 1629 0148 04D1     		bne	.L97
 1630              		.loc 1 801 0 is_stmt 0 discriminator 1
 1631 014a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1632 014c 03F00103 		and	r3, r3, #1
 1633 0150 002B     		cmp	r3, #0
 1634 0152 0CD0     		beq	.L98
 1635              	.L97:
 802:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->snd_lbb++;
 1636              		.loc 1 802 0 is_stmt 1
 1637 0154 7B68     		ldr	r3, [r7, #4]
 1638 0156 DB6D     		ldr	r3, [r3, #92]
 1639 0158 5A1C     		adds	r2, r3, #1
 1640 015a 7B68     		ldr	r3, [r7, #4]
 1641 015c DA65     		str	r2, [r3, #92]
 803:../lwip-1.4.1/src/core/tcp_out.c ****     /* optlen does not influence snd_buf */
 804:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->snd_buf--;
 1642              		.loc 1 804 0
 1643 015e 7B68     		ldr	r3, [r7, #4]
 1644 0160 B3F86630 		ldrh	r3, [r3, #102]
 1645 0164 013B     		subs	r3, r3, #1
 1646 0166 9AB2     		uxth	r2, r3
 1647 0168 7B68     		ldr	r3, [r7, #4]
 1648 016a A3F86620 		strh	r2, [r3, #102]	@ movhi
 1649              	.L98:
 805:../lwip-1.4.1/src/core/tcp_out.c ****   }
 806:../lwip-1.4.1/src/core/tcp_out.c ****   if (flags & TCP_FIN) {
 1650              		.loc 1 806 0
 1651 016e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1652 0170 03F00103 		and	r3, r3, #1
 1653 0174 002B     		cmp	r3, #0
 1654 0176 06D0     		beq	.L99
 807:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->flags |= TF_FIN;
 1655              		.loc 1 807 0
 1656 0178 7B68     		ldr	r3, [r7, #4]
 1657 017a 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1658 017c 43F02003 		orr	r3, r3, #32
 1659 0180 DAB2     		uxtb	r2, r3
 1660 0182 7B68     		ldr	r3, [r7, #4]
 1661 0184 9A77     		strb	r2, [r3, #30]
 1662              	.L99:
 808:../lwip-1.4.1/src/core/tcp_out.c ****   }
 809:../lwip-1.4.1/src/core/tcp_out.c **** 
 810:../lwip-1.4.1/src/core/tcp_out.c ****   /* update number of segments on the queues */
 811:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->snd_queuelen += pbuf_clen(seg->p);
 1663              		.loc 1 811 0
 1664 0186 FB68     		ldr	r3, [r7, #12]
 1665 0188 5B68     		ldr	r3, [r3, #4]
 1666 018a 1846     		mov	r0, r3
 1667 018c FFF7FEFF 		bl	pbuf_clen
 1668 0190 0346     		mov	r3, r0
 1669 0192 1946     		mov	r1, r3
 1670 0194 7B68     		ldr	r3, [r7, #4]
 1671 0196 B3F86820 		ldrh	r2, [r3, #104]
 1672 019a 8BB2     		uxth	r3, r1
 1673 019c 1344     		add	r3, r3, r2
 1674 019e 9AB2     		uxth	r2, r3
 1675 01a0 7B68     		ldr	r3, [r7, #4]
 1676 01a2 A3F86820 		strh	r2, [r3, #104]	@ movhi
 812:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen)
 813:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
 1677              		.loc 1 813 0
 1678 01a6 7B68     		ldr	r3, [r7, #4]
 1679 01a8 B3F86830 		ldrh	r3, [r3, #104]
 1680 01ac 002B     		cmp	r3, #0
 1681 01ae 02D0     		beq	.L100
 814:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 1682              		.loc 1 814 0
 1683 01b0 7B68     		ldr	r3, [r7, #4]
 1684 01b2 1B6F     		ldr	r3, [r3, #112]
 1685 01b4 002B     		cmp	r3, #0
 1686              	.L100:
 815:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->unacked != NULL || pcb->unsent != NULL);
 816:../lwip-1.4.1/src/core/tcp_out.c ****   }
 817:../lwip-1.4.1/src/core/tcp_out.c **** 
 818:../lwip-1.4.1/src/core/tcp_out.c ****   return ERR_OK;
 1687              		.loc 1 818 0
 1688 01b6 0023     		movs	r3, #0
 1689              	.L84:
 1690 01b8 5BB2     		sxtb	r3, r3
 819:../lwip-1.4.1/src/core/tcp_out.c **** }
 1691              		.loc 1 819 0
 1692 01ba 1846     		mov	r0, r3
 1693 01bc 2437     		adds	r7, r7, #36
 1694              		.cfi_def_cfa_offset 12
 1695 01be BD46     		mov	sp, r7
 1696              		.cfi_def_cfa_register 13
 1697              		@ sp needed
 1698 01c0 90BD     		pop	{r4, r7, pc}
 1699              	.L102:
 1700 01c2 00BF     		.align	2
 1701              	.L101:
 1702 01c4 00000000 		.word	lwip_stats
 1703              		.cfi_endproc
 1704              	.LFE6:
 1706              		.section	.text.tcp_send_empty_ack,"ax",%progbits
 1707              		.align	2
 1708              		.global	tcp_send_empty_ack
 1709              		.thumb
 1710              		.thumb_func
 1712              	tcp_send_empty_ack:
 1713              	.LFB7:
 820:../lwip-1.4.1/src/core/tcp_out.c **** 
 821:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
 822:../lwip-1.4.1/src/core/tcp_out.c **** /* Build a timestamp option (12 bytes long) at the specified options pointer)
 823:../lwip-1.4.1/src/core/tcp_out.c ****  *
 824:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb tcp_pcb
 825:../lwip-1.4.1/src/core/tcp_out.c ****  * @param opts option pointer where to store the timestamp option
 826:../lwip-1.4.1/src/core/tcp_out.c ****  */
 827:../lwip-1.4.1/src/core/tcp_out.c **** static void
 828:../lwip-1.4.1/src/core/tcp_out.c **** tcp_build_timestamp_option(struct tcp_pcb *pcb, u32_t *opts)
 829:../lwip-1.4.1/src/core/tcp_out.c **** {
 830:../lwip-1.4.1/src/core/tcp_out.c ****   /* Pad with two NOP options to make everything nicely aligned */
 831:../lwip-1.4.1/src/core/tcp_out.c ****   opts[0] = PP_HTONL(0x0101080A);
 832:../lwip-1.4.1/src/core/tcp_out.c ****   opts[1] = htonl(sys_now());
 833:../lwip-1.4.1/src/core/tcp_out.c ****   opts[2] = htonl(pcb->ts_recent);
 834:../lwip-1.4.1/src/core/tcp_out.c **** }
 835:../lwip-1.4.1/src/core/tcp_out.c **** #endif
 836:../lwip-1.4.1/src/core/tcp_out.c **** 
 837:../lwip-1.4.1/src/core/tcp_out.c **** /** Send an ACK without data.
 838:../lwip-1.4.1/src/core/tcp_out.c ****  *
 839:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection to send the ACK
 840:../lwip-1.4.1/src/core/tcp_out.c ****  */
 841:../lwip-1.4.1/src/core/tcp_out.c **** err_t
 842:../lwip-1.4.1/src/core/tcp_out.c **** tcp_send_empty_ack(struct tcp_pcb *pcb)
 843:../lwip-1.4.1/src/core/tcp_out.c **** {
 1714              		.loc 1 843 0
 1715              		.cfi_startproc
 1716              		@ args = 0, pretend = 0, frame = 24
 1717              		@ frame_needed = 1, uses_anonymous_args = 0
 1718 0000 90B5     		push	{r4, r7, lr}
 1719              		.cfi_def_cfa_offset 12
 1720              		.cfi_offset 4, -12
 1721              		.cfi_offset 7, -8
 1722              		.cfi_offset 14, -4
 1723 0002 89B0     		sub	sp, sp, #36
 1724              		.cfi_def_cfa_offset 48
 1725 0004 02AF     		add	r7, sp, #8
 1726              		.cfi_def_cfa 7, 40
 1727 0006 7860     		str	r0, [r7, #4]
 844:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *p;
 845:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
 846:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t optlen = 0;
 1728              		.loc 1 846 0
 1729 0008 0023     		movs	r3, #0
 1730 000a FB75     		strb	r3, [r7, #23]
 847:../lwip-1.4.1/src/core/tcp_out.c **** 
 848:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
 849:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->flags & TF_TIMESTAMP) {
 850:../lwip-1.4.1/src/core/tcp_out.c ****     optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
 851:../lwip-1.4.1/src/core/tcp_out.c ****   }
 852:../lwip-1.4.1/src/core/tcp_out.c **** #endif
 853:../lwip-1.4.1/src/core/tcp_out.c **** 
 854:../lwip-1.4.1/src/core/tcp_out.c ****   p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 1731              		.loc 1 854 0
 1732 000c FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1733 000e 9CB2     		uxth	r4, r3
 1734 0010 7B68     		ldr	r3, [r7, #4]
 1735 0012 1B6D     		ldr	r3, [r3, #80]
 1736 0014 1846     		mov	r0, r3
 1737 0016 FFF7FEFF 		bl	lwip_htonl
 1738 001a 0346     		mov	r3, r0
 1739 001c 7868     		ldr	r0, [r7, #4]
 1740 001e 2146     		mov	r1, r4
 1741 0020 0022     		movs	r2, #0
 1742 0022 FFF7FEFF 		bl	tcp_output_alloc_header
 1743 0026 3861     		str	r0, [r7, #16]
 855:../lwip-1.4.1/src/core/tcp_out.c ****   if (p == NULL) {
 1744              		.loc 1 855 0
 1745 0028 3B69     		ldr	r3, [r7, #16]
 1746 002a 002B     		cmp	r3, #0
 1747 002c 01D1     		bne	.L104
 856:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
 857:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_BUF;
 1748              		.loc 1 857 0
 1749 002e FE23     		movs	r3, #254
 1750 0030 1BE0     		b	.L105
 1751              	.L104:
 858:../lwip-1.4.1/src/core/tcp_out.c ****   }
 859:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr = (struct tcp_hdr *)p->payload;
 1752              		.loc 1 859 0
 1753 0032 3B69     		ldr	r3, [r7, #16]
 1754 0034 5B68     		ldr	r3, [r3, #4]
 1755 0036 FB60     		str	r3, [r7, #12]
 860:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
 861:../lwip-1.4.1/src/core/tcp_out.c ****               ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
 862:../lwip-1.4.1/src/core/tcp_out.c ****   /* remove ACK flags from the PCB, as we send an empty ACK now */
 863:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 1756              		.loc 1 863 0
 1757 0038 7B68     		ldr	r3, [r7, #4]
 1758 003a 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1759 003c 23F00303 		bic	r3, r3, #3
 1760 0040 DAB2     		uxtb	r2, r3
 1761 0042 7B68     		ldr	r3, [r7, #4]
 1762 0044 9A77     		strb	r2, [r3, #30]
 864:../lwip-1.4.1/src/core/tcp_out.c **** 
 865:../lwip-1.4.1/src/core/tcp_out.c ****   /* NB. MSS option is only sent on SYNs, so ignore it here */
 866:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
 867:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->ts_lastacksent = pcb->rcv_nxt;
 868:../lwip-1.4.1/src/core/tcp_out.c **** 
 869:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->flags & TF_TIMESTAMP) {
 870:../lwip-1.4.1/src/core/tcp_out.c ****     tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
 871:../lwip-1.4.1/src/core/tcp_out.c ****   }
 872:../lwip-1.4.1/src/core/tcp_out.c **** #endif 
 873:../lwip-1.4.1/src/core/tcp_out.c **** 
 874:../lwip-1.4.1/src/core/tcp_out.c **** #if CHECKSUM_GEN_TCP
 875:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 876:../lwip-1.4.1/src/core/tcp_out.c ****         IP_PROTO_TCP, p->tot_len);
 877:../lwip-1.4.1/src/core/tcp_out.c **** #endif
 878:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_NETIF_HWADDRHINT
 879:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 880:../lwip-1.4.1/src/core/tcp_out.c ****       IP_PROTO_TCP, &(pcb->addr_hint));
 881:../lwip-1.4.1/src/core/tcp_out.c **** #else /* LWIP_NETIF_HWADDRHINT*/
 882:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 1763              		.loc 1 882 0
 1764 0046 7968     		ldr	r1, [r7, #4]
 1765 0048 7B68     		ldr	r3, [r7, #4]
 1766 004a 1A1D     		adds	r2, r3, #4
 1767 004c 7B68     		ldr	r3, [r7, #4]
 1768 004e 9C7A     		ldrb	r4, [r3, #10]	@ zero_extendqisi2
 1769 0050 7B68     		ldr	r3, [r7, #4]
 1770 0052 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 1771 0054 0093     		str	r3, [sp]
 1772 0056 0623     		movs	r3, #6
 1773 0058 0193     		str	r3, [sp, #4]
 1774 005a 3869     		ldr	r0, [r7, #16]
 1775 005c 2346     		mov	r3, r4
 1776 005e FFF7FEFF 		bl	ip_output
 883:../lwip-1.4.1/src/core/tcp_out.c ****       IP_PROTO_TCP);
 884:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_NETIF_HWADDRHINT*/
 885:../lwip-1.4.1/src/core/tcp_out.c ****   pbuf_free(p);
 1777              		.loc 1 885 0
 1778 0062 3869     		ldr	r0, [r7, #16]
 1779 0064 FFF7FEFF 		bl	pbuf_free
 886:../lwip-1.4.1/src/core/tcp_out.c **** 
 887:../lwip-1.4.1/src/core/tcp_out.c ****   return ERR_OK;
 1780              		.loc 1 887 0
 1781 0068 0023     		movs	r3, #0
 1782              	.L105:
 1783 006a 5BB2     		sxtb	r3, r3
 888:../lwip-1.4.1/src/core/tcp_out.c **** }
 1784              		.loc 1 888 0
 1785 006c 1846     		mov	r0, r3
 1786 006e 1C37     		adds	r7, r7, #28
 1787              		.cfi_def_cfa_offset 12
 1788 0070 BD46     		mov	sp, r7
 1789              		.cfi_def_cfa_register 13
 1790              		@ sp needed
 1791 0072 90BD     		pop	{r4, r7, pc}
 1792              		.cfi_endproc
 1793              	.LFE7:
 1795              		.section	.text.tcp_output,"ax",%progbits
 1796              		.align	2
 1797              		.global	tcp_output
 1798              		.thumb
 1799              		.thumb_func
 1801              	tcp_output:
 1802              	.LFB8:
 889:../lwip-1.4.1/src/core/tcp_out.c **** 
 890:../lwip-1.4.1/src/core/tcp_out.c **** /**
 891:../lwip-1.4.1/src/core/tcp_out.c ****  * Find out what we can send and send it
 892:../lwip-1.4.1/src/core/tcp_out.c ****  *
 893:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection to send data
 894:../lwip-1.4.1/src/core/tcp_out.c ****  * @return ERR_OK if data has been sent or nothing to send
 895:../lwip-1.4.1/src/core/tcp_out.c ****  *         another err_t on error
 896:../lwip-1.4.1/src/core/tcp_out.c ****  */
 897:../lwip-1.4.1/src/core/tcp_out.c **** err_t
 898:../lwip-1.4.1/src/core/tcp_out.c **** tcp_output(struct tcp_pcb *pcb)
 899:../lwip-1.4.1/src/core/tcp_out.c **** {
 1803              		.loc 1 899 0
 1804              		.cfi_startproc
 1805              		@ args = 0, pretend = 0, frame = 32
 1806              		@ frame_needed = 1, uses_anonymous_args = 0
 1807 0000 B0B5     		push	{r4, r5, r7, lr}
 1808              		.cfi_def_cfa_offset 16
 1809              		.cfi_offset 4, -16
 1810              		.cfi_offset 5, -12
 1811              		.cfi_offset 7, -8
 1812              		.cfi_offset 14, -4
 1813 0002 88B0     		sub	sp, sp, #32
 1814              		.cfi_def_cfa_offset 48
 1815 0004 00AF     		add	r7, sp, #0
 1816              		.cfi_def_cfa_register 7
 1817 0006 7860     		str	r0, [r7, #4]
 900:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg *seg, *useg;
 901:../lwip-1.4.1/src/core/tcp_out.c ****   u32_t wnd, snd_nxt;
 902:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CWND_DEBUG
 903:../lwip-1.4.1/src/core/tcp_out.c ****   s16_t i = 0;
 904:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CWND_DEBUG */
 905:../lwip-1.4.1/src/core/tcp_out.c **** 
 906:../lwip-1.4.1/src/core/tcp_out.c ****   /* pcb->state LISTEN not allowed here */
 907:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 908:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->state != LISTEN);
 909:../lwip-1.4.1/src/core/tcp_out.c **** 
 910:../lwip-1.4.1/src/core/tcp_out.c ****   /* First, check if we are invoked by the TCP input processing
 911:../lwip-1.4.1/src/core/tcp_out.c ****      code. If so, we do not output anything. Instead, we rely on the
 912:../lwip-1.4.1/src/core/tcp_out.c ****      input processing code to call us when input processing is done
 913:../lwip-1.4.1/src/core/tcp_out.c ****      with. */
 914:../lwip-1.4.1/src/core/tcp_out.c ****   if (tcp_input_pcb == pcb) {
 1818              		.loc 1 914 0
 1819 0008 8E4B     		ldr	r3, .L133
 1820 000a 1A68     		ldr	r2, [r3]
 1821 000c 7B68     		ldr	r3, [r7, #4]
 1822 000e 9A42     		cmp	r2, r3
 1823 0010 01D1     		bne	.L107
 915:../lwip-1.4.1/src/core/tcp_out.c ****     return ERR_OK;
 1824              		.loc 1 915 0
 1825 0012 0023     		movs	r3, #0
 1826 0014 42E1     		b	.L108
 1827              	.L107:
 916:../lwip-1.4.1/src/core/tcp_out.c ****   }
 917:../lwip-1.4.1/src/core/tcp_out.c **** 
 918:../lwip-1.4.1/src/core/tcp_out.c ****   wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 1828              		.loc 1 918 0
 1829 0016 7B68     		ldr	r3, [r7, #4]
 1830 0018 B3F84C20 		ldrh	r2, [r3, #76]
 1831 001c 7B68     		ldr	r3, [r7, #4]
 1832 001e B3F86030 		ldrh	r3, [r3, #96]
 1833 0022 9342     		cmp	r3, r2
 1834 0024 28BF     		it	cs
 1835 0026 1346     		movcs	r3, r2
 1836 0028 9BB2     		uxth	r3, r3
 1837 002a 3B61     		str	r3, [r7, #16]
 919:../lwip-1.4.1/src/core/tcp_out.c **** 
 920:../lwip-1.4.1/src/core/tcp_out.c ****   seg = pcb->unsent;
 1838              		.loc 1 920 0
 1839 002c 7B68     		ldr	r3, [r7, #4]
 1840 002e DB6E     		ldr	r3, [r3, #108]
 1841 0030 FB61     		str	r3, [r7, #28]
 921:../lwip-1.4.1/src/core/tcp_out.c **** 
 922:../lwip-1.4.1/src/core/tcp_out.c ****   /* If the TF_ACK_NOW flag is set and no data will be sent (either
 923:../lwip-1.4.1/src/core/tcp_out.c ****    * because the ->unsent queue is empty or because the window does
 924:../lwip-1.4.1/src/core/tcp_out.c ****    * not allow it), construct an empty ACK segment and send it.
 925:../lwip-1.4.1/src/core/tcp_out.c ****    *
 926:../lwip-1.4.1/src/core/tcp_out.c ****    * If data is to be sent, we will just piggyback the ACK (see below).
 927:../lwip-1.4.1/src/core/tcp_out.c ****    */
 928:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->flags & TF_ACK_NOW &&
 1842              		.loc 1 928 0
 1843 0032 7B68     		ldr	r3, [r7, #4]
 1844 0034 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1845 0036 03F00203 		and	r3, r3, #2
 1846 003a 002B     		cmp	r3, #0
 1847 003c 17D0     		beq	.L109
 1848              		.loc 1 928 0 is_stmt 0 discriminator 1
 1849 003e FB69     		ldr	r3, [r7, #28]
 1850 0040 002B     		cmp	r3, #0
 1851 0042 0FD0     		beq	.L110
 929:../lwip-1.4.1/src/core/tcp_out.c ****      (seg == NULL ||
 930:../lwip-1.4.1/src/core/tcp_out.c ****       ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 1852              		.loc 1 930 0 is_stmt 1
 1853 0044 FB69     		ldr	r3, [r7, #28]
 1854 0046 1B69     		ldr	r3, [r3, #16]
 1855 0048 5B68     		ldr	r3, [r3, #4]	@ unaligned
 1856 004a 1846     		mov	r0, r3
 1857 004c FFF7FEFF 		bl	lwip_ntohl
 1858 0050 0246     		mov	r2, r0
 1859 0052 7B68     		ldr	r3, [r7, #4]
 1860 0054 9B6C     		ldr	r3, [r3, #72]
 1861 0056 D31A     		subs	r3, r2, r3
 1862 0058 FA69     		ldr	r2, [r7, #28]
 1863 005a 1289     		ldrh	r2, [r2, #8]
 1864 005c 1A44     		add	r2, r2, r3
 929:../lwip-1.4.1/src/core/tcp_out.c ****      (seg == NULL ||
 1865              		.loc 1 929 0
 1866 005e 3B69     		ldr	r3, [r7, #16]
 1867 0060 9A42     		cmp	r2, r3
 1868 0062 04D9     		bls	.L109
 1869              	.L110:
 931:../lwip-1.4.1/src/core/tcp_out.c ****      return tcp_send_empty_ack(pcb);
 1870              		.loc 1 931 0
 1871 0064 7868     		ldr	r0, [r7, #4]
 1872 0066 FFF7FEFF 		bl	tcp_send_empty_ack
 1873 006a 0346     		mov	r3, r0
 1874 006c 16E1     		b	.L108
 1875              	.L109:
 932:../lwip-1.4.1/src/core/tcp_out.c ****   }
 933:../lwip-1.4.1/src/core/tcp_out.c **** 
 934:../lwip-1.4.1/src/core/tcp_out.c ****   /* useg should point to last segment on unacked queue */
 935:../lwip-1.4.1/src/core/tcp_out.c ****   useg = pcb->unacked;
 1876              		.loc 1 935 0
 1877 006e 7B68     		ldr	r3, [r7, #4]
 1878 0070 1B6F     		ldr	r3, [r3, #112]
 1879 0072 BB61     		str	r3, [r7, #24]
 936:../lwip-1.4.1/src/core/tcp_out.c ****   if (useg != NULL) {
 1880              		.loc 1 936 0
 1881 0074 BB69     		ldr	r3, [r7, #24]
 1882 0076 002B     		cmp	r3, #0
 1883 0078 07D0     		beq	.L111
 937:../lwip-1.4.1/src/core/tcp_out.c ****     for (; useg->next != NULL; useg = useg->next);
 1884              		.loc 1 937 0
 1885 007a 02E0     		b	.L112
 1886              	.L113:
 1887              		.loc 1 937 0 is_stmt 0 discriminator 2
 1888 007c BB69     		ldr	r3, [r7, #24]
 1889 007e 1B68     		ldr	r3, [r3]
 1890 0080 BB61     		str	r3, [r7, #24]
 1891              	.L112:
 1892              		.loc 1 937 0 discriminator 1
 1893 0082 BB69     		ldr	r3, [r7, #24]
 1894 0084 1B68     		ldr	r3, [r3]
 1895 0086 002B     		cmp	r3, #0
 1896 0088 F8D1     		bne	.L113
 1897              	.L111:
 938:../lwip-1.4.1/src/core/tcp_out.c ****   }
 939:../lwip-1.4.1/src/core/tcp_out.c **** 
 940:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OUTPUT_DEBUG
 941:../lwip-1.4.1/src/core/tcp_out.c ****   if (seg == NULL) {
 942:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
 943:../lwip-1.4.1/src/core/tcp_out.c ****                                    (void*)pcb->unsent));
 944:../lwip-1.4.1/src/core/tcp_out.c ****   }
 945:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OUTPUT_DEBUG */
 946:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CWND_DEBUG
 947:../lwip-1.4.1/src/core/tcp_out.c ****   if (seg == NULL) {
 948:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
 949:../lwip-1.4.1/src/core/tcp_out.c ****                                  ", cwnd %"U16_F", wnd %"U32_F
 950:../lwip-1.4.1/src/core/tcp_out.c ****                                  ", seg == NULL, ack %"U32_F"\n",
 951:../lwip-1.4.1/src/core/tcp_out.c ****                                  pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
 952:../lwip-1.4.1/src/core/tcp_out.c ****   } else {
 953:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_CWND_DEBUG, 
 954:../lwip-1.4.1/src/core/tcp_out.c ****                 ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
 955:../lwip-1.4.1/src/core/tcp_out.c ****                  ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
 956:../lwip-1.4.1/src/core/tcp_out.c ****                  pcb->snd_wnd, pcb->cwnd, wnd,
 957:../lwip-1.4.1/src/core/tcp_out.c ****                  ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
 958:../lwip-1.4.1/src/core/tcp_out.c ****                  ntohl(seg->tcphdr->seqno), pcb->lastack));
 959:../lwip-1.4.1/src/core/tcp_out.c ****   }
 960:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CWND_DEBUG */
 961:../lwip-1.4.1/src/core/tcp_out.c ****   /* data available and window allows it to be sent? */
 962:../lwip-1.4.1/src/core/tcp_out.c ****   while (seg != NULL &&
 1898              		.loc 1 962 0 is_stmt 1
 1899 008a E3E0     		b	.L114
 1900              	.L131:
 963:../lwip-1.4.1/src/core/tcp_out.c ****          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 964:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("RST not expected here!", 
 1901              		.loc 1 964 0
 1902 008c FB69     		ldr	r3, [r7, #28]
 1903 008e 1B69     		ldr	r3, [r3, #16]
 1904 0090 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 1905 0092 9BB2     		uxth	r3, r3
 1906 0094 1846     		mov	r0, r3
 1907 0096 FFF7FEFF 		bl	lwip_ntohs
 965:../lwip-1.4.1/src/core/tcp_out.c ****                 (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
 966:../lwip-1.4.1/src/core/tcp_out.c ****     /* Stop sending if the nagle algorithm would prevent it
 967:../lwip-1.4.1/src/core/tcp_out.c ****      * Don't stop:
 968:../lwip-1.4.1/src/core/tcp_out.c ****      * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
 969:../lwip-1.4.1/src/core/tcp_out.c ****      * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
 970:../lwip-1.4.1/src/core/tcp_out.c ****      *   either seg->next != NULL or pcb->unacked == NULL;
 971:../lwip-1.4.1/src/core/tcp_out.c ****      *   RST is no sent using tcp_write/tcp_output.
 972:../lwip-1.4.1/src/core/tcp_out.c ****      */
 973:../lwip-1.4.1/src/core/tcp_out.c ****     if((tcp_do_output_nagle(pcb) == 0) &&
 1908              		.loc 1 973 0
 1909 009a 7B68     		ldr	r3, [r7, #4]
 1910 009c 1B6F     		ldr	r3, [r3, #112]
 1911 009e 002B     		cmp	r3, #0
 1912 00a0 1FD0     		beq	.L115
 1913              		.loc 1 973 0 is_stmt 0 discriminator 2
 1914 00a2 7B68     		ldr	r3, [r7, #4]
 1915 00a4 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1916 00a6 03F04403 		and	r3, r3, #68
 1917 00aa 002B     		cmp	r3, #0
 1918 00ac 19D1     		bne	.L115
 1919              		.loc 1 973 0 discriminator 4
 1920 00ae 7B68     		ldr	r3, [r7, #4]
 1921 00b0 DB6E     		ldr	r3, [r3, #108]
 1922 00b2 002B     		cmp	r3, #0
 1923 00b4 0BD0     		beq	.L116
 1924              		.loc 1 973 0 discriminator 5
 1925 00b6 7B68     		ldr	r3, [r7, #4]
 1926 00b8 DB6E     		ldr	r3, [r3, #108]
 1927 00ba 1B68     		ldr	r3, [r3]
 1928 00bc 002B     		cmp	r3, #0
 1929 00be 10D1     		bne	.L115
 1930              		.loc 1 973 0 discriminator 8
 1931 00c0 7B68     		ldr	r3, [r7, #4]
 1932 00c2 DB6E     		ldr	r3, [r3, #108]
 1933 00c4 1A89     		ldrh	r2, [r3, #8]
 1934 00c6 7B68     		ldr	r3, [r7, #4]
 1935 00c8 DB8E     		ldrh	r3, [r3, #54]
 1936 00ca 9A42     		cmp	r2, r3
 1937 00cc 09D2     		bcs	.L115
 1938              	.L116:
 1939              		.loc 1 973 0 discriminator 10
 1940 00ce 7B68     		ldr	r3, [r7, #4]
 1941 00d0 B3F86630 		ldrh	r3, [r3, #102]
 1942 00d4 002B     		cmp	r3, #0
 1943 00d6 04D0     		beq	.L115
 1944              		.loc 1 973 0 discriminator 12
 1945 00d8 7B68     		ldr	r3, [r7, #4]
 1946 00da B3F86830 		ldrh	r3, [r3, #104]
 1947 00de 072B     		cmp	r3, #7
 1948 00e0 01D9     		bls	.L117
 1949              	.L115:
 1950              		.loc 1 973 0 discriminator 13
 1951 00e2 0123     		movs	r3, #1
 1952 00e4 00E0     		b	.L118
 1953              	.L117:
 1954              		.loc 1 973 0 discriminator 14
 1955 00e6 0023     		movs	r3, #0
 1956              	.L118:
 1957              		.loc 1 973 0 discriminator 16
 1958 00e8 002B     		cmp	r3, #0
 1959 00ea 06D1     		bne	.L119
 974:../lwip-1.4.1/src/core/tcp_out.c ****       ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
 1960              		.loc 1 974 0 is_stmt 1 discriminator 17
 1961 00ec 7B68     		ldr	r3, [r7, #4]
 1962 00ee 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1963 00f0 03F0A003 		and	r3, r3, #160
 973:../lwip-1.4.1/src/core/tcp_out.c ****       ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
 1964              		.loc 1 973 0 discriminator 17
 1965 00f4 002B     		cmp	r3, #0
 1966 00f6 00D1     		bne	.L119
 975:../lwip-1.4.1/src/core/tcp_out.c ****       break;
 1967              		.loc 1 975 0
 1968 00f8 C0E0     		b	.L120
 1969              	.L119:
 976:../lwip-1.4.1/src/core/tcp_out.c ****     }
 977:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CWND_DEBUG
 978:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd
 979:../lwip-1.4.1/src/core/tcp_out.c ****                             pcb->snd_wnd, pcb->cwnd, wnd,
 980:../lwip-1.4.1/src/core/tcp_out.c ****                             ntohl(seg->tcphdr->seqno) + seg->len -
 981:../lwip-1.4.1/src/core/tcp_out.c ****                             pcb->lastack,
 982:../lwip-1.4.1/src/core/tcp_out.c ****                             ntohl(seg->tcphdr->seqno), pcb->lastack, i));
 983:../lwip-1.4.1/src/core/tcp_out.c ****     ++i;
 984:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CWND_DEBUG */
 985:../lwip-1.4.1/src/core/tcp_out.c **** 
 986:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->unsent = seg->next;
 1970              		.loc 1 986 0
 1971 00fa FB69     		ldr	r3, [r7, #28]
 1972 00fc 1A68     		ldr	r2, [r3]
 1973 00fe 7B68     		ldr	r3, [r7, #4]
 1974 0100 DA66     		str	r2, [r3, #108]
 987:../lwip-1.4.1/src/core/tcp_out.c **** 
 988:../lwip-1.4.1/src/core/tcp_out.c ****     if (pcb->state != SYN_SENT) {
 1975              		.loc 1 988 0
 1976 0102 7B68     		ldr	r3, [r7, #4]
 1977 0104 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 1978 0106 022B     		cmp	r3, #2
 1979 0108 13D0     		beq	.L121
 989:../lwip-1.4.1/src/core/tcp_out.c ****       TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 1980              		.loc 1 989 0
 1981 010a FB69     		ldr	r3, [r7, #28]
 1982 010c 1C69     		ldr	r4, [r3, #16]
 1983 010e FB69     		ldr	r3, [r7, #28]
 1984 0110 1B69     		ldr	r3, [r3, #16]
 1985 0112 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 1986 0114 9DB2     		uxth	r5, r3
 1987 0116 1020     		movs	r0, #16
 1988 0118 FFF7FEFF 		bl	lwip_htons
 1989 011c 0346     		mov	r3, r0
 1990 011e 2B43     		orrs	r3, r3, r5
 1991 0120 9BB2     		uxth	r3, r3
 1992 0122 A381     		strh	r3, [r4, #12]	@ unaligned
 990:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 1993              		.loc 1 990 0
 1994 0124 7B68     		ldr	r3, [r7, #4]
 1995 0126 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1996 0128 23F00303 		bic	r3, r3, #3
 1997 012c DAB2     		uxtb	r2, r3
 1998 012e 7B68     		ldr	r3, [r7, #4]
 1999 0130 9A77     		strb	r2, [r3, #30]
 2000              	.L121:
 991:../lwip-1.4.1/src/core/tcp_out.c ****     }
 992:../lwip-1.4.1/src/core/tcp_out.c **** 
 993:../lwip-1.4.1/src/core/tcp_out.c ****     tcp_output_segment(seg, pcb);
 2001              		.loc 1 993 0
 2002 0132 F869     		ldr	r0, [r7, #28]
 2003 0134 7968     		ldr	r1, [r7, #4]
 2004 0136 FFF7FEFF 		bl	tcp_output_segment
 994:../lwip-1.4.1/src/core/tcp_out.c ****     snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 2005              		.loc 1 994 0
 2006 013a FB69     		ldr	r3, [r7, #28]
 2007 013c 1B69     		ldr	r3, [r3, #16]
 2008 013e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2009 0140 1846     		mov	r0, r3
 2010 0142 FFF7FEFF 		bl	lwip_ntohl
 2011 0146 0446     		mov	r4, r0
 2012 0148 FB69     		ldr	r3, [r7, #28]
 2013 014a 1B89     		ldrh	r3, [r3, #8]
 2014 014c 1D46     		mov	r5, r3
 2015 014e FB69     		ldr	r3, [r7, #28]
 2016 0150 1B69     		ldr	r3, [r3, #16]
 2017 0152 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 2018 0154 9BB2     		uxth	r3, r3
 2019 0156 1846     		mov	r0, r3
 2020 0158 FFF7FEFF 		bl	lwip_ntohs
 2021 015c 0346     		mov	r3, r0
 2022 015e 03F00303 		and	r3, r3, #3
 2023 0162 002B     		cmp	r3, #0
 2024 0164 14BF     		ite	ne
 2025 0166 0123     		movne	r3, #1
 2026 0168 0023     		moveq	r3, #0
 2027 016a DBB2     		uxtb	r3, r3
 2028 016c 2B44     		add	r3, r3, r5
 2029 016e 2344     		add	r3, r3, r4
 2030 0170 FB60     		str	r3, [r7, #12]
 995:../lwip-1.4.1/src/core/tcp_out.c ****     if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 2031              		.loc 1 995 0
 2032 0172 7B68     		ldr	r3, [r7, #4]
 2033 0174 1A6D     		ldr	r2, [r3, #80]
 2034 0176 FB68     		ldr	r3, [r7, #12]
 2035 0178 D31A     		subs	r3, r2, r3
 2036 017a 002B     		cmp	r3, #0
 2037 017c 02DA     		bge	.L122
 996:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->snd_nxt = snd_nxt;
 2038              		.loc 1 996 0
 2039 017e 7B68     		ldr	r3, [r7, #4]
 2040 0180 FA68     		ldr	r2, [r7, #12]
 2041 0182 1A65     		str	r2, [r3, #80]
 2042              	.L122:
 997:../lwip-1.4.1/src/core/tcp_out.c ****     }
 998:../lwip-1.4.1/src/core/tcp_out.c ****     /* put segment on unacknowledged list if length > 0 */
 999:../lwip-1.4.1/src/core/tcp_out.c ****     if (TCP_TCPLEN(seg) > 0) {
 2043              		.loc 1 999 0
 2044 0184 FB69     		ldr	r3, [r7, #28]
 2045 0186 1B89     		ldrh	r3, [r3, #8]
 2046 0188 1C46     		mov	r4, r3
 2047 018a FB69     		ldr	r3, [r7, #28]
 2048 018c 1B69     		ldr	r3, [r3, #16]
 2049 018e 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 2050 0190 9BB2     		uxth	r3, r3
 2051 0192 1846     		mov	r0, r3
 2052 0194 FFF7FEFF 		bl	lwip_ntohs
 2053 0198 0346     		mov	r3, r0
 2054 019a 03F00303 		and	r3, r3, #3
 2055 019e 002B     		cmp	r3, #0
 2056 01a0 14BF     		ite	ne
 2057 01a2 0123     		movne	r3, #1
 2058 01a4 0023     		moveq	r3, #0
 2059 01a6 DBB2     		uxtb	r3, r3
 2060 01a8 2344     		add	r3, r3, r4
 2061 01aa 002B     		cmp	r3, #0
 2062 01ac 4CDD     		ble	.L123
1000:../lwip-1.4.1/src/core/tcp_out.c ****       seg->next = NULL;
 2063              		.loc 1 1000 0
 2064 01ae FB69     		ldr	r3, [r7, #28]
 2065 01b0 0022     		movs	r2, #0
 2066 01b2 1A60     		str	r2, [r3]
1001:../lwip-1.4.1/src/core/tcp_out.c ****       /* unacked list is empty? */
1002:../lwip-1.4.1/src/core/tcp_out.c ****       if (pcb->unacked == NULL) {
 2067              		.loc 1 1002 0
 2068 01b4 7B68     		ldr	r3, [r7, #4]
 2069 01b6 1B6F     		ldr	r3, [r3, #112]
 2070 01b8 002B     		cmp	r3, #0
 2071 01ba 05D1     		bne	.L124
1003:../lwip-1.4.1/src/core/tcp_out.c ****         pcb->unacked = seg;
 2072              		.loc 1 1003 0
 2073 01bc 7B68     		ldr	r3, [r7, #4]
 2074 01be FA69     		ldr	r2, [r7, #28]
 2075 01c0 1A67     		str	r2, [r3, #112]
1004:../lwip-1.4.1/src/core/tcp_out.c ****         useg = seg;
 2076              		.loc 1 1004 0
 2077 01c2 FB69     		ldr	r3, [r7, #28]
 2078 01c4 BB61     		str	r3, [r7, #24]
 2079 01c6 42E0     		b	.L130
 2080              	.L124:
1005:../lwip-1.4.1/src/core/tcp_out.c ****       /* unacked list is not empty? */
1006:../lwip-1.4.1/src/core/tcp_out.c ****       } else {
1007:../lwip-1.4.1/src/core/tcp_out.c ****         /* In the case of fast retransmit, the packet should not go to the tail
1008:../lwip-1.4.1/src/core/tcp_out.c ****          * of the unacked queue, but rather somewhere before it. We need to check for
1009:../lwip-1.4.1/src/core/tcp_out.c ****          * this case. -STJ Jul 27, 2004 */
1010:../lwip-1.4.1/src/core/tcp_out.c ****         if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 2081              		.loc 1 1010 0
 2082 01c8 FB69     		ldr	r3, [r7, #28]
 2083 01ca 1B69     		ldr	r3, [r3, #16]
 2084 01cc 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2085 01ce 1846     		mov	r0, r3
 2086 01d0 FFF7FEFF 		bl	lwip_ntohl
 2087 01d4 0446     		mov	r4, r0
 2088 01d6 BB69     		ldr	r3, [r7, #24]
 2089 01d8 1B69     		ldr	r3, [r3, #16]
 2090 01da 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2091 01dc 1846     		mov	r0, r3
 2092 01de FFF7FEFF 		bl	lwip_ntohl
 2093 01e2 0346     		mov	r3, r0
 2094 01e4 E31A     		subs	r3, r4, r3
 2095 01e6 002B     		cmp	r3, #0
 2096 01e8 24DA     		bge	.L126
 2097              	.LBB9:
1011:../lwip-1.4.1/src/core/tcp_out.c ****           /* add segment to before tail of unacked list, keeping the list sorted */
1012:../lwip-1.4.1/src/core/tcp_out.c ****           struct tcp_seg **cur_seg = &(pcb->unacked);
 2098              		.loc 1 1012 0
 2099 01ea 7B68     		ldr	r3, [r7, #4]
 2100 01ec 7033     		adds	r3, r3, #112
 2101 01ee 7B61     		str	r3, [r7, #20]
1013:../lwip-1.4.1/src/core/tcp_out.c ****           while (*cur_seg &&
 2102              		.loc 1 1013 0
 2103 01f0 02E0     		b	.L127
 2104              	.L129:
1014:../lwip-1.4.1/src/core/tcp_out.c ****             TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
1015:../lwip-1.4.1/src/core/tcp_out.c ****               cur_seg = &((*cur_seg)->next );
 2105              		.loc 1 1015 0
 2106 01f2 7B69     		ldr	r3, [r7, #20]
 2107 01f4 1B68     		ldr	r3, [r3]
 2108 01f6 7B61     		str	r3, [r7, #20]
 2109              	.L127:
1013:../lwip-1.4.1/src/core/tcp_out.c ****           while (*cur_seg &&
 2110              		.loc 1 1013 0
 2111 01f8 7B69     		ldr	r3, [r7, #20]
 2112 01fa 1B68     		ldr	r3, [r3]
 2113 01fc 002B     		cmp	r3, #0
 2114 01fe 11D0     		beq	.L128
1014:../lwip-1.4.1/src/core/tcp_out.c ****             TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 2115              		.loc 1 1014 0 discriminator 1
 2116 0200 7B69     		ldr	r3, [r7, #20]
 2117 0202 1B68     		ldr	r3, [r3]
 2118 0204 1B69     		ldr	r3, [r3, #16]
 2119 0206 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2120 0208 1846     		mov	r0, r3
 2121 020a FFF7FEFF 		bl	lwip_ntohl
 2122 020e 0446     		mov	r4, r0
 2123 0210 FB69     		ldr	r3, [r7, #28]
 2124 0212 1B69     		ldr	r3, [r3, #16]
 2125 0214 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2126 0216 1846     		mov	r0, r3
 2127 0218 FFF7FEFF 		bl	lwip_ntohl
 2128 021c 0346     		mov	r3, r0
 2129 021e E31A     		subs	r3, r4, r3
1013:../lwip-1.4.1/src/core/tcp_out.c ****           while (*cur_seg &&
 2130              		.loc 1 1013 0 discriminator 1
 2131 0220 002B     		cmp	r3, #0
 2132 0222 E6DB     		blt	.L129
 2133              	.L128:
1016:../lwip-1.4.1/src/core/tcp_out.c ****           }
1017:../lwip-1.4.1/src/core/tcp_out.c ****           seg->next = (*cur_seg);
 2134              		.loc 1 1017 0
 2135 0224 7B69     		ldr	r3, [r7, #20]
 2136 0226 1A68     		ldr	r2, [r3]
 2137 0228 FB69     		ldr	r3, [r7, #28]
 2138 022a 1A60     		str	r2, [r3]
1018:../lwip-1.4.1/src/core/tcp_out.c ****           (*cur_seg) = seg;
 2139              		.loc 1 1018 0
 2140 022c 7B69     		ldr	r3, [r7, #20]
 2141 022e FA69     		ldr	r2, [r7, #28]
 2142 0230 1A60     		str	r2, [r3]
 2143              	.LBE9:
 2144 0232 0CE0     		b	.L130
 2145              	.L126:
1019:../lwip-1.4.1/src/core/tcp_out.c ****         } else {
1020:../lwip-1.4.1/src/core/tcp_out.c ****           /* add segment to tail of unacked list */
1021:../lwip-1.4.1/src/core/tcp_out.c ****           useg->next = seg;
 2146              		.loc 1 1021 0
 2147 0234 BB69     		ldr	r3, [r7, #24]
 2148 0236 FA69     		ldr	r2, [r7, #28]
 2149 0238 1A60     		str	r2, [r3]
1022:../lwip-1.4.1/src/core/tcp_out.c ****           useg = useg->next;
 2150              		.loc 1 1022 0
 2151 023a BB69     		ldr	r3, [r7, #24]
 2152 023c 1B68     		ldr	r3, [r3]
 2153 023e BB61     		str	r3, [r7, #24]
 2154 0240 05E0     		b	.L130
 2155              	.L134:
 2156 0242 00BF     		.align	2
 2157              	.L133:
 2158 0244 00000000 		.word	tcp_input_pcb
 2159              	.L123:
1023:../lwip-1.4.1/src/core/tcp_out.c ****         }
1024:../lwip-1.4.1/src/core/tcp_out.c ****       }
1025:../lwip-1.4.1/src/core/tcp_out.c ****     /* do not queue empty segments on the unacked list */
1026:../lwip-1.4.1/src/core/tcp_out.c ****     } else {
1027:../lwip-1.4.1/src/core/tcp_out.c ****       tcp_seg_free(seg);
 2160              		.loc 1 1027 0
 2161 0248 F869     		ldr	r0, [r7, #28]
 2162 024a FFF7FEFF 		bl	tcp_seg_free
 2163              	.L130:
1028:../lwip-1.4.1/src/core/tcp_out.c ****     }
1029:../lwip-1.4.1/src/core/tcp_out.c ****     seg = pcb->unsent;
 2164              		.loc 1 1029 0
 2165 024e 7B68     		ldr	r3, [r7, #4]
 2166 0250 DB6E     		ldr	r3, [r3, #108]
 2167 0252 FB61     		str	r3, [r7, #28]
 2168              	.L114:
 962:../lwip-1.4.1/src/core/tcp_out.c ****          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 2169              		.loc 1 962 0
 2170 0254 FB69     		ldr	r3, [r7, #28]
 2171 0256 002B     		cmp	r3, #0
 2172 0258 10D0     		beq	.L120
 963:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_ASSERT("RST not expected here!", 
 2173              		.loc 1 963 0 discriminator 1
 2174 025a FB69     		ldr	r3, [r7, #28]
 2175 025c 1B69     		ldr	r3, [r3, #16]
 2176 025e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2177 0260 1846     		mov	r0, r3
 2178 0262 FFF7FEFF 		bl	lwip_ntohl
 2179 0266 0246     		mov	r2, r0
 2180 0268 7B68     		ldr	r3, [r7, #4]
 2181 026a 9B6C     		ldr	r3, [r3, #72]
 2182 026c D31A     		subs	r3, r2, r3
 2183 026e FA69     		ldr	r2, [r7, #28]
 2184 0270 1289     		ldrh	r2, [r2, #8]
 2185 0272 1A44     		add	r2, r2, r3
 962:../lwip-1.4.1/src/core/tcp_out.c ****          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 2186              		.loc 1 962 0 discriminator 1
 2187 0274 3B69     		ldr	r3, [r7, #16]
 2188 0276 9A42     		cmp	r2, r3
 2189 0278 7FF608AF 		bls	.L131
 2190              	.L120:
1030:../lwip-1.4.1/src/core/tcp_out.c ****   }
1031:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
1032:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->unsent == NULL) {
 2191              		.loc 1 1032 0
 2192 027c 7B68     		ldr	r3, [r7, #4]
 2193 027e DB6E     		ldr	r3, [r3, #108]
 2194 0280 002B     		cmp	r3, #0
 2195 0282 03D1     		bne	.L132
1033:../lwip-1.4.1/src/core/tcp_out.c ****     /* last unsent has been removed, reset unsent_oversize */
1034:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->unsent_oversize = 0;
 2196              		.loc 1 1034 0
 2197 0284 7B68     		ldr	r3, [r7, #4]
 2198 0286 0022     		movs	r2, #0
 2199 0288 A3F86A20 		strh	r2, [r3, #106]	@ movhi
 2200              	.L132:
1035:../lwip-1.4.1/src/core/tcp_out.c ****   }
1036:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
1037:../lwip-1.4.1/src/core/tcp_out.c **** 
1038:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->flags &= ~TF_NAGLEMEMERR;
 2201              		.loc 1 1038 0
 2202 028c 7B68     		ldr	r3, [r7, #4]
 2203 028e 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 2204 0290 03F07F03 		and	r3, r3, #127
 2205 0294 DAB2     		uxtb	r2, r3
 2206 0296 7B68     		ldr	r3, [r7, #4]
 2207 0298 9A77     		strb	r2, [r3, #30]
1039:../lwip-1.4.1/src/core/tcp_out.c ****   return ERR_OK;
 2208              		.loc 1 1039 0
 2209 029a 0023     		movs	r3, #0
 2210              	.L108:
 2211 029c 5BB2     		sxtb	r3, r3
1040:../lwip-1.4.1/src/core/tcp_out.c **** }
 2212              		.loc 1 1040 0
 2213 029e 1846     		mov	r0, r3
 2214 02a0 2037     		adds	r7, r7, #32
 2215              		.cfi_def_cfa_offset 16
 2216 02a2 BD46     		mov	sp, r7
 2217              		.cfi_def_cfa_register 13
 2218              		@ sp needed
 2219 02a4 B0BD     		pop	{r4, r5, r7, pc}
 2220              		.cfi_endproc
 2221              	.LFE8:
 2223 02a6 00BF     		.section	.text.tcp_output_segment,"ax",%progbits
 2224              		.align	2
 2225              		.thumb
 2226              		.thumb_func
 2228              	tcp_output_segment:
 2229              	.LFB9:
1041:../lwip-1.4.1/src/core/tcp_out.c **** 
1042:../lwip-1.4.1/src/core/tcp_out.c **** /**
1043:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_output() to actually send a TCP segment over IP.
1044:../lwip-1.4.1/src/core/tcp_out.c ****  *
1045:../lwip-1.4.1/src/core/tcp_out.c ****  * @param seg the tcp_seg to send
1046:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp_pcb for the TCP connection used to send the segment
1047:../lwip-1.4.1/src/core/tcp_out.c ****  */
1048:../lwip-1.4.1/src/core/tcp_out.c **** static void
1049:../lwip-1.4.1/src/core/tcp_out.c **** tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
1050:../lwip-1.4.1/src/core/tcp_out.c **** {
 2230              		.loc 1 1050 0
 2231              		.cfi_startproc
 2232              		@ args = 0, pretend = 0, frame = 24
 2233              		@ frame_needed = 1, uses_anonymous_args = 0
 2234 0000 90B5     		push	{r4, r7, lr}
 2235              		.cfi_def_cfa_offset 12
 2236              		.cfi_offset 4, -12
 2237              		.cfi_offset 7, -8
 2238              		.cfi_offset 14, -4
 2239 0002 89B0     		sub	sp, sp, #36
 2240              		.cfi_def_cfa_offset 48
 2241 0004 02AF     		add	r7, sp, #8
 2242              		.cfi_def_cfa 7, 40
 2243 0006 7860     		str	r0, [r7, #4]
 2244 0008 3960     		str	r1, [r7]
1051:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t len;
1052:../lwip-1.4.1/src/core/tcp_out.c ****   struct netif *netif;
1053:../lwip-1.4.1/src/core/tcp_out.c ****   u32_t *opts;
1054:../lwip-1.4.1/src/core/tcp_out.c **** 
1055:../lwip-1.4.1/src/core/tcp_out.c ****   /** @bug Exclude retransmitted segments from this count. */
1056:../lwip-1.4.1/src/core/tcp_out.c ****   snmp_inc_tcpoutsegs();
1057:../lwip-1.4.1/src/core/tcp_out.c **** 
1058:../lwip-1.4.1/src/core/tcp_out.c ****   /* The TCP header has already been constructed, but the ackno and
1059:../lwip-1.4.1/src/core/tcp_out.c ****    wnd fields remain. */
1060:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 2245              		.loc 1 1060 0
 2246 000a 7B68     		ldr	r3, [r7, #4]
 2247 000c 1C69     		ldr	r4, [r3, #16]
 2248 000e 3B68     		ldr	r3, [r7]
 2249 0010 9B6A     		ldr	r3, [r3, #40]
 2250 0012 1846     		mov	r0, r3
 2251 0014 FFF7FEFF 		bl	lwip_htonl
 2252 0018 0346     		mov	r3, r0
 2253 001a A360     		str	r3, [r4, #8]	@ unaligned
1061:../lwip-1.4.1/src/core/tcp_out.c **** 
1062:../lwip-1.4.1/src/core/tcp_out.c ****   /* advertise our receive window size in this TCP segment */
1063:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 2254              		.loc 1 1063 0
 2255 001c 7B68     		ldr	r3, [r7, #4]
 2256 001e 1C69     		ldr	r4, [r3, #16]
 2257 0020 3B68     		ldr	r3, [r7]
 2258 0022 DB8D     		ldrh	r3, [r3, #46]
 2259 0024 1846     		mov	r0, r3
 2260 0026 FFF7FEFF 		bl	lwip_htons
 2261 002a 0346     		mov	r3, r0
 2262 002c E381     		strh	r3, [r4, #14]	@ unaligned
1064:../lwip-1.4.1/src/core/tcp_out.c **** 
1065:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 2263              		.loc 1 1065 0
 2264 002e 3B68     		ldr	r3, [r7]
 2265 0030 9B6A     		ldr	r3, [r3, #40]
 2266 0032 3A68     		ldr	r2, [r7]
 2267 0034 D28D     		ldrh	r2, [r2, #46]
 2268 0036 1A44     		add	r2, r2, r3
 2269 0038 3B68     		ldr	r3, [r7]
 2270 003a 1A63     		str	r2, [r3, #48]
1066:../lwip-1.4.1/src/core/tcp_out.c **** 
1067:../lwip-1.4.1/src/core/tcp_out.c ****   /* Add any requested options.  NB MSS option is only set on SYN
1068:../lwip-1.4.1/src/core/tcp_out.c ****      packets, so ignore it here */
1069:../lwip-1.4.1/src/core/tcp_out.c ****   opts = (u32_t *)(void *)(seg->tcphdr + 1);
 2271              		.loc 1 1069 0
 2272 003c 7B68     		ldr	r3, [r7, #4]
 2273 003e 1B69     		ldr	r3, [r3, #16]
 2274 0040 1433     		adds	r3, r3, #20
 2275 0042 7B61     		str	r3, [r7, #20]
1070:../lwip-1.4.1/src/core/tcp_out.c ****   if (seg->flags & TF_SEG_OPTS_MSS) {
 2276              		.loc 1 1070 0
 2277 0044 7B68     		ldr	r3, [r7, #4]
 2278 0046 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2279 0048 03F00103 		and	r3, r3, #1
 2280 004c 002B     		cmp	r3, #0
 2281 004e 14D0     		beq	.L136
 2282              	.LBB10:
1071:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t mss;
1072:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CALCULATE_EFF_SEND_MSS
1073:../lwip-1.4.1/src/core/tcp_out.c ****     mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 2283              		.loc 1 1073 0
 2284 0050 3B68     		ldr	r3, [r7]
 2285 0052 0433     		adds	r3, r3, #4
 2286 0054 40F2B450 		movw	r0, #1460
 2287 0058 1946     		mov	r1, r3
 2288 005a FFF7FEFF 		bl	tcp_eff_send_mss
 2289 005e 0346     		mov	r3, r0
 2290 0060 7B82     		strh	r3, [r7, #18]	@ movhi
1074:../lwip-1.4.1/src/core/tcp_out.c **** #else /* TCP_CALCULATE_EFF_SEND_MSS */
1075:../lwip-1.4.1/src/core/tcp_out.c ****     mss = TCP_MSS;
1076:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
1077:../lwip-1.4.1/src/core/tcp_out.c ****     *opts = TCP_BUILD_MSS_OPTION(mss);
 2291              		.loc 1 1077 0
 2292 0062 7B8A     		ldrh	r3, [r7, #18]
 2293 0064 43F00173 		orr	r3, r3, #33816576
 2294 0068 1846     		mov	r0, r3
 2295 006a FFF7FEFF 		bl	lwip_htonl
 2296 006e 0246     		mov	r2, r0
 2297 0070 7B69     		ldr	r3, [r7, #20]
 2298 0072 1A60     		str	r2, [r3]
1078:../lwip-1.4.1/src/core/tcp_out.c ****     opts += 1;
 2299              		.loc 1 1078 0
 2300 0074 7B69     		ldr	r3, [r7, #20]
 2301 0076 0433     		adds	r3, r3, #4
 2302 0078 7B61     		str	r3, [r7, #20]
 2303              	.L136:
 2304              	.LBE10:
1079:../lwip-1.4.1/src/core/tcp_out.c ****   }
1080:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
1081:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->ts_lastacksent = pcb->rcv_nxt;
1082:../lwip-1.4.1/src/core/tcp_out.c **** 
1083:../lwip-1.4.1/src/core/tcp_out.c ****   if (seg->flags & TF_SEG_OPTS_TS) {
1084:../lwip-1.4.1/src/core/tcp_out.c ****     tcp_build_timestamp_option(pcb, opts);
1085:../lwip-1.4.1/src/core/tcp_out.c ****     opts += 3;
1086:../lwip-1.4.1/src/core/tcp_out.c ****   }
1087:../lwip-1.4.1/src/core/tcp_out.c **** #endif
1088:../lwip-1.4.1/src/core/tcp_out.c **** 
1089:../lwip-1.4.1/src/core/tcp_out.c ****   /* Set retransmission timer running if it is not currently enabled 
1090:../lwip-1.4.1/src/core/tcp_out.c ****      This must be set before checking the route. */
1091:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->rtime == -1) {
 2305              		.loc 1 1091 0
 2306 007a 3B68     		ldr	r3, [r7]
 2307 007c 9B8E     		ldrh	r3, [r3, #52]
 2308 007e 1BB2     		sxth	r3, r3
 2309 0080 B3F1FF3F 		cmp	r3, #-1
 2310 0084 02D1     		bne	.L137
1092:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->rtime = 0;
 2311              		.loc 1 1092 0
 2312 0086 3B68     		ldr	r3, [r7]
 2313 0088 0022     		movs	r2, #0
 2314 008a 9A86     		strh	r2, [r3, #52]	@ movhi
 2315              	.L137:
1093:../lwip-1.4.1/src/core/tcp_out.c ****   }
1094:../lwip-1.4.1/src/core/tcp_out.c **** 
1095:../lwip-1.4.1/src/core/tcp_out.c ****   /* If we don't have a local IP address, we get one by
1096:../lwip-1.4.1/src/core/tcp_out.c ****      calling ip_route(). */
1097:../lwip-1.4.1/src/core/tcp_out.c ****   if (ip_addr_isany(&(pcb->local_ip))) {
 2316              		.loc 1 1097 0
 2317 008c 3B68     		ldr	r3, [r7]
 2318 008e 002B     		cmp	r3, #0
 2319 0090 03D0     		beq	.L138
 2320              		.loc 1 1097 0 is_stmt 0 discriminator 1
 2321 0092 3B68     		ldr	r3, [r7]
 2322 0094 1B68     		ldr	r3, [r3]
 2323 0096 002B     		cmp	r3, #0
 2324 0098 0DD1     		bne	.L139
 2325              	.L138:
1098:../lwip-1.4.1/src/core/tcp_out.c ****     netif = ip_route(&(pcb->remote_ip));
 2326              		.loc 1 1098 0 is_stmt 1
 2327 009a 3B68     		ldr	r3, [r7]
 2328 009c 0433     		adds	r3, r3, #4
 2329 009e 1846     		mov	r0, r3
 2330 00a0 FFF7FEFF 		bl	ip_route
 2331 00a4 F860     		str	r0, [r7, #12]
1099:../lwip-1.4.1/src/core/tcp_out.c ****     if (netif == NULL) {
 2332              		.loc 1 1099 0
 2333 00a6 FB68     		ldr	r3, [r7, #12]
 2334 00a8 002B     		cmp	r3, #0
 2335 00aa 00D1     		bne	.L140
1100:../lwip-1.4.1/src/core/tcp_out.c ****       return;
 2336              		.loc 1 1100 0
 2337 00ac 4FE0     		b	.L135
 2338              	.L140:
1101:../lwip-1.4.1/src/core/tcp_out.c ****     }
1102:../lwip-1.4.1/src/core/tcp_out.c ****     ip_addr_copy(pcb->local_ip, netif->ip_addr);
 2339              		.loc 1 1102 0
 2340 00ae FB68     		ldr	r3, [r7, #12]
 2341 00b0 5A68     		ldr	r2, [r3, #4]
 2342 00b2 3B68     		ldr	r3, [r7]
 2343 00b4 1A60     		str	r2, [r3]
 2344              	.L139:
1103:../lwip-1.4.1/src/core/tcp_out.c ****   }
1104:../lwip-1.4.1/src/core/tcp_out.c **** 
1105:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->rttest == 0) {
 2345              		.loc 1 1105 0
 2346 00b6 3B68     		ldr	r3, [r7]
 2347 00b8 9B6B     		ldr	r3, [r3, #56]
 2348 00ba 002B     		cmp	r3, #0
 2349 00bc 0CD1     		bne	.L142
1106:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->rttest = tcp_ticks;
 2350              		.loc 1 1106 0
 2351 00be 254B     		ldr	r3, .L143
 2352 00c0 1A68     		ldr	r2, [r3]
 2353 00c2 3B68     		ldr	r3, [r7]
 2354 00c4 9A63     		str	r2, [r3, #56]
1107:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->rtseq = ntohl(seg->tcphdr->seqno);
 2355              		.loc 1 1107 0
 2356 00c6 7B68     		ldr	r3, [r7, #4]
 2357 00c8 1B69     		ldr	r3, [r3, #16]
 2358 00ca 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2359 00cc 1846     		mov	r0, r3
 2360 00ce FFF7FEFF 		bl	lwip_ntohl
 2361 00d2 0246     		mov	r2, r0
 2362 00d4 3B68     		ldr	r3, [r7]
 2363 00d6 DA63     		str	r2, [r3, #60]
 2364              	.L142:
1108:../lwip-1.4.1/src/core/tcp_out.c **** 
1109:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
1110:../lwip-1.4.1/src/core/tcp_out.c ****   }
1111:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
1112:../lwip-1.4.1/src/core/tcp_out.c ****           htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
1113:../lwip-1.4.1/src/core/tcp_out.c ****           seg->len));
1114:../lwip-1.4.1/src/core/tcp_out.c **** 
1115:../lwip-1.4.1/src/core/tcp_out.c ****   len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 2365              		.loc 1 1115 0
 2366 00d8 7B68     		ldr	r3, [r7, #4]
 2367 00da 1B69     		ldr	r3, [r3, #16]
 2368 00dc 1A46     		mov	r2, r3
 2369 00de 7B68     		ldr	r3, [r7, #4]
 2370 00e0 5B68     		ldr	r3, [r3, #4]
 2371 00e2 5B68     		ldr	r3, [r3, #4]
 2372 00e4 D31A     		subs	r3, r2, r3
 2373 00e6 7B81     		strh	r3, [r7, #10]	@ movhi
1116:../lwip-1.4.1/src/core/tcp_out.c **** 
1117:../lwip-1.4.1/src/core/tcp_out.c ****   seg->p->len -= len;
 2374              		.loc 1 1117 0
 2375 00e8 7B68     		ldr	r3, [r7, #4]
 2376 00ea 5B68     		ldr	r3, [r3, #4]
 2377 00ec 7A68     		ldr	r2, [r7, #4]
 2378 00ee 5268     		ldr	r2, [r2, #4]
 2379 00f0 5189     		ldrh	r1, [r2, #10]
 2380 00f2 7A89     		ldrh	r2, [r7, #10]	@ movhi
 2381 00f4 8A1A     		subs	r2, r1, r2
 2382 00f6 92B2     		uxth	r2, r2
 2383 00f8 5A81     		strh	r2, [r3, #10]	@ movhi
1118:../lwip-1.4.1/src/core/tcp_out.c ****   seg->p->tot_len -= len;
 2384              		.loc 1 1118 0
 2385 00fa 7B68     		ldr	r3, [r7, #4]
 2386 00fc 5B68     		ldr	r3, [r3, #4]
 2387 00fe 7A68     		ldr	r2, [r7, #4]
 2388 0100 5268     		ldr	r2, [r2, #4]
 2389 0102 1189     		ldrh	r1, [r2, #8]
 2390 0104 7A89     		ldrh	r2, [r7, #10]	@ movhi
 2391 0106 8A1A     		subs	r2, r1, r2
 2392 0108 92B2     		uxth	r2, r2
 2393 010a 1A81     		strh	r2, [r3, #8]	@ movhi
1119:../lwip-1.4.1/src/core/tcp_out.c **** 
1120:../lwip-1.4.1/src/core/tcp_out.c ****   seg->p->payload = seg->tcphdr;
 2394              		.loc 1 1120 0
 2395 010c 7B68     		ldr	r3, [r7, #4]
 2396 010e 5B68     		ldr	r3, [r3, #4]
 2397 0110 7A68     		ldr	r2, [r7, #4]
 2398 0112 1269     		ldr	r2, [r2, #16]
 2399 0114 5A60     		str	r2, [r3, #4]
1121:../lwip-1.4.1/src/core/tcp_out.c **** 
1122:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->chksum = 0;
 2400              		.loc 1 1122 0
 2401 0116 7B68     		ldr	r3, [r7, #4]
 2402 0118 1B69     		ldr	r3, [r3, #16]
 2403 011a 0022     		movs	r2, #0
 2404 011c 1A74     		strb	r2, [r3, #16]
 2405 011e 0022     		movs	r2, #0
 2406 0120 5A74     		strb	r2, [r3, #17]
1123:../lwip-1.4.1/src/core/tcp_out.c **** #if CHECKSUM_GEN_TCP
1124:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
1125:../lwip-1.4.1/src/core/tcp_out.c ****   {
1126:../lwip-1.4.1/src/core/tcp_out.c ****     u32_t acc;
1127:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
1128:../lwip-1.4.1/src/core/tcp_out.c ****     u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
1129:../lwip-1.4.1/src/core/tcp_out.c ****            &(pcb->remote_ip),
1130:../lwip-1.4.1/src/core/tcp_out.c ****            IP_PROTO_TCP, seg->p->tot_len);
1131:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
1132:../lwip-1.4.1/src/core/tcp_out.c ****     if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
1133:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_ASSERT("data included but not checksummed",
1134:../lwip-1.4.1/src/core/tcp_out.c ****         seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
1135:../lwip-1.4.1/src/core/tcp_out.c ****     }
1136:../lwip-1.4.1/src/core/tcp_out.c **** 
1137:../lwip-1.4.1/src/core/tcp_out.c ****     /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
1138:../lwip-1.4.1/src/core/tcp_out.c ****     acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
1139:../lwip-1.4.1/src/core/tcp_out.c ****              &(pcb->remote_ip),
1140:../lwip-1.4.1/src/core/tcp_out.c ****              IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
1141:../lwip-1.4.1/src/core/tcp_out.c ****     /* add payload checksum */
1142:../lwip-1.4.1/src/core/tcp_out.c ****     if (seg->chksum_swapped) {
1143:../lwip-1.4.1/src/core/tcp_out.c ****       seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
1144:../lwip-1.4.1/src/core/tcp_out.c ****       seg->chksum_swapped = 0;
1145:../lwip-1.4.1/src/core/tcp_out.c ****     }
1146:../lwip-1.4.1/src/core/tcp_out.c ****     acc += (u16_t)~(seg->chksum);
1147:../lwip-1.4.1/src/core/tcp_out.c ****     seg->tcphdr->chksum = FOLD_U32T(acc);
1148:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
1149:../lwip-1.4.1/src/core/tcp_out.c ****     if (chksum_slow != seg->tcphdr->chksum) {
1150:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
1151:../lwip-1.4.1/src/core/tcp_out.c ****                   ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
1152:../lwip-1.4.1/src/core/tcp_out.c ****                   seg->tcphdr->chksum, chksum_slow));
1153:../lwip-1.4.1/src/core/tcp_out.c ****       seg->tcphdr->chksum = chksum_slow;
1154:../lwip-1.4.1/src/core/tcp_out.c ****     }
1155:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
1156:../lwip-1.4.1/src/core/tcp_out.c ****   }
1157:../lwip-1.4.1/src/core/tcp_out.c **** #else /* TCP_CHECKSUM_ON_COPY */
1158:../lwip-1.4.1/src/core/tcp_out.c ****   seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
1159:../lwip-1.4.1/src/core/tcp_out.c ****          &(pcb->remote_ip),
1160:../lwip-1.4.1/src/core/tcp_out.c ****          IP_PROTO_TCP, seg->p->tot_len);
1161:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
1162:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* CHECKSUM_GEN_TCP */
1163:../lwip-1.4.1/src/core/tcp_out.c ****   TCP_STATS_INC(tcp.xmit);
 2407              		.loc 1 1163 0
 2408 0122 0D4B     		ldr	r3, .L143+4
 2409 0124 D3F82031 		ldr	r3, [r3, #288]
 2410 0128 0133     		adds	r3, r3, #1
 2411 012a 0B4A     		ldr	r2, .L143+4
 2412 012c C2F82031 		str	r3, [r2, #288]
1164:../lwip-1.4.1/src/core/tcp_out.c **** 
1165:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_NETIF_HWADDRHINT
1166:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
1167:../lwip-1.4.1/src/core/tcp_out.c ****       IP_PROTO_TCP, &(pcb->addr_hint));
1168:../lwip-1.4.1/src/core/tcp_out.c **** #else /* LWIP_NETIF_HWADDRHINT*/
1169:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 2413              		.loc 1 1169 0
 2414 0130 7B68     		ldr	r3, [r7, #4]
 2415 0132 5868     		ldr	r0, [r3, #4]
 2416 0134 3968     		ldr	r1, [r7]
 2417 0136 3B68     		ldr	r3, [r7]
 2418 0138 1A1D     		adds	r2, r3, #4
 2419 013a 3B68     		ldr	r3, [r7]
 2420 013c 9C7A     		ldrb	r4, [r3, #10]	@ zero_extendqisi2
 2421 013e 3B68     		ldr	r3, [r7]
 2422 0140 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 2423 0142 0093     		str	r3, [sp]
 2424 0144 0623     		movs	r3, #6
 2425 0146 0193     		str	r3, [sp, #4]
 2426 0148 2346     		mov	r3, r4
 2427 014a FFF7FEFF 		bl	ip_output
 2428              	.L135:
1170:../lwip-1.4.1/src/core/tcp_out.c ****       IP_PROTO_TCP);
1171:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_NETIF_HWADDRHINT*/
1172:../lwip-1.4.1/src/core/tcp_out.c **** }
 2429              		.loc 1 1172 0
 2430 014e 1C37     		adds	r7, r7, #28
 2431              		.cfi_def_cfa_offset 12
 2432 0150 BD46     		mov	sp, r7
 2433              		.cfi_def_cfa_register 13
 2434              		@ sp needed
 2435 0152 90BD     		pop	{r4, r7, pc}
 2436              	.L144:
 2437              		.align	2
 2438              	.L143:
 2439 0154 00000000 		.word	tcp_ticks
 2440 0158 00000000 		.word	lwip_stats
 2441              		.cfi_endproc
 2442              	.LFE9:
 2444              		.section	.text.tcp_rst,"ax",%progbits
 2445              		.align	2
 2446              		.global	tcp_rst
 2447              		.thumb
 2448              		.thumb_func
 2450              	tcp_rst:
 2451              	.LFB10:
1173:../lwip-1.4.1/src/core/tcp_out.c **** 
1174:../lwip-1.4.1/src/core/tcp_out.c **** /**
1175:../lwip-1.4.1/src/core/tcp_out.c ****  * Send a TCP RESET packet (empty segment with RST flag set) either to
1176:../lwip-1.4.1/src/core/tcp_out.c ****  * abort a connection or to show that there is no matching local connection
1177:../lwip-1.4.1/src/core/tcp_out.c ****  * for a received segment.
1178:../lwip-1.4.1/src/core/tcp_out.c ****  *
1179:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
1180:../lwip-1.4.1/src/core/tcp_out.c ****  * matching local pcb was found), tcp_listen_input() (if incoming segment
1181:../lwip-1.4.1/src/core/tcp_out.c ****  * has ACK flag set) and tcp_process() (received segment in the wrong state)
1182:../lwip-1.4.1/src/core/tcp_out.c ****  *
1183:../lwip-1.4.1/src/core/tcp_out.c ****  * Since a RST segment is in most cases not sent for an active connection,
1184:../lwip-1.4.1/src/core/tcp_out.c ****  * tcp_rst() has a number of arguments that are taken from a tcp_pcb for
1185:../lwip-1.4.1/src/core/tcp_out.c ****  * most other segment output functions.
1186:../lwip-1.4.1/src/core/tcp_out.c ****  *
1187:../lwip-1.4.1/src/core/tcp_out.c ****  * @param seqno the sequence number to use for the outgoing segment
1188:../lwip-1.4.1/src/core/tcp_out.c ****  * @param ackno the acknowledge number to use for the outgoing segment
1189:../lwip-1.4.1/src/core/tcp_out.c ****  * @param local_ip the local IP address to send the segment from
1190:../lwip-1.4.1/src/core/tcp_out.c ****  * @param remote_ip the remote IP address to send the segment to
1191:../lwip-1.4.1/src/core/tcp_out.c ****  * @param local_port the local TCP port to send the segment from
1192:../lwip-1.4.1/src/core/tcp_out.c ****  * @param remote_port the remote TCP port to send the segment to
1193:../lwip-1.4.1/src/core/tcp_out.c ****  */
1194:../lwip-1.4.1/src/core/tcp_out.c **** void
1195:../lwip-1.4.1/src/core/tcp_out.c **** tcp_rst(u32_t seqno, u32_t ackno,
1196:../lwip-1.4.1/src/core/tcp_out.c ****   ip_addr_t *local_ip, ip_addr_t *remote_ip,
1197:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t local_port, u16_t remote_port)
1198:../lwip-1.4.1/src/core/tcp_out.c **** {
 2452              		.loc 1 1198 0
 2453              		.cfi_startproc
 2454              		@ args = 8, pretend = 0, frame = 24
 2455              		@ frame_needed = 1, uses_anonymous_args = 0
 2456 0000 80B5     		push	{r7, lr}
 2457              		.cfi_def_cfa_offset 8
 2458              		.cfi_offset 7, -8
 2459              		.cfi_offset 14, -4
 2460 0002 88B0     		sub	sp, sp, #32
 2461              		.cfi_def_cfa_offset 40
 2462 0004 02AF     		add	r7, sp, #8
 2463              		.cfi_def_cfa 7, 32
 2464 0006 F860     		str	r0, [r7, #12]
 2465 0008 B960     		str	r1, [r7, #8]
 2466 000a 7A60     		str	r2, [r7, #4]
 2467 000c 3B60     		str	r3, [r7]
1199:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *p;
1200:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
1201:../lwip-1.4.1/src/core/tcp_out.c ****   p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 2468              		.loc 1 1201 0
 2469 000e 0120     		movs	r0, #1
 2470 0010 1421     		movs	r1, #20
 2471 0012 0022     		movs	r2, #0
 2472 0014 FFF7FEFF 		bl	pbuf_alloc
 2473 0018 7861     		str	r0, [r7, #20]
1202:../lwip-1.4.1/src/core/tcp_out.c ****   if (p == NULL) {
 2474              		.loc 1 1202 0
 2475 001a 7B69     		ldr	r3, [r7, #20]
 2476 001c 002B     		cmp	r3, #0
 2477 001e 00D1     		bne	.L146
1203:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
1204:../lwip-1.4.1/src/core/tcp_out.c ****       return;
 2478              		.loc 1 1204 0
 2479 0020 4DE0     		b	.L145
 2480              	.L146:
1205:../lwip-1.4.1/src/core/tcp_out.c ****   }
1206:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
1207:../lwip-1.4.1/src/core/tcp_out.c ****               (p->len >= sizeof(struct tcp_hdr)));
1208:../lwip-1.4.1/src/core/tcp_out.c **** 
1209:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr = (struct tcp_hdr *)p->payload;
 2481              		.loc 1 1209 0
 2482 0022 7B69     		ldr	r3, [r7, #20]
 2483 0024 5B68     		ldr	r3, [r3, #4]
 2484 0026 3B61     		str	r3, [r7, #16]
1210:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->src = htons(local_port);
 2485              		.loc 1 1210 0
 2486 0028 3B8C     		ldrh	r3, [r7, #32]
 2487 002a 1846     		mov	r0, r3
 2488 002c FFF7FEFF 		bl	lwip_htons
 2489 0030 0346     		mov	r3, r0
 2490 0032 1A46     		mov	r2, r3
 2491 0034 3B69     		ldr	r3, [r7, #16]
 2492 0036 1A80     		strh	r2, [r3]	@ unaligned
1211:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->dest = htons(remote_port);
 2493              		.loc 1 1211 0
 2494 0038 BB8C     		ldrh	r3, [r7, #36]
 2495 003a 1846     		mov	r0, r3
 2496 003c FFF7FEFF 		bl	lwip_htons
 2497 0040 0346     		mov	r3, r0
 2498 0042 1A46     		mov	r2, r3
 2499 0044 3B69     		ldr	r3, [r7, #16]
 2500 0046 5A80     		strh	r2, [r3, #2]	@ unaligned
1212:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->seqno = htonl(seqno);
 2501              		.loc 1 1212 0
 2502 0048 F868     		ldr	r0, [r7, #12]
 2503 004a FFF7FEFF 		bl	lwip_htonl
 2504 004e 0246     		mov	r2, r0
 2505 0050 3B69     		ldr	r3, [r7, #16]
 2506 0052 5A60     		str	r2, [r3, #4]	@ unaligned
1213:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->ackno = htonl(ackno);
 2507              		.loc 1 1213 0
 2508 0054 B868     		ldr	r0, [r7, #8]
 2509 0056 FFF7FEFF 		bl	lwip_htonl
 2510 005a 0246     		mov	r2, r0
 2511 005c 3B69     		ldr	r3, [r7, #16]
 2512 005e 9A60     		str	r2, [r3, #8]	@ unaligned
1214:../lwip-1.4.1/src/core/tcp_out.c ****   TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 2513              		.loc 1 1214 0
 2514 0060 45F21400 		movw	r0, #20500
 2515 0064 FFF7FEFF 		bl	lwip_htons
 2516 0068 0346     		mov	r3, r0
 2517 006a 1A46     		mov	r2, r3
 2518 006c 3B69     		ldr	r3, [r7, #16]
 2519 006e 9A81     		strh	r2, [r3, #12]	@ unaligned
1215:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->wnd = PP_HTONS(TCP_WND);
 2520              		.loc 1 1215 0
 2521 0070 3B69     		ldr	r3, [r7, #16]
 2522 0072 0022     		movs	r2, #0
 2523 0074 42F00B02 		orr	r2, r2, #11
 2524 0078 9A73     		strb	r2, [r3, #14]
 2525 007a 0022     		movs	r2, #0
 2526 007c 42F06802 		orr	r2, r2, #104
 2527 0080 DA73     		strb	r2, [r3, #15]
1216:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->chksum = 0;
 2528              		.loc 1 1216 0
 2529 0082 3B69     		ldr	r3, [r7, #16]
 2530 0084 0022     		movs	r2, #0
 2531 0086 1A74     		strb	r2, [r3, #16]
 2532 0088 0022     		movs	r2, #0
 2533 008a 5A74     		strb	r2, [r3, #17]
1217:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->urgp = 0;
 2534              		.loc 1 1217 0
 2535 008c 3B69     		ldr	r3, [r7, #16]
 2536 008e 0022     		movs	r2, #0
 2537 0090 9A74     		strb	r2, [r3, #18]
 2538 0092 0022     		movs	r2, #0
 2539 0094 DA74     		strb	r2, [r3, #19]
1218:../lwip-1.4.1/src/core/tcp_out.c **** 
1219:../lwip-1.4.1/src/core/tcp_out.c **** #if CHECKSUM_GEN_TCP
1220:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
1221:../lwip-1.4.1/src/core/tcp_out.c ****               IP_PROTO_TCP, p->tot_len);
1222:../lwip-1.4.1/src/core/tcp_out.c **** #endif
1223:../lwip-1.4.1/src/core/tcp_out.c ****   TCP_STATS_INC(tcp.xmit);
 2540              		.loc 1 1223 0
 2541 0096 0B4B     		ldr	r3, .L148
 2542 0098 D3F82031 		ldr	r3, [r3, #288]
 2543 009c 0133     		adds	r3, r3, #1
 2544 009e 094A     		ldr	r2, .L148
 2545 00a0 C2F82031 		str	r3, [r2, #288]
1224:../lwip-1.4.1/src/core/tcp_out.c ****   snmp_inc_tcpoutrsts();
1225:../lwip-1.4.1/src/core/tcp_out.c ****    /* Send output with hardcoded TTL since we have no access to the pcb */
1226:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 2546              		.loc 1 1226 0
 2547 00a4 0023     		movs	r3, #0
 2548 00a6 0093     		str	r3, [sp]
 2549 00a8 0623     		movs	r3, #6
 2550 00aa 0193     		str	r3, [sp, #4]
 2551 00ac 7869     		ldr	r0, [r7, #20]
 2552 00ae 7968     		ldr	r1, [r7, #4]
 2553 00b0 3A68     		ldr	r2, [r7]
 2554 00b2 FF23     		movs	r3, #255
 2555 00b4 FFF7FEFF 		bl	ip_output
1227:../lwip-1.4.1/src/core/tcp_out.c ****   pbuf_free(p);
 2556              		.loc 1 1227 0
 2557 00b8 7869     		ldr	r0, [r7, #20]
 2558 00ba FFF7FEFF 		bl	pbuf_free
 2559              	.L145:
1228:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
1229:../lwip-1.4.1/src/core/tcp_out.c **** }
 2560              		.loc 1 1229 0
 2561 00be 1837     		adds	r7, r7, #24
 2562              		.cfi_def_cfa_offset 8
 2563 00c0 BD46     		mov	sp, r7
 2564              		.cfi_def_cfa_register 13
 2565              		@ sp needed
 2566 00c2 80BD     		pop	{r7, pc}
 2567              	.L149:
 2568              		.align	2
 2569              	.L148:
 2570 00c4 00000000 		.word	lwip_stats
 2571              		.cfi_endproc
 2572              	.LFE10:
 2574              		.section	.text.tcp_rexmit_rto,"ax",%progbits
 2575              		.align	2
 2576              		.global	tcp_rexmit_rto
 2577              		.thumb
 2578              		.thumb_func
 2580              	tcp_rexmit_rto:
 2581              	.LFB11:
1230:../lwip-1.4.1/src/core/tcp_out.c **** 
1231:../lwip-1.4.1/src/core/tcp_out.c **** /**
1232:../lwip-1.4.1/src/core/tcp_out.c ****  * Requeue all unacked segments for retransmission
1233:../lwip-1.4.1/src/core/tcp_out.c ****  *
1234:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_slowtmr() for slow retransmission.
1235:../lwip-1.4.1/src/core/tcp_out.c ****  *
1236:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
1237:../lwip-1.4.1/src/core/tcp_out.c ****  */
1238:../lwip-1.4.1/src/core/tcp_out.c **** void
1239:../lwip-1.4.1/src/core/tcp_out.c **** tcp_rexmit_rto(struct tcp_pcb *pcb)
1240:../lwip-1.4.1/src/core/tcp_out.c **** {
 2582              		.loc 1 1240 0
 2583              		.cfi_startproc
 2584              		@ args = 0, pretend = 0, frame = 16
 2585              		@ frame_needed = 1, uses_anonymous_args = 0
 2586 0000 80B5     		push	{r7, lr}
 2587              		.cfi_def_cfa_offset 8
 2588              		.cfi_offset 7, -8
 2589              		.cfi_offset 14, -4
 2590 0002 84B0     		sub	sp, sp, #16
 2591              		.cfi_def_cfa_offset 24
 2592 0004 00AF     		add	r7, sp, #0
 2593              		.cfi_def_cfa_register 7
 2594 0006 7860     		str	r0, [r7, #4]
1241:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg *seg;
1242:../lwip-1.4.1/src/core/tcp_out.c **** 
1243:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->unacked == NULL) {
 2595              		.loc 1 1243 0
 2596 0008 7B68     		ldr	r3, [r7, #4]
 2597 000a 1B6F     		ldr	r3, [r3, #112]
 2598 000c 002B     		cmp	r3, #0
 2599 000e 00D1     		bne	.L151
1244:../lwip-1.4.1/src/core/tcp_out.c ****     return;
 2600              		.loc 1 1244 0
 2601 0010 23E0     		b	.L150
 2602              	.L151:
1245:../lwip-1.4.1/src/core/tcp_out.c ****   }
1246:../lwip-1.4.1/src/core/tcp_out.c **** 
1247:../lwip-1.4.1/src/core/tcp_out.c ****   /* Move all unacked segments to the head of the unsent queue */
1248:../lwip-1.4.1/src/core/tcp_out.c ****   for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 2603              		.loc 1 1248 0
 2604 0012 7B68     		ldr	r3, [r7, #4]
 2605 0014 1B6F     		ldr	r3, [r3, #112]
 2606 0016 FB60     		str	r3, [r7, #12]
 2607 0018 02E0     		b	.L153
 2608              	.L154:
 2609              		.loc 1 1248 0 is_stmt 0 discriminator 3
 2610 001a FB68     		ldr	r3, [r7, #12]
 2611 001c 1B68     		ldr	r3, [r3]
 2612 001e FB60     		str	r3, [r7, #12]
 2613              	.L153:
 2614              		.loc 1 1248 0 discriminator 1
 2615 0020 FB68     		ldr	r3, [r7, #12]
 2616 0022 1B68     		ldr	r3, [r3]
 2617 0024 002B     		cmp	r3, #0
 2618 0026 F8D1     		bne	.L154
1249:../lwip-1.4.1/src/core/tcp_out.c ****   /* concatenate unsent queue after unacked queue */
1250:../lwip-1.4.1/src/core/tcp_out.c ****   seg->next = pcb->unsent;
 2619              		.loc 1 1250 0 is_stmt 1
 2620 0028 7B68     		ldr	r3, [r7, #4]
 2621 002a DA6E     		ldr	r2, [r3, #108]
 2622 002c FB68     		ldr	r3, [r7, #12]
 2623 002e 1A60     		str	r2, [r3]
1251:../lwip-1.4.1/src/core/tcp_out.c ****   /* unsent queue is the concatenated queue (of unacked, unsent) */
1252:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->unsent = pcb->unacked;
 2624              		.loc 1 1252 0
 2625 0030 7B68     		ldr	r3, [r7, #4]
 2626 0032 1A6F     		ldr	r2, [r3, #112]
 2627 0034 7B68     		ldr	r3, [r7, #4]
 2628 0036 DA66     		str	r2, [r3, #108]
1253:../lwip-1.4.1/src/core/tcp_out.c ****   /* unacked queue is now empty */
1254:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->unacked = NULL;
 2629              		.loc 1 1254 0
 2630 0038 7B68     		ldr	r3, [r7, #4]
 2631 003a 0022     		movs	r2, #0
 2632 003c 1A67     		str	r2, [r3, #112]
1255:../lwip-1.4.1/src/core/tcp_out.c ****   /* last unsent hasn't changed, no need to reset unsent_oversize */
1256:../lwip-1.4.1/src/core/tcp_out.c **** 
1257:../lwip-1.4.1/src/core/tcp_out.c ****   /* increment number of retransmissions */
1258:../lwip-1.4.1/src/core/tcp_out.c ****   ++pcb->nrtx;
 2633              		.loc 1 1258 0
 2634 003e 7B68     		ldr	r3, [r7, #4]
 2635 0040 93F84630 		ldrb	r3, [r3, #70]	@ zero_extendqisi2
 2636 0044 0133     		adds	r3, r3, #1
 2637 0046 DAB2     		uxtb	r2, r3
 2638 0048 7B68     		ldr	r3, [r7, #4]
 2639 004a 83F84620 		strb	r2, [r3, #70]
1259:../lwip-1.4.1/src/core/tcp_out.c **** 
1260:../lwip-1.4.1/src/core/tcp_out.c ****   /* Don't take any RTT measurements after retransmitting. */
1261:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->rttest = 0;
 2640              		.loc 1 1261 0
 2641 004e 7B68     		ldr	r3, [r7, #4]
 2642 0050 0022     		movs	r2, #0
 2643 0052 9A63     		str	r2, [r3, #56]
1262:../lwip-1.4.1/src/core/tcp_out.c **** 
1263:../lwip-1.4.1/src/core/tcp_out.c ****   /* Do the actual retransmission */
1264:../lwip-1.4.1/src/core/tcp_out.c ****   tcp_output(pcb);
 2644              		.loc 1 1264 0
 2645 0054 7868     		ldr	r0, [r7, #4]
 2646 0056 FFF7FEFF 		bl	tcp_output
 2647              	.L150:
1265:../lwip-1.4.1/src/core/tcp_out.c **** }
 2648              		.loc 1 1265 0
 2649 005a 1037     		adds	r7, r7, #16
 2650              		.cfi_def_cfa_offset 8
 2651 005c BD46     		mov	sp, r7
 2652              		.cfi_def_cfa_register 13
 2653              		@ sp needed
 2654 005e 80BD     		pop	{r7, pc}
 2655              		.cfi_endproc
 2656              	.LFE11:
 2658              		.section	.text.tcp_rexmit,"ax",%progbits
 2659              		.align	2
 2660              		.global	tcp_rexmit
 2661              		.thumb
 2662              		.thumb_func
 2664              	tcp_rexmit:
 2665              	.LFB12:
1266:../lwip-1.4.1/src/core/tcp_out.c **** 
1267:../lwip-1.4.1/src/core/tcp_out.c **** /**
1268:../lwip-1.4.1/src/core/tcp_out.c ****  * Requeue the first unacked segment for retransmission
1269:../lwip-1.4.1/src/core/tcp_out.c ****  *
1270:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_receive() for fast retramsmit.
1271:../lwip-1.4.1/src/core/tcp_out.c ****  *
1272:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to retransmit the first unacked segment
1273:../lwip-1.4.1/src/core/tcp_out.c ****  */
1274:../lwip-1.4.1/src/core/tcp_out.c **** void
1275:../lwip-1.4.1/src/core/tcp_out.c **** tcp_rexmit(struct tcp_pcb *pcb)
1276:../lwip-1.4.1/src/core/tcp_out.c **** {
 2666              		.loc 1 1276 0
 2667              		.cfi_startproc
 2668              		@ args = 0, pretend = 0, frame = 16
 2669              		@ frame_needed = 1, uses_anonymous_args = 0
 2670 0000 90B5     		push	{r4, r7, lr}
 2671              		.cfi_def_cfa_offset 12
 2672              		.cfi_offset 4, -12
 2673              		.cfi_offset 7, -8
 2674              		.cfi_offset 14, -4
 2675 0002 85B0     		sub	sp, sp, #20
 2676              		.cfi_def_cfa_offset 32
 2677 0004 00AF     		add	r7, sp, #0
 2678              		.cfi_def_cfa_register 7
 2679 0006 7860     		str	r0, [r7, #4]
1277:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg *seg;
1278:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg **cur_seg;
1279:../lwip-1.4.1/src/core/tcp_out.c **** 
1280:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->unacked == NULL) {
 2680              		.loc 1 1280 0
 2681 0008 7B68     		ldr	r3, [r7, #4]
 2682 000a 1B6F     		ldr	r3, [r3, #112]
 2683 000c 002B     		cmp	r3, #0
 2684 000e 00D1     		bne	.L156
1281:../lwip-1.4.1/src/core/tcp_out.c ****     return;
 2685              		.loc 1 1281 0
 2686 0010 3DE0     		b	.L155
 2687              	.L156:
1282:../lwip-1.4.1/src/core/tcp_out.c ****   }
1283:../lwip-1.4.1/src/core/tcp_out.c **** 
1284:../lwip-1.4.1/src/core/tcp_out.c ****   /* Move the first unacked segment to the unsent queue */
1285:../lwip-1.4.1/src/core/tcp_out.c ****   /* Keep the unsent queue sorted. */
1286:../lwip-1.4.1/src/core/tcp_out.c ****   seg = pcb->unacked;
 2688              		.loc 1 1286 0
 2689 0012 7B68     		ldr	r3, [r7, #4]
 2690 0014 1B6F     		ldr	r3, [r3, #112]
 2691 0016 BB60     		str	r3, [r7, #8]
1287:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->unacked = seg->next;
 2692              		.loc 1 1287 0
 2693 0018 BB68     		ldr	r3, [r7, #8]
 2694 001a 1A68     		ldr	r2, [r3]
 2695 001c 7B68     		ldr	r3, [r7, #4]
 2696 001e 1A67     		str	r2, [r3, #112]
1288:../lwip-1.4.1/src/core/tcp_out.c **** 
1289:../lwip-1.4.1/src/core/tcp_out.c ****   cur_seg = &(pcb->unsent);
 2697              		.loc 1 1289 0
 2698 0020 7B68     		ldr	r3, [r7, #4]
 2699 0022 6C33     		adds	r3, r3, #108
 2700 0024 FB60     		str	r3, [r7, #12]
1290:../lwip-1.4.1/src/core/tcp_out.c ****   while (*cur_seg &&
 2701              		.loc 1 1290 0
 2702 0026 02E0     		b	.L158
 2703              	.L160:
1291:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
1292:../lwip-1.4.1/src/core/tcp_out.c ****       cur_seg = &((*cur_seg)->next );
 2704              		.loc 1 1292 0
 2705 0028 FB68     		ldr	r3, [r7, #12]
 2706 002a 1B68     		ldr	r3, [r3]
 2707 002c FB60     		str	r3, [r7, #12]
 2708              	.L158:
1290:../lwip-1.4.1/src/core/tcp_out.c ****   while (*cur_seg &&
 2709              		.loc 1 1290 0
 2710 002e FB68     		ldr	r3, [r7, #12]
 2711 0030 1B68     		ldr	r3, [r3]
 2712 0032 002B     		cmp	r3, #0
 2713 0034 11D0     		beq	.L159
1291:../lwip-1.4.1/src/core/tcp_out.c ****     TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 2714              		.loc 1 1291 0 discriminator 1
 2715 0036 FB68     		ldr	r3, [r7, #12]
 2716 0038 1B68     		ldr	r3, [r3]
 2717 003a 1B69     		ldr	r3, [r3, #16]
 2718 003c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2719 003e 1846     		mov	r0, r3
 2720 0040 FFF7FEFF 		bl	lwip_ntohl
 2721 0044 0446     		mov	r4, r0
 2722 0046 BB68     		ldr	r3, [r7, #8]
 2723 0048 1B69     		ldr	r3, [r3, #16]
 2724 004a 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2725 004c 1846     		mov	r0, r3
 2726 004e FFF7FEFF 		bl	lwip_ntohl
 2727 0052 0346     		mov	r3, r0
 2728 0054 E31A     		subs	r3, r4, r3
1290:../lwip-1.4.1/src/core/tcp_out.c ****   while (*cur_seg &&
 2729              		.loc 1 1290 0 discriminator 1
 2730 0056 002B     		cmp	r3, #0
 2731 0058 E6DB     		blt	.L160
 2732              	.L159:
1293:../lwip-1.4.1/src/core/tcp_out.c ****   }
1294:../lwip-1.4.1/src/core/tcp_out.c ****   seg->next = *cur_seg;
 2733              		.loc 1 1294 0
 2734 005a FB68     		ldr	r3, [r7, #12]
 2735 005c 1A68     		ldr	r2, [r3]
 2736 005e BB68     		ldr	r3, [r7, #8]
 2737 0060 1A60     		str	r2, [r3]
1295:../lwip-1.4.1/src/core/tcp_out.c ****   *cur_seg = seg;
 2738              		.loc 1 1295 0
 2739 0062 FB68     		ldr	r3, [r7, #12]
 2740 0064 BA68     		ldr	r2, [r7, #8]
 2741 0066 1A60     		str	r2, [r3]
1296:../lwip-1.4.1/src/core/tcp_out.c **** #if TCP_OVERSIZE
1297:../lwip-1.4.1/src/core/tcp_out.c ****   if (seg->next == NULL) {
 2742              		.loc 1 1297 0
 2743 0068 BB68     		ldr	r3, [r7, #8]
 2744 006a 1B68     		ldr	r3, [r3]
 2745 006c 002B     		cmp	r3, #0
 2746 006e 03D1     		bne	.L161
1298:../lwip-1.4.1/src/core/tcp_out.c ****     /* the retransmitted segment is last in unsent, so reset unsent_oversize */
1299:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->unsent_oversize = 0;
 2747              		.loc 1 1299 0
 2748 0070 7B68     		ldr	r3, [r7, #4]
 2749 0072 0022     		movs	r2, #0
 2750 0074 A3F86A20 		strh	r2, [r3, #106]	@ movhi
 2751              	.L161:
1300:../lwip-1.4.1/src/core/tcp_out.c ****   }
1301:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
1302:../lwip-1.4.1/src/core/tcp_out.c **** 
1303:../lwip-1.4.1/src/core/tcp_out.c ****   ++pcb->nrtx;
 2752              		.loc 1 1303 0
 2753 0078 7B68     		ldr	r3, [r7, #4]
 2754 007a 93F84630 		ldrb	r3, [r3, #70]	@ zero_extendqisi2
 2755 007e 0133     		adds	r3, r3, #1
 2756 0080 DAB2     		uxtb	r2, r3
 2757 0082 7B68     		ldr	r3, [r7, #4]
 2758 0084 83F84620 		strb	r2, [r3, #70]
1304:../lwip-1.4.1/src/core/tcp_out.c **** 
1305:../lwip-1.4.1/src/core/tcp_out.c ****   /* Don't take any rtt measurements after retransmitting. */
1306:../lwip-1.4.1/src/core/tcp_out.c ****   pcb->rttest = 0;
 2759              		.loc 1 1306 0
 2760 0088 7B68     		ldr	r3, [r7, #4]
 2761 008a 0022     		movs	r2, #0
 2762 008c 9A63     		str	r2, [r3, #56]
 2763              	.L155:
1307:../lwip-1.4.1/src/core/tcp_out.c **** 
1308:../lwip-1.4.1/src/core/tcp_out.c ****   /* Do the actual retransmission. */
1309:../lwip-1.4.1/src/core/tcp_out.c ****   snmp_inc_tcpretranssegs();
1310:../lwip-1.4.1/src/core/tcp_out.c ****   /* No need to call tcp_output: we are always called from tcp_input()
1311:../lwip-1.4.1/src/core/tcp_out.c ****      and thus tcp_output directly returns. */
1312:../lwip-1.4.1/src/core/tcp_out.c **** }
 2764              		.loc 1 1312 0
 2765 008e 1437     		adds	r7, r7, #20
 2766              		.cfi_def_cfa_offset 12
 2767 0090 BD46     		mov	sp, r7
 2768              		.cfi_def_cfa_register 13
 2769              		@ sp needed
 2770 0092 90BD     		pop	{r4, r7, pc}
 2771              		.cfi_endproc
 2772              	.LFE12:
 2774              		.section	.text.tcp_rexmit_fast,"ax",%progbits
 2775              		.align	2
 2776              		.global	tcp_rexmit_fast
 2777              		.thumb
 2778              		.thumb_func
 2780              	tcp_rexmit_fast:
 2781              	.LFB13:
1313:../lwip-1.4.1/src/core/tcp_out.c **** 
1314:../lwip-1.4.1/src/core/tcp_out.c **** 
1315:../lwip-1.4.1/src/core/tcp_out.c **** /**
1316:../lwip-1.4.1/src/core/tcp_out.c ****  * Handle retransmission after three dupacks received
1317:../lwip-1.4.1/src/core/tcp_out.c ****  *
1318:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to retransmit the first unacked segment
1319:../lwip-1.4.1/src/core/tcp_out.c ****  */
1320:../lwip-1.4.1/src/core/tcp_out.c **** void 
1321:../lwip-1.4.1/src/core/tcp_out.c **** tcp_rexmit_fast(struct tcp_pcb *pcb)
1322:../lwip-1.4.1/src/core/tcp_out.c **** {
 2782              		.loc 1 1322 0
 2783              		.cfi_startproc
 2784              		@ args = 0, pretend = 0, frame = 8
 2785              		@ frame_needed = 1, uses_anonymous_args = 0
 2786 0000 80B5     		push	{r7, lr}
 2787              		.cfi_def_cfa_offset 8
 2788              		.cfi_offset 7, -8
 2789              		.cfi_offset 14, -4
 2790 0002 82B0     		sub	sp, sp, #8
 2791              		.cfi_def_cfa_offset 16
 2792 0004 00AF     		add	r7, sp, #0
 2793              		.cfi_def_cfa_register 7
 2794 0006 7860     		str	r0, [r7, #4]
1323:../lwip-1.4.1/src/core/tcp_out.c ****   if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 2795              		.loc 1 1323 0
 2796 0008 7B68     		ldr	r3, [r7, #4]
 2797 000a 1B6F     		ldr	r3, [r3, #112]
 2798 000c 002B     		cmp	r3, #0
 2799 000e 46D0     		beq	.L162
 2800              		.loc 1 1323 0 is_stmt 0 discriminator 1
 2801 0010 7B68     		ldr	r3, [r7, #4]
 2802 0012 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 2803 0014 03F00403 		and	r3, r3, #4
 2804 0018 002B     		cmp	r3, #0
 2805 001a 40D1     		bne	.L162
1324:../lwip-1.4.1/src/core/tcp_out.c ****     /* This is fast retransmit. Retransmit the first unacked segment. */
1325:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_FR_DEBUG, 
1326:../lwip-1.4.1/src/core/tcp_out.c ****                 ("tcp_receive: dupacks %"U16_F" (%"U32_F
1327:../lwip-1.4.1/src/core/tcp_out.c ****                  "), fast retransmit %"U32_F"\n",
1328:../lwip-1.4.1/src/core/tcp_out.c ****                  (u16_t)pcb->dupacks, pcb->lastack,
1329:../lwip-1.4.1/src/core/tcp_out.c ****                  ntohl(pcb->unacked->tcphdr->seqno)));
1330:../lwip-1.4.1/src/core/tcp_out.c ****     tcp_rexmit(pcb);
 2806              		.loc 1 1330 0 is_stmt 1
 2807 001c 7868     		ldr	r0, [r7, #4]
 2808 001e FFF7FEFF 		bl	tcp_rexmit
1331:../lwip-1.4.1/src/core/tcp_out.c **** 
1332:../lwip-1.4.1/src/core/tcp_out.c ****     /* Set ssthresh to half of the minimum of the current
1333:../lwip-1.4.1/src/core/tcp_out.c ****      * cwnd and the advertised window */
1334:../lwip-1.4.1/src/core/tcp_out.c ****     if (pcb->cwnd > pcb->snd_wnd) {
 2809              		.loc 1 1334 0
 2810 0022 7B68     		ldr	r3, [r7, #4]
 2811 0024 B3F84C20 		ldrh	r2, [r3, #76]
 2812 0028 7B68     		ldr	r3, [r7, #4]
 2813 002a B3F86030 		ldrh	r3, [r3, #96]
 2814 002e 9A42     		cmp	r2, r3
 2815 0030 08D9     		bls	.L164
1335:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->ssthresh = pcb->snd_wnd / 2;
 2816              		.loc 1 1335 0
 2817 0032 7B68     		ldr	r3, [r7, #4]
 2818 0034 B3F86030 		ldrh	r3, [r3, #96]
 2819 0038 5B08     		lsrs	r3, r3, #1
 2820 003a 9AB2     		uxth	r2, r3
 2821 003c 7B68     		ldr	r3, [r7, #4]
 2822 003e A3F84E20 		strh	r2, [r3, #78]	@ movhi
 2823 0042 07E0     		b	.L165
 2824              	.L164:
1336:../lwip-1.4.1/src/core/tcp_out.c ****     } else {
1337:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->ssthresh = pcb->cwnd / 2;
 2825              		.loc 1 1337 0
 2826 0044 7B68     		ldr	r3, [r7, #4]
 2827 0046 B3F84C30 		ldrh	r3, [r3, #76]
 2828 004a 5B08     		lsrs	r3, r3, #1
 2829 004c 9AB2     		uxth	r2, r3
 2830 004e 7B68     		ldr	r3, [r7, #4]
 2831 0050 A3F84E20 		strh	r2, [r3, #78]	@ movhi
 2832              	.L165:
1338:../lwip-1.4.1/src/core/tcp_out.c ****     }
1339:../lwip-1.4.1/src/core/tcp_out.c ****     
1340:../lwip-1.4.1/src/core/tcp_out.c ****     /* The minimum value for ssthresh should be 2 MSS */
1341:../lwip-1.4.1/src/core/tcp_out.c ****     if (pcb->ssthresh < 2*pcb->mss) {
 2833              		.loc 1 1341 0
 2834 0054 7B68     		ldr	r3, [r7, #4]
 2835 0056 B3F84E30 		ldrh	r3, [r3, #78]
 2836 005a 1A46     		mov	r2, r3
 2837 005c 7B68     		ldr	r3, [r7, #4]
 2838 005e DB8E     		ldrh	r3, [r3, #54]
 2839 0060 5B00     		lsls	r3, r3, #1
 2840 0062 9A42     		cmp	r2, r3
 2841 0064 06DA     		bge	.L166
1342:../lwip-1.4.1/src/core/tcp_out.c ****       LWIP_DEBUGF(TCP_FR_DEBUG, 
1343:../lwip-1.4.1/src/core/tcp_out.c ****                   ("tcp_receive: The minimum value for ssthresh %"U16_F
1344:../lwip-1.4.1/src/core/tcp_out.c ****                    " should be min 2 mss %"U16_F"...\n",
1345:../lwip-1.4.1/src/core/tcp_out.c ****                    pcb->ssthresh, 2*pcb->mss));
1346:../lwip-1.4.1/src/core/tcp_out.c ****       pcb->ssthresh = 2*pcb->mss;
 2842              		.loc 1 1346 0
 2843 0066 7B68     		ldr	r3, [r7, #4]
 2844 0068 DB8E     		ldrh	r3, [r3, #54]
 2845 006a 5B00     		lsls	r3, r3, #1
 2846 006c 9AB2     		uxth	r2, r3
 2847 006e 7B68     		ldr	r3, [r7, #4]
 2848 0070 A3F84E20 		strh	r2, [r3, #78]	@ movhi
 2849              	.L166:
1347:../lwip-1.4.1/src/core/tcp_out.c ****     }
1348:../lwip-1.4.1/src/core/tcp_out.c ****     
1349:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 2850              		.loc 1 1349 0
 2851 0074 7B68     		ldr	r3, [r7, #4]
 2852 0076 B3F84E20 		ldrh	r2, [r3, #78]
 2853 007a 7B68     		ldr	r3, [r7, #4]
 2854 007c DB8E     		ldrh	r3, [r3, #54]
 2855 007e 1946     		mov	r1, r3	@ movhi
 2856 0080 4900     		lsls	r1, r1, #1
 2857 0082 0B44     		add	r3, r3, r1
 2858 0084 9BB2     		uxth	r3, r3
 2859 0086 1344     		add	r3, r3, r2
 2860 0088 9AB2     		uxth	r2, r3
 2861 008a 7B68     		ldr	r3, [r7, #4]
 2862 008c A3F84C20 		strh	r2, [r3, #76]	@ movhi
1350:../lwip-1.4.1/src/core/tcp_out.c ****     pcb->flags |= TF_INFR;
 2863              		.loc 1 1350 0
 2864 0090 7B68     		ldr	r3, [r7, #4]
 2865 0092 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 2866 0094 43F00403 		orr	r3, r3, #4
 2867 0098 DAB2     		uxtb	r2, r3
 2868 009a 7B68     		ldr	r3, [r7, #4]
 2869 009c 9A77     		strb	r2, [r3, #30]
 2870              	.L162:
1351:../lwip-1.4.1/src/core/tcp_out.c ****   } 
1352:../lwip-1.4.1/src/core/tcp_out.c **** }
 2871              		.loc 1 1352 0
 2872 009e 0837     		adds	r7, r7, #8
 2873              		.cfi_def_cfa_offset 8
 2874 00a0 BD46     		mov	sp, r7
 2875              		.cfi_def_cfa_register 13
 2876              		@ sp needed
 2877 00a2 80BD     		pop	{r7, pc}
 2878              		.cfi_endproc
 2879              	.LFE13:
 2881              		.section	.text.tcp_keepalive,"ax",%progbits
 2882              		.align	2
 2883              		.global	tcp_keepalive
 2884              		.thumb
 2885              		.thumb_func
 2887              	tcp_keepalive:
 2888              	.LFB14:
1353:../lwip-1.4.1/src/core/tcp_out.c **** 
1354:../lwip-1.4.1/src/core/tcp_out.c **** 
1355:../lwip-1.4.1/src/core/tcp_out.c **** /**
1356:../lwip-1.4.1/src/core/tcp_out.c ****  * Send keepalive packets to keep a connection active although
1357:../lwip-1.4.1/src/core/tcp_out.c ****  * no data is sent over it.
1358:../lwip-1.4.1/src/core/tcp_out.c ****  *
1359:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_slowtmr()
1360:../lwip-1.4.1/src/core/tcp_out.c ****  *
1361:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to send a keepalive packet
1362:../lwip-1.4.1/src/core/tcp_out.c ****  */
1363:../lwip-1.4.1/src/core/tcp_out.c **** void
1364:../lwip-1.4.1/src/core/tcp_out.c **** tcp_keepalive(struct tcp_pcb *pcb)
1365:../lwip-1.4.1/src/core/tcp_out.c **** {
 2889              		.loc 1 1365 0
 2890              		.cfi_startproc
 2891              		@ args = 0, pretend = 0, frame = 16
 2892              		@ frame_needed = 1, uses_anonymous_args = 0
 2893 0000 90B5     		push	{r4, r7, lr}
 2894              		.cfi_def_cfa_offset 12
 2895              		.cfi_offset 4, -12
 2896              		.cfi_offset 7, -8
 2897              		.cfi_offset 14, -4
 2898 0002 87B0     		sub	sp, sp, #28
 2899              		.cfi_def_cfa_offset 40
 2900 0004 02AF     		add	r7, sp, #8
 2901              		.cfi_def_cfa 7, 32
 2902 0006 7860     		str	r0, [r7, #4]
1366:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *p;
1367:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
1368:../lwip-1.4.1/src/core/tcp_out.c **** 
1369:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U
1370:../lwip-1.4.1/src/core/tcp_out.c ****                           ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
1371:../lwip-1.4.1/src/core/tcp_out.c ****                           ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
1372:../lwip-1.4.1/src/core/tcp_out.c **** 
1373:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent
1374:../lwip-1.4.1/src/core/tcp_out.c ****                           tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
1375:../lwip-1.4.1/src/core/tcp_out.c ****    
1376:../lwip-1.4.1/src/core/tcp_out.c ****   p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 2903              		.loc 1 1376 0
 2904 0008 7B68     		ldr	r3, [r7, #4]
 2905 000a 1B6D     		ldr	r3, [r3, #80]
 2906 000c 013B     		subs	r3, r3, #1
 2907 000e 1846     		mov	r0, r3
 2908 0010 FFF7FEFF 		bl	lwip_htonl
 2909 0014 0346     		mov	r3, r0
 2910 0016 7868     		ldr	r0, [r7, #4]
 2911 0018 0021     		movs	r1, #0
 2912 001a 0022     		movs	r2, #0
 2913 001c FFF7FEFF 		bl	tcp_output_alloc_header
 2914 0020 F860     		str	r0, [r7, #12]
1377:../lwip-1.4.1/src/core/tcp_out.c ****   if(p == NULL) {
 2915              		.loc 1 1377 0
 2916 0022 FB68     		ldr	r3, [r7, #12]
 2917 0024 002B     		cmp	r3, #0
 2918 0026 00D1     		bne	.L168
1378:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_DEBUG, 
1379:../lwip-1.4.1/src/core/tcp_out.c ****                 ("tcp_keepalive: could not allocate memory for pbuf\n"));
1380:../lwip-1.4.1/src/core/tcp_out.c ****     return;
 2919              		.loc 1 1380 0
 2920 0028 19E0     		b	.L167
 2921              	.L168:
1381:../lwip-1.4.1/src/core/tcp_out.c ****   }
1382:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr = (struct tcp_hdr *)p->payload;
 2922              		.loc 1 1382 0
 2923 002a FB68     		ldr	r3, [r7, #12]
 2924 002c 5B68     		ldr	r3, [r3, #4]
 2925 002e BB60     		str	r3, [r7, #8]
1383:../lwip-1.4.1/src/core/tcp_out.c **** 
1384:../lwip-1.4.1/src/core/tcp_out.c **** #if CHECKSUM_GEN_TCP
1385:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
1386:../lwip-1.4.1/src/core/tcp_out.c ****                                       IP_PROTO_TCP, p->tot_len);
1387:../lwip-1.4.1/src/core/tcp_out.c **** #endif
1388:../lwip-1.4.1/src/core/tcp_out.c ****   TCP_STATS_INC(tcp.xmit);
 2926              		.loc 1 1388 0
 2927 0030 0C4B     		ldr	r3, .L170
 2928 0032 D3F82031 		ldr	r3, [r3, #288]
 2929 0036 0133     		adds	r3, r3, #1
 2930 0038 0A4A     		ldr	r2, .L170
 2931 003a C2F82031 		str	r3, [r2, #288]
1389:../lwip-1.4.1/src/core/tcp_out.c **** 
1390:../lwip-1.4.1/src/core/tcp_out.c ****   /* Send output to IP */
1391:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_NETIF_HWADDRHINT
1392:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
1393:../lwip-1.4.1/src/core/tcp_out.c ****     &(pcb->addr_hint));
1394:../lwip-1.4.1/src/core/tcp_out.c **** #else /* LWIP_NETIF_HWADDRHINT*/
1395:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 2932              		.loc 1 1395 0
 2933 003e 7968     		ldr	r1, [r7, #4]
 2934 0040 7B68     		ldr	r3, [r7, #4]
 2935 0042 1A1D     		adds	r2, r3, #4
 2936 0044 7B68     		ldr	r3, [r7, #4]
 2937 0046 9C7A     		ldrb	r4, [r3, #10]	@ zero_extendqisi2
 2938 0048 0023     		movs	r3, #0
 2939 004a 0093     		str	r3, [sp]
 2940 004c 0623     		movs	r3, #6
 2941 004e 0193     		str	r3, [sp, #4]
 2942 0050 F868     		ldr	r0, [r7, #12]
 2943 0052 2346     		mov	r3, r4
 2944 0054 FFF7FEFF 		bl	ip_output
1396:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_NETIF_HWADDRHINT*/
1397:../lwip-1.4.1/src/core/tcp_out.c **** 
1398:../lwip-1.4.1/src/core/tcp_out.c ****   pbuf_free(p);
 2945              		.loc 1 1398 0
 2946 0058 F868     		ldr	r0, [r7, #12]
 2947 005a FFF7FEFF 		bl	pbuf_free
 2948              	.L167:
1399:../lwip-1.4.1/src/core/tcp_out.c **** 
1400:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
1401:../lwip-1.4.1/src/core/tcp_out.c ****                           pcb->snd_nxt - 1, pcb->rcv_nxt));
1402:../lwip-1.4.1/src/core/tcp_out.c **** }
 2949              		.loc 1 1402 0
 2950 005e 1437     		adds	r7, r7, #20
 2951              		.cfi_def_cfa_offset 12
 2952 0060 BD46     		mov	sp, r7
 2953              		.cfi_def_cfa_register 13
 2954              		@ sp needed
 2955 0062 90BD     		pop	{r4, r7, pc}
 2956              	.L171:
 2957              		.align	2
 2958              	.L170:
 2959 0064 00000000 		.word	lwip_stats
 2960              		.cfi_endproc
 2961              	.LFE14:
 2963              		.section	.text.tcp_zero_window_probe,"ax",%progbits
 2964              		.align	2
 2965              		.global	tcp_zero_window_probe
 2966              		.thumb
 2967              		.thumb_func
 2969              	tcp_zero_window_probe:
 2970              	.LFB15:
1403:../lwip-1.4.1/src/core/tcp_out.c **** 
1404:../lwip-1.4.1/src/core/tcp_out.c **** 
1405:../lwip-1.4.1/src/core/tcp_out.c **** /**
1406:../lwip-1.4.1/src/core/tcp_out.c ****  * Send persist timer zero-window probes to keep a connection active
1407:../lwip-1.4.1/src/core/tcp_out.c ****  * when a window update is lost.
1408:../lwip-1.4.1/src/core/tcp_out.c ****  *
1409:../lwip-1.4.1/src/core/tcp_out.c ****  * Called by tcp_slowtmr()
1410:../lwip-1.4.1/src/core/tcp_out.c ****  *
1411:../lwip-1.4.1/src/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to send a zero-window probe packet
1412:../lwip-1.4.1/src/core/tcp_out.c ****  */
1413:../lwip-1.4.1/src/core/tcp_out.c **** void
1414:../lwip-1.4.1/src/core/tcp_out.c **** tcp_zero_window_probe(struct tcp_pcb *pcb)
1415:../lwip-1.4.1/src/core/tcp_out.c **** {
 2971              		.loc 1 1415 0
 2972              		.cfi_startproc
 2973              		@ args = 0, pretend = 0, frame = 32
 2974              		@ frame_needed = 1, uses_anonymous_args = 0
 2975 0000 90B5     		push	{r4, r7, lr}
 2976              		.cfi_def_cfa_offset 12
 2977              		.cfi_offset 4, -12
 2978              		.cfi_offset 7, -8
 2979              		.cfi_offset 14, -4
 2980 0002 8BB0     		sub	sp, sp, #44
 2981              		.cfi_def_cfa_offset 56
 2982 0004 02AF     		add	r7, sp, #8
 2983              		.cfi_def_cfa 7, 48
 2984 0006 7860     		str	r0, [r7, #4]
1416:../lwip-1.4.1/src/core/tcp_out.c ****   struct pbuf *p;
1417:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
1418:../lwip-1.4.1/src/core/tcp_out.c ****   struct tcp_seg *seg;
1419:../lwip-1.4.1/src/core/tcp_out.c ****   u16_t len;
1420:../lwip-1.4.1/src/core/tcp_out.c ****   u8_t is_fin;
1421:../lwip-1.4.1/src/core/tcp_out.c **** 
1422:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, 
1423:../lwip-1.4.1/src/core/tcp_out.c ****               ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
1424:../lwip-1.4.1/src/core/tcp_out.c ****                U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
1425:../lwip-1.4.1/src/core/tcp_out.c ****                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
1426:../lwip-1.4.1/src/core/tcp_out.c ****                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
1427:../lwip-1.4.1/src/core/tcp_out.c **** 
1428:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, 
1429:../lwip-1.4.1/src/core/tcp_out.c ****               ("tcp_zero_window_probe: tcp_ticks %"U32_F
1430:../lwip-1.4.1/src/core/tcp_out.c ****                "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
1431:../lwip-1.4.1/src/core/tcp_out.c ****                tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
1432:../lwip-1.4.1/src/core/tcp_out.c **** 
1433:../lwip-1.4.1/src/core/tcp_out.c ****   seg = pcb->unacked;
 2985              		.loc 1 1433 0
 2986 0008 7B68     		ldr	r3, [r7, #4]
 2987 000a 1B6F     		ldr	r3, [r3, #112]
 2988 000c FB61     		str	r3, [r7, #28]
1434:../lwip-1.4.1/src/core/tcp_out.c **** 
1435:../lwip-1.4.1/src/core/tcp_out.c ****   if(seg == NULL) {
 2989              		.loc 1 1435 0
 2990 000e FB69     		ldr	r3, [r7, #28]
 2991 0010 002B     		cmp	r3, #0
 2992 0012 02D1     		bne	.L173
1436:../lwip-1.4.1/src/core/tcp_out.c ****     seg = pcb->unsent;
 2993              		.loc 1 1436 0
 2994 0014 7B68     		ldr	r3, [r7, #4]
 2995 0016 DB6E     		ldr	r3, [r3, #108]
 2996 0018 FB61     		str	r3, [r7, #28]
 2997              	.L173:
1437:../lwip-1.4.1/src/core/tcp_out.c ****   }
1438:../lwip-1.4.1/src/core/tcp_out.c ****   if(seg == NULL) {
 2998              		.loc 1 1438 0
 2999 001a FB69     		ldr	r3, [r7, #28]
 3000 001c 002B     		cmp	r3, #0
 3001 001e 00D1     		bne	.L174
1439:../lwip-1.4.1/src/core/tcp_out.c ****     return;
 3002              		.loc 1 1439 0
 3003 0020 69E0     		b	.L172
 3004              	.L174:
1440:../lwip-1.4.1/src/core/tcp_out.c ****   }
1441:../lwip-1.4.1/src/core/tcp_out.c **** 
1442:../lwip-1.4.1/src/core/tcp_out.c ****   is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 3005              		.loc 1 1442 0
 3006 0022 FB69     		ldr	r3, [r7, #28]
 3007 0024 1B69     		ldr	r3, [r3, #16]
 3008 0026 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 3009 0028 9BB2     		uxth	r3, r3
 3010 002a 1846     		mov	r0, r3
 3011 002c FFF7FEFF 		bl	lwip_ntohs
 3012 0030 0346     		mov	r3, r0
 3013 0032 03F00103 		and	r3, r3, #1
 3014 0036 002B     		cmp	r3, #0
 3015 0038 05D0     		beq	.L176
 3016              		.loc 1 1442 0 is_stmt 0 discriminator 1
 3017 003a FB69     		ldr	r3, [r7, #28]
 3018 003c 1B89     		ldrh	r3, [r3, #8]
 3019 003e 002B     		cmp	r3, #0
 3020 0040 01D1     		bne	.L176
 3021              		.loc 1 1442 0 discriminator 3
 3022 0042 0123     		movs	r3, #1
 3023 0044 00E0     		b	.L177
 3024              	.L176:
 3025              		.loc 1 1442 0 discriminator 4
 3026 0046 0023     		movs	r3, #0
 3027              	.L177:
 3028              		.loc 1 1442 0 discriminator 6
 3029 0048 FB76     		strb	r3, [r7, #27]
1443:../lwip-1.4.1/src/core/tcp_out.c ****   /* we want to send one seqno: either FIN or data (no options) */
1444:../lwip-1.4.1/src/core/tcp_out.c ****   len = is_fin ? 0 : 1;
 3030              		.loc 1 1444 0 is_stmt 1 discriminator 6
 3031 004a FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 3032 004c 002B     		cmp	r3, #0
 3033 004e 0CBF     		ite	eq
 3034 0050 0123     		moveq	r3, #1
 3035 0052 0023     		movne	r3, #0
 3036 0054 DBB2     		uxtb	r3, r3
 3037 0056 3B83     		strh	r3, [r7, #24]	@ movhi
1445:../lwip-1.4.1/src/core/tcp_out.c **** 
1446:../lwip-1.4.1/src/core/tcp_out.c ****   p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 3038              		.loc 1 1446 0 discriminator 6
 3039 0058 FB69     		ldr	r3, [r7, #28]
 3040 005a 1B69     		ldr	r3, [r3, #16]
 3041 005c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3042 005e 3A8B     		ldrh	r2, [r7, #24]
 3043 0060 7868     		ldr	r0, [r7, #4]
 3044 0062 0021     		movs	r1, #0
 3045 0064 FFF7FEFF 		bl	tcp_output_alloc_header
 3046 0068 7861     		str	r0, [r7, #20]
1447:../lwip-1.4.1/src/core/tcp_out.c ****   if(p == NULL) {
 3047              		.loc 1 1447 0 discriminator 6
 3048 006a 7B69     		ldr	r3, [r7, #20]
 3049 006c 002B     		cmp	r3, #0
 3050 006e 00D1     		bne	.L178
1448:../lwip-1.4.1/src/core/tcp_out.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
1449:../lwip-1.4.1/src/core/tcp_out.c ****     return;
 3051              		.loc 1 1449 0 discriminator 5
 3052 0070 41E0     		b	.L172
 3053              	.L178:
1450:../lwip-1.4.1/src/core/tcp_out.c ****   }
1451:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr = (struct tcp_hdr *)p->payload;
 3054              		.loc 1 1451 0
 3055 0072 7B69     		ldr	r3, [r7, #20]
 3056 0074 5B68     		ldr	r3, [r3, #4]
 3057 0076 3B61     		str	r3, [r7, #16]
1452:../lwip-1.4.1/src/core/tcp_out.c **** 
1453:../lwip-1.4.1/src/core/tcp_out.c ****   if (is_fin) {
 3058              		.loc 1 1453 0
 3059 0078 FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 3060 007a 002B     		cmp	r3, #0
 3061 007c 12D0     		beq	.L179
1454:../lwip-1.4.1/src/core/tcp_out.c ****     /* FIN segment, no data */
1455:../lwip-1.4.1/src/core/tcp_out.c ****     TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 3062              		.loc 1 1455 0
 3063 007e 3B69     		ldr	r3, [r7, #16]
 3064 0080 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 3065 0082 9BB2     		uxth	r3, r3
 3066 0084 9BB2     		uxth	r3, r3
 3067 0086 23F47C53 		bic	r3, r3, #16128
 3068 008a 9CB2     		uxth	r4, r3
 3069 008c 1120     		movs	r0, #17
 3070 008e FFF7FEFF 		bl	lwip_htons
 3071 0092 0346     		mov	r3, r0
 3072 0094 9BB2     		uxth	r3, r3
 3073 0096 2246     		mov	r2, r4	@ movhi
 3074 0098 1343     		orrs	r3, r3, r2
 3075 009a 9BB2     		uxth	r3, r3
 3076 009c 9AB2     		uxth	r2, r3
 3077 009e 3B69     		ldr	r3, [r7, #16]
 3078 00a0 9A81     		strh	r2, [r3, #12]	@ unaligned
 3079 00a2 11E0     		b	.L180
 3080              	.L179:
 3081              	.LBB11:
1456:../lwip-1.4.1/src/core/tcp_out.c ****   } else {
1457:../lwip-1.4.1/src/core/tcp_out.c ****     /* Data segment, copy in one byte from the head of the unacked queue */
1458:../lwip-1.4.1/src/core/tcp_out.c ****     char *d = ((char *)p->payload + TCP_HLEN);
 3082              		.loc 1 1458 0
 3083 00a4 7B69     		ldr	r3, [r7, #20]
 3084 00a6 5B68     		ldr	r3, [r3, #4]
 3085 00a8 1433     		adds	r3, r3, #20
 3086 00aa FB60     		str	r3, [r7, #12]
1459:../lwip-1.4.1/src/core/tcp_out.c ****     /* Depending on whether the segment has already been sent (unacked) or not
1460:../lwip-1.4.1/src/core/tcp_out.c ****        (unsent), seg->p->payload points to the IP header or TCP header.
1461:../lwip-1.4.1/src/core/tcp_out.c ****        Ensure we copy the first TCP data byte: */
1462:../lwip-1.4.1/src/core/tcp_out.c ****     pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 3087              		.loc 1 1462 0
 3088 00ac FB69     		ldr	r3, [r7, #28]
 3089 00ae 5968     		ldr	r1, [r3, #4]
 3090 00b0 FB69     		ldr	r3, [r7, #28]
 3091 00b2 5B68     		ldr	r3, [r3, #4]
 3092 00b4 1A89     		ldrh	r2, [r3, #8]
 3093 00b6 FB69     		ldr	r3, [r7, #28]
 3094 00b8 1B89     		ldrh	r3, [r3, #8]
 3095 00ba D31A     		subs	r3, r2, r3
 3096 00bc 9BB2     		uxth	r3, r3
 3097 00be 0846     		mov	r0, r1
 3098 00c0 F968     		ldr	r1, [r7, #12]
 3099 00c2 0122     		movs	r2, #1
 3100 00c4 FFF7FEFF 		bl	pbuf_copy_partial
 3101              	.L180:
 3102              	.LBE11:
1463:../lwip-1.4.1/src/core/tcp_out.c ****   }
1464:../lwip-1.4.1/src/core/tcp_out.c **** 
1465:../lwip-1.4.1/src/core/tcp_out.c **** #if CHECKSUM_GEN_TCP
1466:../lwip-1.4.1/src/core/tcp_out.c ****   tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
1467:../lwip-1.4.1/src/core/tcp_out.c ****                                       IP_PROTO_TCP, p->tot_len);
1468:../lwip-1.4.1/src/core/tcp_out.c **** #endif
1469:../lwip-1.4.1/src/core/tcp_out.c ****   TCP_STATS_INC(tcp.xmit);
 3103              		.loc 1 1469 0
 3104 00c8 0C4B     		ldr	r3, .L181
 3105 00ca D3F82031 		ldr	r3, [r3, #288]
 3106 00ce 0133     		adds	r3, r3, #1
 3107 00d0 0A4A     		ldr	r2, .L181
 3108 00d2 C2F82031 		str	r3, [r2, #288]
1470:../lwip-1.4.1/src/core/tcp_out.c **** 
1471:../lwip-1.4.1/src/core/tcp_out.c ****   /* Send output to IP */
1472:../lwip-1.4.1/src/core/tcp_out.c **** #if LWIP_NETIF_HWADDRHINT
1473:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
1474:../lwip-1.4.1/src/core/tcp_out.c ****     &(pcb->addr_hint));
1475:../lwip-1.4.1/src/core/tcp_out.c **** #else /* LWIP_NETIF_HWADDRHINT*/
1476:../lwip-1.4.1/src/core/tcp_out.c ****   ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 3109              		.loc 1 1476 0
 3110 00d6 7968     		ldr	r1, [r7, #4]
 3111 00d8 7B68     		ldr	r3, [r7, #4]
 3112 00da 1A1D     		adds	r2, r3, #4
 3113 00dc 7B68     		ldr	r3, [r7, #4]
 3114 00de 9C7A     		ldrb	r4, [r3, #10]	@ zero_extendqisi2
 3115 00e0 0023     		movs	r3, #0
 3116 00e2 0093     		str	r3, [sp]
 3117 00e4 0623     		movs	r3, #6
 3118 00e6 0193     		str	r3, [sp, #4]
 3119 00e8 7869     		ldr	r0, [r7, #20]
 3120 00ea 2346     		mov	r3, r4
 3121 00ec FFF7FEFF 		bl	ip_output
1477:../lwip-1.4.1/src/core/tcp_out.c **** #endif /* LWIP_NETIF_HWADDRHINT*/
1478:../lwip-1.4.1/src/core/tcp_out.c **** 
1479:../lwip-1.4.1/src/core/tcp_out.c ****   pbuf_free(p);
 3122              		.loc 1 1479 0
 3123 00f0 7869     		ldr	r0, [r7, #20]
 3124 00f2 FFF7FEFF 		bl	pbuf_free
 3125              	.L172:
1480:../lwip-1.4.1/src/core/tcp_out.c **** 
1481:../lwip-1.4.1/src/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
1482:../lwip-1.4.1/src/core/tcp_out.c ****                           " ackno %"U32_F".\n",
1483:../lwip-1.4.1/src/core/tcp_out.c ****                           pcb->snd_nxt - 1, pcb->rcv_nxt));
1484:../lwip-1.4.1/src/core/tcp_out.c **** }
 3126              		.loc 1 1484 0
 3127 00f6 2437     		adds	r7, r7, #36
 3128              		.cfi_def_cfa_offset 12
 3129 00f8 BD46     		mov	sp, r7
 3130              		.cfi_def_cfa_register 13
 3131              		@ sp needed
 3132 00fa 90BD     		pop	{r4, r7, pc}
 3133              	.L182:
 3134              		.align	2
 3135              	.L181:
 3136 00fc 00000000 		.word	lwip_stats
 3137              		.cfi_endproc
 3138              	.LFE15:
 3140              		.text
 3141              	.Letext0:
 3142              		.file 2 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\port/arch/cc.h"
 3143              		.file 3 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/mem.h"
 3144              		.file 4 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/err.h"
 3145              		.file 5 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/pbuf.h
 3146              		.file 6 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip/
 3147              		.file 7 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/netif.
 3148              		.file 8 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/tcp.h"
 3149              		.file 9 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/tcp_im
 3150              		.file 10 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/memp.
 3151              		.file 11 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/stats
DEFINED SYMBOLS
                            *ABS*:00000000 tcp_out.c
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:19     .text.tcp_output_alloc_header:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:23     .text.tcp_output_alloc_header:00000000 tcp_output_alloc_header
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:154    .text.tcp_send_fin:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:159    .text.tcp_send_fin:00000000 tcp_send_fin
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1424   .text.tcp_enqueue_flags:00000000 tcp_enqueue_flags
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:253    .text.tcp_create_segment:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:257    .text.tcp_create_segment:00000000 tcp_create_segment
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:433    .text.tcp_create_segment:00000118 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:438    .text.tcp_pbuf_prealloc:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:442    .text.tcp_pbuf_prealloc:00000000 tcp_pbuf_prealloc
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:557    .text.tcp_write_checks:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:561    .text.tcp_write_checks:00000000 tcp_write_checks
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:693    .text.tcp_write_checks:000000b8 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:698    .text.tcp_write:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:703    .text.tcp_write:00000000 tcp_write
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1414   .text.tcp_write:00000484 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1419   .text.tcp_enqueue_flags:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1702   .text.tcp_enqueue_flags:000001c4 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1707   .text.tcp_send_empty_ack:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1712   .text.tcp_send_empty_ack:00000000 tcp_send_empty_ack
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1796   .text.tcp_output:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:1801   .text.tcp_output:00000000 tcp_output
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2228   .text.tcp_output_segment:00000000 tcp_output_segment
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2158   .text.tcp_output:00000244 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2161   .text.tcp_output:00000248 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2224   .text.tcp_output_segment:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2439   .text.tcp_output_segment:00000154 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2445   .text.tcp_rst:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2450   .text.tcp_rst:00000000 tcp_rst
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2570   .text.tcp_rst:000000c4 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2575   .text.tcp_rexmit_rto:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2580   .text.tcp_rexmit_rto:00000000 tcp_rexmit_rto
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2659   .text.tcp_rexmit:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2664   .text.tcp_rexmit:00000000 tcp_rexmit
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2775   .text.tcp_rexmit_fast:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2780   .text.tcp_rexmit_fast:00000000 tcp_rexmit_fast
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2882   .text.tcp_keepalive:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2887   .text.tcp_keepalive:00000000 tcp_keepalive
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2959   .text.tcp_keepalive:00000064 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2964   .text.tcp_zero_window_probe:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:2969   .text.tcp_zero_window_probe:00000000 tcp_zero_window_probe
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccy1TSIX.s:3136   .text.tcp_zero_window_probe:000000fc $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.2d80f1b5ce3c69d13e258577ddf29668
                           .group:00000000 wm4.lwipopts.h.25.76e03deb318fbe54d896a83c1b611e55
                           .group:00000000 wm4.arch.h.33.6fa4aa86d33d1490ae882caef7316405
                           .group:00000000 wm4.cpu.h.33.0ec64ad8cd52614da6479c7936fa3efa
                           .group:00000000 wm4.cc.h.49.217a0c46a6dd8448cb36cccbf00f897f
                           .group:00000000 wm4.arch.h.52.2e97dbd839a1aa815d8c47878a7f8e2b
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.24.b2be5f53932a9c9d07787288b29b6d75
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.82.82b71f3f44c70e3a459d0f66642b05eb
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.68.ff6d7571d3ad75c55f15e26dbaa81e35
                           .group:00000000 wm4.debug.h.45.223028a5c052c9f879ffd43dd519f3f1
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.opt.h.76.0e16bb9c23144e1f631b5b5afa9a69f6
                           .group:00000000 wm4.mem.h.33.ae21028c0b1f3dc3305003fc71edaf5a
                           .group:00000000 wm4.err.h.33.909ff4b35439192d64931f0a04fc8fdb
                           .group:00000000 wm4.pbuf.h.45.444f43edbf93d1b2ead9ba1554355b0e
                           .group:00000000 wm4.def.h.33.d4208c3cd3e0fc64e20a8b9f95a681f3
                           .group:00000000 wm4.ip_addr.h.33.906726af218ee6749c0aa25e08c3a1fe
                           .group:00000000 wm4.netif.h.33.f0b62f0135b4c001826f0908df525042
                           .group:00000000 wm4.ip.h.48.c2e3a3e3a9e009c03a30eff6a88b0a33
                           .group:00000000 wm4.icmp.h.33.9c8da59f6edf08fae1a2f37336a6e965
                           .group:00000000 wm4.tcp.h.148.20c69d62fcb119a5d6bfd32bc982e4fb
                           .group:00000000 wm4.tcp_impl.h.84.6e9c66479f429d69332d497d793a73a6
                           .group:00000000 wm4.memp.h.34.a409f52ec6d44b5681de26eb10b0c08b
                           .group:00000000 wm4.memp_std.h.15.637bb4287b70e9d70dbd8dd3c6f62f3b
                           .group:00000000 wm4.inet_chksum.h.33.8f33e706cb8ab6b406ce83637c67c459
                           .group:00000000 wm4.stats.h.33.e4d36fe09c96bf9e2f10f7a27b9fa99f
                           .group:00000000 wm4.snmp.h.34.65cd272594ba53b669353bfbd8cfaef5

UNDEFINED SYMBOLS
pbuf_alloc
lwip_htons
lwip_htonl
lwip_ntohs
memp_malloc
pbuf_free
pbuf_header
tcp_seg_free
lwip_stats
memcpy
pbuf_clen
pbuf_cat
tcp_segs_free
ip_output
lwip_ntohl
tcp_input_pcb
tcp_eff_send_mss
ip_route
tcp_ticks
pbuf_copy_partial
