   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"udp.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.data
  19              		.align	1
  22              	udp_port:
  23 0000 00C0     		.short	-16384
  24              		.comm	udp_pcbs,4,4
  25              		.section	.text.udp_init,"ax",%progbits
  26              		.align	2
  27              		.global	udp_init
  28              		.thumb
  29              		.thumb_func
  31              	udp_init:
  32              	.LFB0:
  33              		.file 1 "../lwip-1.4.1/src/core/udp.c"
   1:../lwip-1.4.1/src/core/udp.c **** /**
   2:../lwip-1.4.1/src/core/udp.c ****  * @file
   3:../lwip-1.4.1/src/core/udp.c ****  * User Datagram Protocol module
   4:../lwip-1.4.1/src/core/udp.c ****  *
   5:../lwip-1.4.1/src/core/udp.c ****  */
   6:../lwip-1.4.1/src/core/udp.c **** 
   7:../lwip-1.4.1/src/core/udp.c **** /*
   8:../lwip-1.4.1/src/core/udp.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
   9:../lwip-1.4.1/src/core/udp.c ****  * All rights reserved.
  10:../lwip-1.4.1/src/core/udp.c ****  *
  11:../lwip-1.4.1/src/core/udp.c ****  * Redistribution and use in source and binary forms, with or without modification,
  12:../lwip-1.4.1/src/core/udp.c ****  * are permitted provided that the following conditions are met:
  13:../lwip-1.4.1/src/core/udp.c ****  *
  14:../lwip-1.4.1/src/core/udp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  15:../lwip-1.4.1/src/core/udp.c ****  *    this list of conditions and the following disclaimer.
  16:../lwip-1.4.1/src/core/udp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  17:../lwip-1.4.1/src/core/udp.c ****  *    this list of conditions and the following disclaimer in the documentation
  18:../lwip-1.4.1/src/core/udp.c ****  *    and/or other materials provided with the distribution.
  19:../lwip-1.4.1/src/core/udp.c ****  * 3. The name of the author may not be used to endorse or promote products
  20:../lwip-1.4.1/src/core/udp.c ****  *    derived from this software without specific prior written permission.
  21:../lwip-1.4.1/src/core/udp.c ****  *
  22:../lwip-1.4.1/src/core/udp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  23:../lwip-1.4.1/src/core/udp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  24:../lwip-1.4.1/src/core/udp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  25:../lwip-1.4.1/src/core/udp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  26:../lwip-1.4.1/src/core/udp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  27:../lwip-1.4.1/src/core/udp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:../lwip-1.4.1/src/core/udp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:../lwip-1.4.1/src/core/udp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  30:../lwip-1.4.1/src/core/udp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  31:../lwip-1.4.1/src/core/udp.c ****  * OF SUCH DAMAGE.
  32:../lwip-1.4.1/src/core/udp.c ****  *
  33:../lwip-1.4.1/src/core/udp.c ****  * This file is part of the lwIP TCP/IP stack.
  34:../lwip-1.4.1/src/core/udp.c ****  *
  35:../lwip-1.4.1/src/core/udp.c ****  * Author: Adam Dunkels <adam@sics.se>
  36:../lwip-1.4.1/src/core/udp.c ****  *
  37:../lwip-1.4.1/src/core/udp.c ****  */
  38:../lwip-1.4.1/src/core/udp.c **** 
  39:../lwip-1.4.1/src/core/udp.c **** 
  40:../lwip-1.4.1/src/core/udp.c **** /* udp.c
  41:../lwip-1.4.1/src/core/udp.c ****  *
  42:../lwip-1.4.1/src/core/udp.c ****  * The code for the User Datagram Protocol UDP & UDPLite (RFC 3828).
  43:../lwip-1.4.1/src/core/udp.c ****  *
  44:../lwip-1.4.1/src/core/udp.c ****  */
  45:../lwip-1.4.1/src/core/udp.c **** 
  46:../lwip-1.4.1/src/core/udp.c **** /* @todo Check the use of '(struct udp_pcb).chksum_len_rx'!
  47:../lwip-1.4.1/src/core/udp.c ****  */
  48:../lwip-1.4.1/src/core/udp.c **** 
  49:../lwip-1.4.1/src/core/udp.c **** #include "lwip/opt.h"
  50:../lwip-1.4.1/src/core/udp.c **** 
  51:../lwip-1.4.1/src/core/udp.c **** #if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
  52:../lwip-1.4.1/src/core/udp.c **** 
  53:../lwip-1.4.1/src/core/udp.c **** #include "lwip/udp.h"
  54:../lwip-1.4.1/src/core/udp.c **** #include "lwip/def.h"
  55:../lwip-1.4.1/src/core/udp.c **** #include "lwip/memp.h"
  56:../lwip-1.4.1/src/core/udp.c **** #include "lwip/inet_chksum.h"
  57:../lwip-1.4.1/src/core/udp.c **** #include "lwip/ip_addr.h"
  58:../lwip-1.4.1/src/core/udp.c **** #include "lwip/netif.h"
  59:../lwip-1.4.1/src/core/udp.c **** #include "lwip/icmp.h"
  60:../lwip-1.4.1/src/core/udp.c **** #include "lwip/stats.h"
  61:../lwip-1.4.1/src/core/udp.c **** #include "lwip/snmp.h"
  62:../lwip-1.4.1/src/core/udp.c **** #include "arch/perf.h"
  63:../lwip-1.4.1/src/core/udp.c **** #include "lwip/dhcp.h"
  64:../lwip-1.4.1/src/core/udp.c **** 
  65:../lwip-1.4.1/src/core/udp.c **** #include <string.h>
  66:../lwip-1.4.1/src/core/udp.c **** 
  67:../lwip-1.4.1/src/core/udp.c **** #ifndef UDP_LOCAL_PORT_RANGE_START
  68:../lwip-1.4.1/src/core/udp.c **** /* From http://www.iana.org/assignments/port-numbers:
  69:../lwip-1.4.1/src/core/udp.c ****    "The Dynamic and/or Private Ports are those from 49152 through 65535" */
  70:../lwip-1.4.1/src/core/udp.c **** #define UDP_LOCAL_PORT_RANGE_START  0xc000
  71:../lwip-1.4.1/src/core/udp.c **** #define UDP_LOCAL_PORT_RANGE_END    0xffff
  72:../lwip-1.4.1/src/core/udp.c **** #define UDP_ENSURE_LOCAL_PORT_RANGE(port) (((port) & ~UDP_LOCAL_PORT_RANGE_START) + UDP_LOCAL_PORT_
  73:../lwip-1.4.1/src/core/udp.c **** #endif
  74:../lwip-1.4.1/src/core/udp.c **** 
  75:../lwip-1.4.1/src/core/udp.c **** /* last local UDP port */
  76:../lwip-1.4.1/src/core/udp.c **** static u16_t udp_port = UDP_LOCAL_PORT_RANGE_START;
  77:../lwip-1.4.1/src/core/udp.c **** 
  78:../lwip-1.4.1/src/core/udp.c **** /* The list of UDP PCBs */
  79:../lwip-1.4.1/src/core/udp.c **** /* exported in udp.h (was static) */
  80:../lwip-1.4.1/src/core/udp.c **** struct udp_pcb *udp_pcbs;
  81:../lwip-1.4.1/src/core/udp.c **** 
  82:../lwip-1.4.1/src/core/udp.c **** /**
  83:../lwip-1.4.1/src/core/udp.c ****  * Initialize this module.
  84:../lwip-1.4.1/src/core/udp.c ****  */
  85:../lwip-1.4.1/src/core/udp.c **** void
  86:../lwip-1.4.1/src/core/udp.c **** udp_init(void)
  87:../lwip-1.4.1/src/core/udp.c **** {
  34              		.loc 1 87 0
  35              		.cfi_startproc
  36              		@ args = 0, pretend = 0, frame = 0
  37              		@ frame_needed = 1, uses_anonymous_args = 0
  38              		@ link register save eliminated.
  39 0000 80B4     		push	{r7}
  40              		.cfi_def_cfa_offset 4
  41              		.cfi_offset 7, -4
  42 0002 00AF     		add	r7, sp, #0
  43              		.cfi_def_cfa_register 7
  88:../lwip-1.4.1/src/core/udp.c **** #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  89:../lwip-1.4.1/src/core/udp.c ****   udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
  90:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
  91:../lwip-1.4.1/src/core/udp.c **** }
  44              		.loc 1 91 0
  45 0004 BD46     		mov	sp, r7
  46              		.cfi_def_cfa_register 13
  47              		@ sp needed
  48 0006 5DF8047B 		ldr	r7, [sp], #4
  49              		.cfi_restore 7
  50              		.cfi_def_cfa_offset 0
  51 000a 7047     		bx	lr
  52              		.cfi_endproc
  53              	.LFE0:
  55              		.section	.text.udp_new_port,"ax",%progbits
  56              		.align	2
  57              		.thumb
  58              		.thumb_func
  60              	udp_new_port:
  61              	.LFB1:
  92:../lwip-1.4.1/src/core/udp.c **** 
  93:../lwip-1.4.1/src/core/udp.c **** /**
  94:../lwip-1.4.1/src/core/udp.c ****  * Allocate a new local UDP port.
  95:../lwip-1.4.1/src/core/udp.c ****  *
  96:../lwip-1.4.1/src/core/udp.c ****  * @return a new (free) local UDP port number
  97:../lwip-1.4.1/src/core/udp.c ****  */
  98:../lwip-1.4.1/src/core/udp.c **** static u16_t
  99:../lwip-1.4.1/src/core/udp.c **** udp_new_port(void)
 100:../lwip-1.4.1/src/core/udp.c **** {
  62              		.loc 1 100 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 1, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67 0000 80B4     		push	{r7}
  68              		.cfi_def_cfa_offset 4
  69              		.cfi_offset 7, -4
  70 0002 83B0     		sub	sp, sp, #12
  71              		.cfi_def_cfa_offset 16
  72 0004 00AF     		add	r7, sp, #0
  73              		.cfi_def_cfa_register 7
 101:../lwip-1.4.1/src/core/udp.c ****   u16_t n = 0;
  74              		.loc 1 101 0
  75 0006 0023     		movs	r3, #0
  76 0008 FB80     		strh	r3, [r7, #6]	@ movhi
  77              	.L3:
 102:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *pcb;
 103:../lwip-1.4.1/src/core/udp.c ****   
 104:../lwip-1.4.1/src/core/udp.c **** again:
 105:../lwip-1.4.1/src/core/udp.c ****   if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
  78              		.loc 1 105 0
  79 000a 184B     		ldr	r3, .L10
  80 000c 1B88     		ldrh	r3, [r3]
  81 000e 5A1C     		adds	r2, r3, #1
  82 0010 91B2     		uxth	r1, r2
  83 0012 164A     		ldr	r2, .L10
  84 0014 1180     		strh	r1, [r2]	@ movhi
  85 0016 4FF6FF72 		movw	r2, #65535
  86 001a 9342     		cmp	r3, r2
  87 001c 03D1     		bne	.L4
 106:../lwip-1.4.1/src/core/udp.c ****     udp_port = UDP_LOCAL_PORT_RANGE_START;
  88              		.loc 1 106 0
  89 001e 134B     		ldr	r3, .L10
  90 0020 4FF44042 		mov	r2, #49152
  91 0024 1A80     		strh	r2, [r3]	@ movhi
  92              	.L4:
 107:../lwip-1.4.1/src/core/udp.c ****   }
 108:../lwip-1.4.1/src/core/udp.c ****   /* Check all PCBs. */
 109:../lwip-1.4.1/src/core/udp.c ****   for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  93              		.loc 1 109 0
  94 0026 124B     		ldr	r3, .L10+4
  95 0028 1B68     		ldr	r3, [r3]
  96 002a 3B60     		str	r3, [r7]
  97 002c 12E0     		b	.L5
  98              	.L9:
 110:../lwip-1.4.1/src/core/udp.c ****     if (pcb->local_port == udp_port) {
  99              		.loc 1 110 0
 100 002e 3B68     		ldr	r3, [r7]
 101 0030 5A8A     		ldrh	r2, [r3, #18]
 102 0032 0E4B     		ldr	r3, .L10
 103 0034 1B88     		ldrh	r3, [r3]
 104 0036 9A42     		cmp	r2, r3
 105 0038 09D1     		bne	.L6
 111:../lwip-1.4.1/src/core/udp.c ****       if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 106              		.loc 1 111 0
 107 003a FB88     		ldrh	r3, [r7, #6]	@ movhi
 108 003c 0133     		adds	r3, r3, #1
 109 003e FB80     		strh	r3, [r7, #6]	@ movhi
 110 0040 FB88     		ldrh	r3, [r7, #6]
 111 0042 B3F5804F 		cmp	r3, #16384
 112 0046 01D3     		bcc	.L7
 112:../lwip-1.4.1/src/core/udp.c ****         return 0;
 113              		.loc 1 112 0
 114 0048 0023     		movs	r3, #0
 115 004a 08E0     		b	.L8
 116              	.L7:
 113:../lwip-1.4.1/src/core/udp.c ****       }
 114:../lwip-1.4.1/src/core/udp.c ****       goto again;
 117              		.loc 1 114 0
 118 004c DDE7     		b	.L3
 119              	.L6:
 109:../lwip-1.4.1/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 120              		.loc 1 109 0 discriminator 2
 121 004e 3B68     		ldr	r3, [r7]
 122 0050 DB68     		ldr	r3, [r3, #12]
 123 0052 3B60     		str	r3, [r7]
 124              	.L5:
 109:../lwip-1.4.1/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 125              		.loc 1 109 0 is_stmt 0 discriminator 1
 126 0054 3B68     		ldr	r3, [r7]
 127 0056 002B     		cmp	r3, #0
 128 0058 E9D1     		bne	.L9
 115:../lwip-1.4.1/src/core/udp.c ****     }
 116:../lwip-1.4.1/src/core/udp.c ****   }
 117:../lwip-1.4.1/src/core/udp.c ****   return udp_port;
 129              		.loc 1 117 0 is_stmt 1
 130 005a 044B     		ldr	r3, .L10
 131 005c 1B88     		ldrh	r3, [r3]
 132              	.L8:
 118:../lwip-1.4.1/src/core/udp.c **** #if 0
 119:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *ipcb = udp_pcbs;
 120:../lwip-1.4.1/src/core/udp.c ****   while ((ipcb != NULL) && (udp_port != UDP_LOCAL_PORT_RANGE_END)) {
 121:../lwip-1.4.1/src/core/udp.c ****     if (ipcb->local_port == udp_port) {
 122:../lwip-1.4.1/src/core/udp.c ****       /* port is already used by another udp_pcb */
 123:../lwip-1.4.1/src/core/udp.c ****       udp_port++;
 124:../lwip-1.4.1/src/core/udp.c ****       /* restart scanning all udp pcbs */
 125:../lwip-1.4.1/src/core/udp.c ****       ipcb = udp_pcbs;
 126:../lwip-1.4.1/src/core/udp.c ****     } else {
 127:../lwip-1.4.1/src/core/udp.c ****       /* go on with next udp pcb */
 128:../lwip-1.4.1/src/core/udp.c ****       ipcb = ipcb->next;
 129:../lwip-1.4.1/src/core/udp.c ****     }
 130:../lwip-1.4.1/src/core/udp.c ****   }
 131:../lwip-1.4.1/src/core/udp.c ****   if (ipcb != NULL) {
 132:../lwip-1.4.1/src/core/udp.c ****     return 0;
 133:../lwip-1.4.1/src/core/udp.c ****   }
 134:../lwip-1.4.1/src/core/udp.c ****   return udp_port;
 135:../lwip-1.4.1/src/core/udp.c **** #endif
 136:../lwip-1.4.1/src/core/udp.c **** }
 133              		.loc 1 136 0
 134 005e 1846     		mov	r0, r3
 135 0060 0C37     		adds	r7, r7, #12
 136              		.cfi_def_cfa_offset 4
 137 0062 BD46     		mov	sp, r7
 138              		.cfi_def_cfa_register 13
 139              		@ sp needed
 140 0064 5DF8047B 		ldr	r7, [sp], #4
 141              		.cfi_restore 7
 142              		.cfi_def_cfa_offset 0
 143 0068 7047     		bx	lr
 144              	.L11:
 145 006a 00BF     		.align	2
 146              	.L10:
 147 006c 00000000 		.word	udp_port
 148 0070 00000000 		.word	udp_pcbs
 149              		.cfi_endproc
 150              	.LFE1:
 152              		.section	.text.udp_input,"ax",%progbits
 153              		.align	2
 154              		.global	udp_input
 155              		.thumb
 156              		.thumb_func
 158              	udp_input:
 159              	.LFB2:
 137:../lwip-1.4.1/src/core/udp.c **** 
 138:../lwip-1.4.1/src/core/udp.c **** /**
 139:../lwip-1.4.1/src/core/udp.c ****  * Process an incoming UDP datagram.
 140:../lwip-1.4.1/src/core/udp.c ****  *
 141:../lwip-1.4.1/src/core/udp.c ****  * Given an incoming UDP datagram (as a chain of pbufs) this function
 142:../lwip-1.4.1/src/core/udp.c ****  * finds a corresponding UDP PCB and hands over the pbuf to the pcbs
 143:../lwip-1.4.1/src/core/udp.c ****  * recv function. If no pcb is found or the datagram is incorrect, the
 144:../lwip-1.4.1/src/core/udp.c ****  * pbuf is freed.
 145:../lwip-1.4.1/src/core/udp.c ****  *
 146:../lwip-1.4.1/src/core/udp.c ****  * @param p pbuf to be demultiplexed to a UDP PCB.
 147:../lwip-1.4.1/src/core/udp.c ****  * @param inp network interface on which the datagram was received.
 148:../lwip-1.4.1/src/core/udp.c ****  *
 149:../lwip-1.4.1/src/core/udp.c ****  */
 150:../lwip-1.4.1/src/core/udp.c **** void
 151:../lwip-1.4.1/src/core/udp.c **** udp_input(struct pbuf *p, struct netif *inp)
 152:../lwip-1.4.1/src/core/udp.c **** {
 160              		.loc 1 152 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 40
 163              		@ frame_needed = 1, uses_anonymous_args = 0
 164 0000 90B5     		push	{r4, r7, lr}
 165              		.cfi_def_cfa_offset 12
 166              		.cfi_offset 4, -12
 167              		.cfi_offset 7, -8
 168              		.cfi_offset 14, -4
 169 0002 8DB0     		sub	sp, sp, #52
 170              		.cfi_def_cfa_offset 64
 171 0004 02AF     		add	r7, sp, #8
 172              		.cfi_def_cfa 7, 56
 173 0006 7860     		str	r0, [r7, #4]
 174 0008 3960     		str	r1, [r7]
 153:../lwip-1.4.1/src/core/udp.c ****   struct udp_hdr *udphdr;
 154:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *pcb, *prev;
 155:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *uncon_pcb;
 156:../lwip-1.4.1/src/core/udp.c ****   struct ip_hdr *iphdr;
 157:../lwip-1.4.1/src/core/udp.c ****   u16_t src, dest;
 158:../lwip-1.4.1/src/core/udp.c ****   u8_t local_match;
 159:../lwip-1.4.1/src/core/udp.c ****   u8_t broadcast;
 160:../lwip-1.4.1/src/core/udp.c **** 
 161:../lwip-1.4.1/src/core/udp.c ****   PERF_START;
 162:../lwip-1.4.1/src/core/udp.c **** 
 163:../lwip-1.4.1/src/core/udp.c ****   UDP_STATS_INC(udp.recv);
 175              		.loc 1 163 0
 176 000a 9B4B     		ldr	r3, .L34
 177 000c D3F8F430 		ldr	r3, [r3, #244]
 178 0010 0133     		adds	r3, r3, #1
 179 0012 994A     		ldr	r2, .L34
 180 0014 C2F8F430 		str	r3, [r2, #244]
 164:../lwip-1.4.1/src/core/udp.c **** 
 165:../lwip-1.4.1/src/core/udp.c ****   iphdr = (struct ip_hdr *)p->payload;
 181              		.loc 1 165 0
 182 0018 7B68     		ldr	r3, [r7, #4]
 183 001a 5B68     		ldr	r3, [r3, #4]
 184 001c 7B61     		str	r3, [r7, #20]
 166:../lwip-1.4.1/src/core/udp.c **** 
 167:../lwip-1.4.1/src/core/udp.c ****   /* Check minimum length (IP header + UDP header)
 168:../lwip-1.4.1/src/core/udp.c ****    * and move payload pointer to UDP header */
 169:../lwip-1.4.1/src/core/udp.c ****   if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 185              		.loc 1 169 0
 186 001e 7B68     		ldr	r3, [r7, #4]
 187 0020 1B89     		ldrh	r3, [r3, #8]
 188 0022 1A46     		mov	r2, r3
 189 0024 7B69     		ldr	r3, [r7, #20]
 190 0026 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 191 0028 03F00F03 		and	r3, r3, #15
 192 002c 0233     		adds	r3, r3, #2
 193 002e 9B00     		lsls	r3, r3, #2
 194 0030 9A42     		cmp	r2, r3
 195 0032 12DB     		blt	.L13
 196              		.loc 1 169 0 is_stmt 0 discriminator 1
 197 0034 7B69     		ldr	r3, [r7, #20]
 198 0036 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 199 0038 9BB2     		uxth	r3, r3
 200 003a 03F00F03 		and	r3, r3, #15
 201 003e 9BB2     		uxth	r3, r3
 202 0040 9B00     		lsls	r3, r3, #2
 203 0042 9BB2     		uxth	r3, r3
 204 0044 5B42     		negs	r3, r3
 205 0046 9BB2     		uxth	r3, r3
 206 0048 9BB2     		uxth	r3, r3
 207 004a 1BB2     		sxth	r3, r3
 208 004c 7868     		ldr	r0, [r7, #4]
 209 004e 1946     		mov	r1, r3
 210 0050 FFF7FEFF 		bl	pbuf_header
 211 0054 0346     		mov	r3, r0
 212 0056 002B     		cmp	r3, #0
 213 0058 11D0     		beq	.L14
 214              	.L13:
 170:../lwip-1.4.1/src/core/udp.c ****     /* drop short packets */
 171:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG,
 172:../lwip-1.4.1/src/core/udp.c ****                 ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
 173:../lwip-1.4.1/src/core/udp.c ****     UDP_STATS_INC(udp.lenerr);
 215              		.loc 1 173 0 is_stmt 1
 216 005a 874B     		ldr	r3, .L34
 217 005c D3F80431 		ldr	r3, [r3, #260]
 218 0060 0133     		adds	r3, r3, #1
 219 0062 854A     		ldr	r2, .L34
 220 0064 C2F80431 		str	r3, [r2, #260]
 174:../lwip-1.4.1/src/core/udp.c ****     UDP_STATS_INC(udp.drop);
 221              		.loc 1 174 0
 222 0068 834B     		ldr	r3, .L34
 223 006a D3F8FC30 		ldr	r3, [r3, #252]
 224 006e 0133     		adds	r3, r3, #1
 225 0070 814A     		ldr	r2, .L34
 226 0072 C2F8FC30 		str	r3, [r2, #252]
 175:../lwip-1.4.1/src/core/udp.c ****     snmp_inc_udpinerrors();
 176:../lwip-1.4.1/src/core/udp.c ****     pbuf_free(p);
 227              		.loc 1 176 0
 228 0076 7868     		ldr	r0, [r7, #4]
 229 0078 FFF7FEFF 		bl	pbuf_free
 177:../lwip-1.4.1/src/core/udp.c ****     goto end;
 230              		.loc 1 177 0
 231 007c F9E0     		b	.L12
 232              	.L14:
 178:../lwip-1.4.1/src/core/udp.c ****   }
 179:../lwip-1.4.1/src/core/udp.c **** 
 180:../lwip-1.4.1/src/core/udp.c ****   udphdr = (struct udp_hdr *)p->payload;
 233              		.loc 1 180 0
 234 007e 7B68     		ldr	r3, [r7, #4]
 235 0080 5B68     		ldr	r3, [r3, #4]
 236 0082 3B61     		str	r3, [r7, #16]
 181:../lwip-1.4.1/src/core/udp.c **** 
 182:../lwip-1.4.1/src/core/udp.c ****   /* is broadcast packet ? */
 183:../lwip-1.4.1/src/core/udp.c ****   broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 237              		.loc 1 183 0
 238 0084 7D4B     		ldr	r3, .L34+4
 239 0086 1B68     		ldr	r3, [r3]
 240 0088 1846     		mov	r0, r3
 241 008a 3968     		ldr	r1, [r7]
 242 008c FFF7FEFF 		bl	ip4_addr_isbroadcast
 243 0090 0346     		mov	r3, r0
 244 0092 FB73     		strb	r3, [r7, #15]
 184:../lwip-1.4.1/src/core/udp.c **** 
 185:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
 186:../lwip-1.4.1/src/core/udp.c **** 
 187:../lwip-1.4.1/src/core/udp.c ****   /* convert src and dest ports to host byte order */
 188:../lwip-1.4.1/src/core/udp.c ****   src = ntohs(udphdr->src);
 245              		.loc 1 188 0
 246 0094 3B69     		ldr	r3, [r7, #16]
 247 0096 1B88     		ldrh	r3, [r3]	@ unaligned
 248 0098 9BB2     		uxth	r3, r3
 249 009a 1846     		mov	r0, r3
 250 009c FFF7FEFF 		bl	lwip_ntohs
 251 00a0 0346     		mov	r3, r0
 252 00a2 BB81     		strh	r3, [r7, #12]	@ movhi
 189:../lwip-1.4.1/src/core/udp.c ****   dest = ntohs(udphdr->dest);
 253              		.loc 1 189 0
 254 00a4 3B69     		ldr	r3, [r7, #16]
 255 00a6 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 256 00a8 9BB2     		uxth	r3, r3
 257 00aa 1846     		mov	r0, r3
 258 00ac FFF7FEFF 		bl	lwip_ntohs
 259 00b0 0346     		mov	r3, r0
 260 00b2 7B81     		strh	r3, [r7, #10]	@ movhi
 190:../lwip-1.4.1/src/core/udp.c **** 
 191:../lwip-1.4.1/src/core/udp.c ****   udp_debug_print(udphdr);
 192:../lwip-1.4.1/src/core/udp.c **** 
 193:../lwip-1.4.1/src/core/udp.c ****   /* print the UDP source and destination */
 194:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG,
 195:../lwip-1.4.1/src/core/udp.c ****               ("udp (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") <-- "
 196:../lwip-1.4.1/src/core/udp.c ****                "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
 197:../lwip-1.4.1/src/core/udp.c ****                ip4_addr1_16(&iphdr->dest), ip4_addr2_16(&iphdr->dest),
 198:../lwip-1.4.1/src/core/udp.c ****                ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
 199:../lwip-1.4.1/src/core/udp.c ****                ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
 200:../lwip-1.4.1/src/core/udp.c ****                ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));
 201:../lwip-1.4.1/src/core/udp.c **** 
 202:../lwip-1.4.1/src/core/udp.c **** #if LWIP_DHCP
 203:../lwip-1.4.1/src/core/udp.c ****   pcb = NULL;
 204:../lwip-1.4.1/src/core/udp.c ****   /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
 205:../lwip-1.4.1/src/core/udp.c ****      the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
 206:../lwip-1.4.1/src/core/udp.c ****   if (dest == DHCP_CLIENT_PORT) {
 207:../lwip-1.4.1/src/core/udp.c ****     /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
 208:../lwip-1.4.1/src/core/udp.c ****     if (src == DHCP_SERVER_PORT) {
 209:../lwip-1.4.1/src/core/udp.c ****       if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
 210:../lwip-1.4.1/src/core/udp.c ****         /* accept the packe if 
 211:../lwip-1.4.1/src/core/udp.c ****            (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
 212:../lwip-1.4.1/src/core/udp.c ****            - inp->dhcp->pcb->remote == ANY or iphdr->src */
 213:../lwip-1.4.1/src/core/udp.c ****         if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 214:../lwip-1.4.1/src/core/udp.c ****            ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
 215:../lwip-1.4.1/src/core/udp.c ****           pcb = inp->dhcp->pcb;
 216:../lwip-1.4.1/src/core/udp.c ****         }
 217:../lwip-1.4.1/src/core/udp.c ****       }
 218:../lwip-1.4.1/src/core/udp.c ****     }
 219:../lwip-1.4.1/src/core/udp.c ****   } else
 220:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_DHCP */
 221:../lwip-1.4.1/src/core/udp.c ****   {
 222:../lwip-1.4.1/src/core/udp.c ****     prev = NULL;
 261              		.loc 1 222 0
 262 00b4 0023     		movs	r3, #0
 263 00b6 3B62     		str	r3, [r7, #32]
 223:../lwip-1.4.1/src/core/udp.c ****     local_match = 0;
 264              		.loc 1 223 0
 265 00b8 0023     		movs	r3, #0
 266 00ba FB76     		strb	r3, [r7, #27]
 224:../lwip-1.4.1/src/core/udp.c ****     uncon_pcb = NULL;
 267              		.loc 1 224 0
 268 00bc 0023     		movs	r3, #0
 269 00be FB61     		str	r3, [r7, #28]
 225:../lwip-1.4.1/src/core/udp.c ****     /* Iterate through the UDP pcb list for a matching pcb.
 226:../lwip-1.4.1/src/core/udp.c ****      * 'Perfect match' pcbs (connected to the remote port & ip address) are
 227:../lwip-1.4.1/src/core/udp.c ****      * preferred. If no perfect match is found, the first unconnected pcb that
 228:../lwip-1.4.1/src/core/udp.c ****      * matches the local port and ip address gets the datagram. */
 229:../lwip-1.4.1/src/core/udp.c ****     for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 270              		.loc 1 229 0
 271 00c0 6F4B     		ldr	r3, .L34+8
 272 00c2 1B68     		ldr	r3, [r3]
 273 00c4 7B62     		str	r3, [r7, #36]
 274 00c6 69E0     		b	.L16
 275              	.L25:
 230:../lwip-1.4.1/src/core/udp.c ****       local_match = 0;
 276              		.loc 1 230 0
 277 00c8 0023     		movs	r3, #0
 278 00ca FB76     		strb	r3, [r7, #27]
 231:../lwip-1.4.1/src/core/udp.c ****       /* print the PCB local and remote address */
 232:../lwip-1.4.1/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG,
 233:../lwip-1.4.1/src/core/udp.c ****                   ("pcb (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") --- "
 234:../lwip-1.4.1/src/core/udp.c ****                    "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
 235:../lwip-1.4.1/src/core/udp.c ****                    ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
 236:../lwip-1.4.1/src/core/udp.c ****                    ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
 237:../lwip-1.4.1/src/core/udp.c ****                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
 238:../lwip-1.4.1/src/core/udp.c ****                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port))
 239:../lwip-1.4.1/src/core/udp.c **** 
 240:../lwip-1.4.1/src/core/udp.c ****       /* compare PCB local addr+port to UDP destination addr+port */
 241:../lwip-1.4.1/src/core/udp.c ****       if (pcb->local_port == dest) {
 279              		.loc 1 241 0
 280 00cc 7B6A     		ldr	r3, [r7, #36]
 281 00ce 5B8A     		ldrh	r3, [r3, #18]
 282 00d0 7A89     		ldrh	r2, [r7, #10]
 283 00d2 9A42     		cmp	r2, r3
 284 00d4 30D1     		bne	.L17
 242:../lwip-1.4.1/src/core/udp.c ****         if (
 285              		.loc 1 242 0
 286 00d6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 287 00d8 002B     		cmp	r3, #0
 288 00da 06D1     		bne	.L18
 243:../lwip-1.4.1/src/core/udp.c ****            (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 289              		.loc 1 243 0
 290 00dc 7B6A     		ldr	r3, [r7, #36]
 291 00de 002B     		cmp	r3, #0
 292 00e0 1DD0     		beq	.L19
 293              		.loc 1 243 0 is_stmt 0 discriminator 1
 294 00e2 7B6A     		ldr	r3, [r7, #36]
 295 00e4 1B68     		ldr	r3, [r3]
 296 00e6 002B     		cmp	r3, #0
 297 00e8 19D0     		beq	.L19
 298              	.L18:
 244:../lwip-1.4.1/src/core/udp.c ****            ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 299              		.loc 1 244 0 is_stmt 1 discriminator 2
 300 00ea 7B6A     		ldr	r3, [r7, #36]
 301 00ec 1A68     		ldr	r2, [r3]
 302 00ee 634B     		ldr	r3, .L34+4
 303 00f0 1B68     		ldr	r3, [r3]
 243:../lwip-1.4.1/src/core/udp.c ****            (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 304              		.loc 1 243 0 discriminator 2
 305 00f2 9A42     		cmp	r2, r3
 306 00f4 13D0     		beq	.L19
 307              		.loc 1 244 0
 308 00f6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 309 00f8 002B     		cmp	r3, #0
 310 00fa 1DD0     		beq	.L17
 245:../lwip-1.4.1/src/core/udp.c **** #if LWIP_IGMP
 246:../lwip-1.4.1/src/core/udp.c ****            ip_addr_ismulticast(&current_iphdr_dest) ||
 247:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_IGMP */
 248:../lwip-1.4.1/src/core/udp.c **** #if IP_SOF_BROADCAST_RECV
 249:../lwip-1.4.1/src/core/udp.c ****             (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
 250:../lwip-1.4.1/src/core/udp.c ****              (ip_addr_isany(&pcb->local_ip) ||
 251:../lwip-1.4.1/src/core/udp.c ****               ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 252:../lwip-1.4.1/src/core/udp.c **** #else /* IP_SOF_BROADCAST_RECV */
 253:../lwip-1.4.1/src/core/udp.c ****             (broadcast &&
 254:../lwip-1.4.1/src/core/udp.c ****              (ip_addr_isany(&pcb->local_ip) ||
 311              		.loc 1 254 0
 312 00fc 7B6A     		ldr	r3, [r7, #36]
 253:../lwip-1.4.1/src/core/udp.c ****              (ip_addr_isany(&pcb->local_ip) ||
 313              		.loc 1 253 0
 314 00fe 002B     		cmp	r3, #0
 315 0100 0DD0     		beq	.L19
 316              		.loc 1 254 0
 317 0102 7B6A     		ldr	r3, [r7, #36]
 318 0104 1B68     		ldr	r3, [r3]
 319 0106 002B     		cmp	r3, #0
 320 0108 09D0     		beq	.L19
 255:../lwip-1.4.1/src/core/udp.c ****               ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 321              		.loc 1 255 0 discriminator 1
 322 010a 7B6A     		ldr	r3, [r7, #36]
 323 010c 1A68     		ldr	r2, [r3]
 324 010e 5B4B     		ldr	r3, .L34+4
 325 0110 1B68     		ldr	r3, [r3]
 326 0112 5A40     		eors	r2, r2, r3
 327 0114 3B68     		ldr	r3, [r7]
 328 0116 9B68     		ldr	r3, [r3, #8]
 329 0118 1340     		ands	r3, r3, r2
 254:../lwip-1.4.1/src/core/udp.c ****               ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 330              		.loc 1 254 0 discriminator 1
 331 011a 002B     		cmp	r3, #0
 332 011c 0CD1     		bne	.L17
 333              	.L19:
 256:../lwip-1.4.1/src/core/udp.c **** #endif /* IP_SOF_BROADCAST_RECV */ 
 257:../lwip-1.4.1/src/core/udp.c ****           local_match = 1;
 334              		.loc 1 257 0
 335 011e 0123     		movs	r3, #1
 336 0120 FB76     		strb	r3, [r7, #27]
 258:../lwip-1.4.1/src/core/udp.c ****           if ((uncon_pcb == NULL) && 
 337              		.loc 1 258 0
 338 0122 FB69     		ldr	r3, [r7, #28]
 339 0124 002B     		cmp	r3, #0
 340 0126 07D1     		bne	.L17
 259:../lwip-1.4.1/src/core/udp.c ****               ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
 341              		.loc 1 259 0 discriminator 1
 342 0128 7B6A     		ldr	r3, [r7, #36]
 343 012a 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 344 012c 03F00403 		and	r3, r3, #4
 258:../lwip-1.4.1/src/core/udp.c ****           if ((uncon_pcb == NULL) && 
 345              		.loc 1 258 0 discriminator 1
 346 0130 002B     		cmp	r3, #0
 347 0132 01D1     		bne	.L17
 260:../lwip-1.4.1/src/core/udp.c ****             /* the first unconnected matching PCB */
 261:../lwip-1.4.1/src/core/udp.c ****             uncon_pcb = pcb;
 348              		.loc 1 261 0
 349 0134 7B6A     		ldr	r3, [r7, #36]
 350 0136 FB61     		str	r3, [r7, #28]
 351              	.L17:
 262:../lwip-1.4.1/src/core/udp.c ****           }
 263:../lwip-1.4.1/src/core/udp.c ****         }
 264:../lwip-1.4.1/src/core/udp.c ****       }
 265:../lwip-1.4.1/src/core/udp.c ****       /* compare PCB remote addr+port to UDP source addr+port */
 266:../lwip-1.4.1/src/core/udp.c ****       if ((local_match != 0) &&
 352              		.loc 1 266 0
 353 0138 FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 354 013a 002B     		cmp	r3, #0
 355 013c 29D0     		beq	.L20
 267:../lwip-1.4.1/src/core/udp.c ****           (pcb->remote_port == src) &&
 356              		.loc 1 267 0 discriminator 1
 357 013e 7B6A     		ldr	r3, [r7, #36]
 358 0140 9B8A     		ldrh	r3, [r3, #20]
 266:../lwip-1.4.1/src/core/udp.c ****           (pcb->remote_port == src) &&
 359              		.loc 1 266 0 discriminator 1
 360 0142 BA89     		ldrh	r2, [r7, #12]
 361 0144 9A42     		cmp	r2, r3
 362 0146 24D1     		bne	.L20
 268:../lwip-1.4.1/src/core/udp.c ****           (ip_addr_isany(&pcb->remote_ip) ||
 363              		.loc 1 268 0
 364 0148 7B6A     		ldr	r3, [r7, #36]
 365 014a 0433     		adds	r3, r3, #4
 267:../lwip-1.4.1/src/core/udp.c ****           (pcb->remote_port == src) &&
 366              		.loc 1 267 0
 367 014c 002B     		cmp	r3, #0
 368 014e 09D0     		beq	.L21
 369              		.loc 1 268 0
 370 0150 7B6A     		ldr	r3, [r7, #36]
 371 0152 5B68     		ldr	r3, [r3, #4]
 372 0154 002B     		cmp	r3, #0
 373 0156 05D0     		beq	.L21
 269:../lwip-1.4.1/src/core/udp.c ****            ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 374              		.loc 1 269 0 discriminator 1
 375 0158 7B6A     		ldr	r3, [r7, #36]
 376 015a 5A68     		ldr	r2, [r3, #4]
 377 015c 494B     		ldr	r3, .L34+12
 378 015e 1B68     		ldr	r3, [r3]
 268:../lwip-1.4.1/src/core/udp.c ****           (ip_addr_isany(&pcb->remote_ip) ||
 379              		.loc 1 268 0 discriminator 1
 380 0160 9A42     		cmp	r2, r3
 381 0162 16D1     		bne	.L20
 382              	.L21:
 270:../lwip-1.4.1/src/core/udp.c ****         /* the first fully matching PCB */
 271:../lwip-1.4.1/src/core/udp.c ****         if (prev != NULL) {
 383              		.loc 1 271 0
 384 0164 3B6A     		ldr	r3, [r7, #32]
 385 0166 002B     		cmp	r3, #0
 386 0168 0BD0     		beq	.L22
 272:../lwip-1.4.1/src/core/udp.c ****           /* move the pcb to the front of udp_pcbs so that is
 273:../lwip-1.4.1/src/core/udp.c ****              found faster next time */
 274:../lwip-1.4.1/src/core/udp.c ****           prev->next = pcb->next;
 387              		.loc 1 274 0
 388 016a 7B6A     		ldr	r3, [r7, #36]
 389 016c DA68     		ldr	r2, [r3, #12]
 390 016e 3B6A     		ldr	r3, [r7, #32]
 391 0170 DA60     		str	r2, [r3, #12]
 275:../lwip-1.4.1/src/core/udp.c ****           pcb->next = udp_pcbs;
 392              		.loc 1 275 0
 393 0172 434B     		ldr	r3, .L34+8
 394 0174 1A68     		ldr	r2, [r3]
 395 0176 7B6A     		ldr	r3, [r7, #36]
 396 0178 DA60     		str	r2, [r3, #12]
 276:../lwip-1.4.1/src/core/udp.c ****           udp_pcbs = pcb;
 397              		.loc 1 276 0
 398 017a 414A     		ldr	r2, .L34+8
 399 017c 7B6A     		ldr	r3, [r7, #36]
 400 017e 1360     		str	r3, [r2]
 277:../lwip-1.4.1/src/core/udp.c ****         } else {
 278:../lwip-1.4.1/src/core/udp.c ****           UDP_STATS_INC(udp.cachehit);
 279:../lwip-1.4.1/src/core/udp.c ****         }
 280:../lwip-1.4.1/src/core/udp.c ****         break;
 401              		.loc 1 280 0
 402 0180 0FE0     		b	.L24
 403              	.L22:
 278:../lwip-1.4.1/src/core/udp.c ****         }
 404              		.loc 1 278 0
 405 0182 3D4B     		ldr	r3, .L34
 406 0184 D3F81C31 		ldr	r3, [r3, #284]
 407 0188 0133     		adds	r3, r3, #1
 408 018a 3B4A     		ldr	r2, .L34
 409 018c C2F81C31 		str	r3, [r2, #284]
 410              		.loc 1 280 0
 411 0190 07E0     		b	.L24
 412              	.L20:
 281:../lwip-1.4.1/src/core/udp.c ****       }
 282:../lwip-1.4.1/src/core/udp.c ****       prev = pcb;
 413              		.loc 1 282 0 discriminator 2
 414 0192 7B6A     		ldr	r3, [r7, #36]
 415 0194 3B62     		str	r3, [r7, #32]
 229:../lwip-1.4.1/src/core/udp.c ****       local_match = 0;
 416              		.loc 1 229 0 discriminator 2
 417 0196 7B6A     		ldr	r3, [r7, #36]
 418 0198 DB68     		ldr	r3, [r3, #12]
 419 019a 7B62     		str	r3, [r7, #36]
 420              	.L16:
 229:../lwip-1.4.1/src/core/udp.c ****       local_match = 0;
 421              		.loc 1 229 0 is_stmt 0 discriminator 1
 422 019c 7B6A     		ldr	r3, [r7, #36]
 423 019e 002B     		cmp	r3, #0
 424 01a0 92D1     		bne	.L25
 425              	.L24:
 283:../lwip-1.4.1/src/core/udp.c ****     }
 284:../lwip-1.4.1/src/core/udp.c ****     /* no fully matching pcb found? then look for an unconnected pcb */
 285:../lwip-1.4.1/src/core/udp.c ****     if (pcb == NULL) {
 426              		.loc 1 285 0 is_stmt 1
 427 01a2 7B6A     		ldr	r3, [r7, #36]
 428 01a4 002B     		cmp	r3, #0
 429 01a6 01D1     		bne	.L26
 286:../lwip-1.4.1/src/core/udp.c ****       pcb = uncon_pcb;
 430              		.loc 1 286 0
 431 01a8 FB69     		ldr	r3, [r7, #28]
 432 01aa 7B62     		str	r3, [r7, #36]
 433              	.L26:
 287:../lwip-1.4.1/src/core/udp.c ****     }
 288:../lwip-1.4.1/src/core/udp.c ****   }
 289:../lwip-1.4.1/src/core/udp.c **** 
 290:../lwip-1.4.1/src/core/udp.c ****   /* Check checksum if this is a match or if it was directed at us. */
 291:../lwip-1.4.1/src/core/udp.c ****   if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 434              		.loc 1 291 0
 435 01ac 7B6A     		ldr	r3, [r7, #36]
 436 01ae 002B     		cmp	r3, #0
 437 01b0 05D1     		bne	.L27
 438              		.loc 1 291 0 is_stmt 0 discriminator 1
 439 01b2 3B68     		ldr	r3, [r7]
 440 01b4 5A68     		ldr	r2, [r3, #4]
 441 01b6 314B     		ldr	r3, .L34+4
 442 01b8 1B68     		ldr	r3, [r3]
 443 01ba 9A42     		cmp	r2, r3
 444 01bc 56D1     		bne	.L28
 445              	.L27:
 292:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
 293:../lwip-1.4.1/src/core/udp.c **** #if LWIP_UDPLITE
 294:../lwip-1.4.1/src/core/udp.c ****     if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
 295:../lwip-1.4.1/src/core/udp.c ****       /* Do the UDP Lite checksum */
 296:../lwip-1.4.1/src/core/udp.c **** #if CHECKSUM_CHECK_UDP
 297:../lwip-1.4.1/src/core/udp.c ****       u16_t chklen = ntohs(udphdr->len);
 298:../lwip-1.4.1/src/core/udp.c ****       if (chklen < sizeof(struct udp_hdr)) {
 299:../lwip-1.4.1/src/core/udp.c ****         if (chklen == 0) {
 300:../lwip-1.4.1/src/core/udp.c ****           /* For UDP-Lite, checksum length of 0 means checksum
 301:../lwip-1.4.1/src/core/udp.c ****              over the complete packet (See RFC 3828 chap. 3.1) */
 302:../lwip-1.4.1/src/core/udp.c ****           chklen = p->tot_len;
 303:../lwip-1.4.1/src/core/udp.c ****         } else {
 304:../lwip-1.4.1/src/core/udp.c ****           /* At least the UDP-Lite header must be covered by the
 305:../lwip-1.4.1/src/core/udp.c ****              checksum! (Again, see RFC 3828 chap. 3.1) */
 306:../lwip-1.4.1/src/core/udp.c ****           UDP_STATS_INC(udp.chkerr);
 307:../lwip-1.4.1/src/core/udp.c ****           UDP_STATS_INC(udp.drop);
 308:../lwip-1.4.1/src/core/udp.c ****           snmp_inc_udpinerrors();
 309:../lwip-1.4.1/src/core/udp.c ****           pbuf_free(p);
 310:../lwip-1.4.1/src/core/udp.c ****           goto end;
 311:../lwip-1.4.1/src/core/udp.c ****         }
 312:../lwip-1.4.1/src/core/udp.c ****       }
 313:../lwip-1.4.1/src/core/udp.c ****       if (inet_chksum_pseudo_partial(p, &current_iphdr_src, &current_iphdr_dest,
 314:../lwip-1.4.1/src/core/udp.c ****                              IP_PROTO_UDPLITE, p->tot_len, chklen) != 0) {
 315:../lwip-1.4.1/src/core/udp.c ****        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 316:../lwip-1.4.1/src/core/udp.c ****                    ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
 317:../lwip-1.4.1/src/core/udp.c ****         UDP_STATS_INC(udp.chkerr);
 318:../lwip-1.4.1/src/core/udp.c ****         UDP_STATS_INC(udp.drop);
 319:../lwip-1.4.1/src/core/udp.c ****         snmp_inc_udpinerrors();
 320:../lwip-1.4.1/src/core/udp.c ****         pbuf_free(p);
 321:../lwip-1.4.1/src/core/udp.c ****         goto end;
 322:../lwip-1.4.1/src/core/udp.c ****       }
 323:../lwip-1.4.1/src/core/udp.c **** #endif /* CHECKSUM_CHECK_UDP */
 324:../lwip-1.4.1/src/core/udp.c ****     } else
 325:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_UDPLITE */
 326:../lwip-1.4.1/src/core/udp.c ****     {
 327:../lwip-1.4.1/src/core/udp.c **** #if CHECKSUM_CHECK_UDP
 328:../lwip-1.4.1/src/core/udp.c ****       if (udphdr->chksum != 0) {
 329:../lwip-1.4.1/src/core/udp.c ****         if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 330:../lwip-1.4.1/src/core/udp.c ****                                IP_PROTO_UDP, p->tot_len) != 0) {
 331:../lwip-1.4.1/src/core/udp.c ****           LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 332:../lwip-1.4.1/src/core/udp.c ****                       ("udp_input: UDP datagram discarded due to failing checksum\n"));
 333:../lwip-1.4.1/src/core/udp.c ****           UDP_STATS_INC(udp.chkerr);
 334:../lwip-1.4.1/src/core/udp.c ****           UDP_STATS_INC(udp.drop);
 335:../lwip-1.4.1/src/core/udp.c ****           snmp_inc_udpinerrors();
 336:../lwip-1.4.1/src/core/udp.c ****           pbuf_free(p);
 337:../lwip-1.4.1/src/core/udp.c ****           goto end;
 338:../lwip-1.4.1/src/core/udp.c ****         }
 339:../lwip-1.4.1/src/core/udp.c ****       }
 340:../lwip-1.4.1/src/core/udp.c **** #endif /* CHECKSUM_CHECK_UDP */
 341:../lwip-1.4.1/src/core/udp.c ****     }
 342:../lwip-1.4.1/src/core/udp.c ****     if(pbuf_header(p, -UDP_HLEN)) {
 446              		.loc 1 342 0 is_stmt 1
 447 01be 7868     		ldr	r0, [r7, #4]
 448 01c0 6FF00701 		mvn	r1, #7
 449 01c4 FFF7FEFF 		bl	pbuf_header
 450 01c8 0346     		mov	r3, r0
 451 01ca 002B     		cmp	r3, #0
 452 01cc 0AD0     		beq	.L29
 343:../lwip-1.4.1/src/core/udp.c ****       /* Can we cope with this failing? Just assert for now */
 344:../lwip-1.4.1/src/core/udp.c ****       LWIP_ASSERT("pbuf_header failed\n", 0);
 345:../lwip-1.4.1/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 453              		.loc 1 345 0
 454 01ce 2A4B     		ldr	r3, .L34
 455 01d0 D3F8FC30 		ldr	r3, [r3, #252]
 456 01d4 0133     		adds	r3, r3, #1
 457 01d6 284A     		ldr	r2, .L34
 458 01d8 C2F8FC30 		str	r3, [r2, #252]
 346:../lwip-1.4.1/src/core/udp.c ****       snmp_inc_udpinerrors();
 347:../lwip-1.4.1/src/core/udp.c ****       pbuf_free(p);
 459              		.loc 1 347 0
 460 01dc 7868     		ldr	r0, [r7, #4]
 461 01de FFF7FEFF 		bl	pbuf_free
 348:../lwip-1.4.1/src/core/udp.c ****       goto end;
 462              		.loc 1 348 0
 463 01e2 46E0     		b	.L12
 464              	.L29:
 349:../lwip-1.4.1/src/core/udp.c ****     }
 350:../lwip-1.4.1/src/core/udp.c ****     if (pcb != NULL) {
 465              		.loc 1 350 0
 466 01e4 7B6A     		ldr	r3, [r7, #36]
 467 01e6 002B     		cmp	r3, #0
 468 01e8 13D0     		beq	.L30
 351:../lwip-1.4.1/src/core/udp.c ****       snmp_inc_udpindatagrams();
 352:../lwip-1.4.1/src/core/udp.c **** #if SO_REUSE && SO_REUSE_RXTOALL
 353:../lwip-1.4.1/src/core/udp.c ****       if ((broadcast || ip_addr_ismulticast(&current_iphdr_dest)) &&
 354:../lwip-1.4.1/src/core/udp.c ****           ip_get_option(pcb, SOF_REUSEADDR)) {
 355:../lwip-1.4.1/src/core/udp.c ****         /* pass broadcast- or multicast packets to all multicast pcbs
 356:../lwip-1.4.1/src/core/udp.c ****            if SOF_REUSEADDR is set on the first match */
 357:../lwip-1.4.1/src/core/udp.c ****         struct udp_pcb *mpcb;
 358:../lwip-1.4.1/src/core/udp.c ****         u8_t p_header_changed = 0;
 359:../lwip-1.4.1/src/core/udp.c ****         for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
 360:../lwip-1.4.1/src/core/udp.c ****           if (mpcb != pcb) {
 361:../lwip-1.4.1/src/core/udp.c ****             /* compare PCB local addr+port to UDP destination addr+port */
 362:../lwip-1.4.1/src/core/udp.c ****             if ((mpcb->local_port == dest) &&
 363:../lwip-1.4.1/src/core/udp.c ****                 ((!broadcast && ip_addr_isany(&mpcb->local_ip)) ||
 364:../lwip-1.4.1/src/core/udp.c ****                  ip_addr_cmp(&(mpcb->local_ip), &current_iphdr_dest) ||
 365:../lwip-1.4.1/src/core/udp.c **** #if LWIP_IGMP
 366:../lwip-1.4.1/src/core/udp.c ****                  ip_addr_ismulticast(&current_iphdr_dest) ||
 367:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_IGMP */
 368:../lwip-1.4.1/src/core/udp.c **** #if IP_SOF_BROADCAST_RECV
 369:../lwip-1.4.1/src/core/udp.c ****                  (broadcast && ip_get_option(mpcb, SOF_BROADCAST)))) {
 370:../lwip-1.4.1/src/core/udp.c **** #else  /* IP_SOF_BROADCAST_RECV */
 371:../lwip-1.4.1/src/core/udp.c ****                  (broadcast))) {
 372:../lwip-1.4.1/src/core/udp.c **** #endif /* IP_SOF_BROADCAST_RECV */
 373:../lwip-1.4.1/src/core/udp.c ****               /* pass a copy of the packet to all local matches */
 374:../lwip-1.4.1/src/core/udp.c ****               if (mpcb->recv != NULL) {
 375:../lwip-1.4.1/src/core/udp.c ****                 struct pbuf *q;
 376:../lwip-1.4.1/src/core/udp.c ****                 /* for that, move payload to IP header again */
 377:../lwip-1.4.1/src/core/udp.c ****                 if (p_header_changed == 0) {
 378:../lwip-1.4.1/src/core/udp.c ****                   pbuf_header(p, (s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
 379:../lwip-1.4.1/src/core/udp.c ****                   p_header_changed = 1;
 380:../lwip-1.4.1/src/core/udp.c ****                 }
 381:../lwip-1.4.1/src/core/udp.c ****                 q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 382:../lwip-1.4.1/src/core/udp.c ****                 if (q != NULL) {
 383:../lwip-1.4.1/src/core/udp.c ****                   err_t err = pbuf_copy(q, p);
 384:../lwip-1.4.1/src/core/udp.c ****                   if (err == ERR_OK) {
 385:../lwip-1.4.1/src/core/udp.c ****                     /* move payload to UDP data */
 386:../lwip-1.4.1/src/core/udp.c ****                     pbuf_header(q, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
 387:../lwip-1.4.1/src/core/udp.c ****                     mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
 388:../lwip-1.4.1/src/core/udp.c ****                   }
 389:../lwip-1.4.1/src/core/udp.c ****                 }
 390:../lwip-1.4.1/src/core/udp.c ****               }
 391:../lwip-1.4.1/src/core/udp.c ****             }
 392:../lwip-1.4.1/src/core/udp.c ****           }
 393:../lwip-1.4.1/src/core/udp.c ****         }
 394:../lwip-1.4.1/src/core/udp.c ****         if (p_header_changed) {
 395:../lwip-1.4.1/src/core/udp.c ****           /* and move payload to UDP data again */
 396:../lwip-1.4.1/src/core/udp.c ****           pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
 397:../lwip-1.4.1/src/core/udp.c ****         }
 398:../lwip-1.4.1/src/core/udp.c ****       }
 399:../lwip-1.4.1/src/core/udp.c **** #endif /* SO_REUSE && SO_REUSE_RXTOALL */
 400:../lwip-1.4.1/src/core/udp.c ****       /* callback */
 401:../lwip-1.4.1/src/core/udp.c ****       if (pcb->recv != NULL) {
 469              		.loc 1 401 0
 470 01ea 7B6A     		ldr	r3, [r7, #36]
 471 01ec 9B69     		ldr	r3, [r3, #24]
 472 01ee 002B     		cmp	r3, #0
 473 01f0 0BD0     		beq	.L31
 402:../lwip-1.4.1/src/core/udp.c ****         /* now the recv function is responsible for freeing p */
 403:../lwip-1.4.1/src/core/udp.c ****         pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 474              		.loc 1 403 0
 475 01f2 7B6A     		ldr	r3, [r7, #36]
 476 01f4 9C69     		ldr	r4, [r3, #24]
 477 01f6 7B6A     		ldr	r3, [r7, #36]
 478 01f8 DA69     		ldr	r2, [r3, #28]
 479 01fa BB89     		ldrh	r3, [r7, #12]
 480 01fc 0093     		str	r3, [sp]
 481 01fe 1046     		mov	r0, r2
 482 0200 796A     		ldr	r1, [r7, #36]
 483 0202 7A68     		ldr	r2, [r7, #4]
 484 0204 1F4B     		ldr	r3, .L34+12
 485 0206 A047     		blx	r4
 350:../lwip-1.4.1/src/core/udp.c ****       snmp_inc_udpindatagrams();
 486              		.loc 1 350 0
 487 0208 33E0     		b	.L12
 488              	.L31:
 404:../lwip-1.4.1/src/core/udp.c ****       } else {
 405:../lwip-1.4.1/src/core/udp.c ****         /* no recv function registered? then we have to free the pbuf! */
 406:../lwip-1.4.1/src/core/udp.c ****         pbuf_free(p);
 489              		.loc 1 406 0
 490 020a 7868     		ldr	r0, [r7, #4]
 491 020c FFF7FEFF 		bl	pbuf_free
 407:../lwip-1.4.1/src/core/udp.c ****         goto end;
 492              		.loc 1 407 0
 493 0210 2FE0     		b	.L12
 494              	.L30:
 408:../lwip-1.4.1/src/core/udp.c ****       }
 409:../lwip-1.4.1/src/core/udp.c ****     } else {
 410:../lwip-1.4.1/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
 411:../lwip-1.4.1/src/core/udp.c **** 
 412:../lwip-1.4.1/src/core/udp.c **** #if LWIP_ICMP
 413:../lwip-1.4.1/src/core/udp.c ****       /* No match was found, send ICMP destination port unreachable unless
 414:../lwip-1.4.1/src/core/udp.c ****          destination address was broadcast/multicast. */
 415:../lwip-1.4.1/src/core/udp.c ****       if (!broadcast &&
 495              		.loc 1 415 0
 496 0212 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 497 0214 002B     		cmp	r3, #0
 498 0216 17D1     		bne	.L33
 416:../lwip-1.4.1/src/core/udp.c ****           !ip_addr_ismulticast(&current_iphdr_dest)) {
 499              		.loc 1 416 0 discriminator 1
 500 0218 184B     		ldr	r3, .L34+4
 501 021a 1B68     		ldr	r3, [r3]
 502 021c 03F0F003 		and	r3, r3, #240
 415:../lwip-1.4.1/src/core/udp.c ****           !ip_addr_ismulticast(&current_iphdr_dest)) {
 503              		.loc 1 415 0 discriminator 1
 504 0220 E02B     		cmp	r3, #224
 505 0222 11D0     		beq	.L33
 417:../lwip-1.4.1/src/core/udp.c ****         /* move payload pointer back to ip header */
 418:../lwip-1.4.1/src/core/udp.c ****         pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 506              		.loc 1 418 0
 507 0224 7B69     		ldr	r3, [r7, #20]
 508 0226 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 509 0228 03F00F03 		and	r3, r3, #15
 510 022c 0233     		adds	r3, r3, #2
 511 022e 9BB2     		uxth	r3, r3
 512 0230 9B00     		lsls	r3, r3, #2
 513 0232 9BB2     		uxth	r3, r3
 514 0234 9BB2     		uxth	r3, r3
 515 0236 1BB2     		sxth	r3, r3
 516 0238 7868     		ldr	r0, [r7, #4]
 517 023a 1946     		mov	r1, r3
 518 023c FFF7FEFF 		bl	pbuf_header
 419:../lwip-1.4.1/src/core/udp.c ****         LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
 420:../lwip-1.4.1/src/core/udp.c ****         icmp_dest_unreach(p, ICMP_DUR_PORT);
 519              		.loc 1 420 0
 520 0240 7868     		ldr	r0, [r7, #4]
 521 0242 0321     		movs	r1, #3
 522 0244 FFF7FEFF 		bl	icmp_dest_unreach
 523              	.L33:
 421:../lwip-1.4.1/src/core/udp.c ****       }
 422:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_ICMP */
 423:../lwip-1.4.1/src/core/udp.c ****       UDP_STATS_INC(udp.proterr);
 524              		.loc 1 423 0
 525 0248 0B4B     		ldr	r3, .L34
 526 024a D3F81031 		ldr	r3, [r3, #272]
 527 024e 0133     		adds	r3, r3, #1
 528 0250 094A     		ldr	r2, .L34
 529 0252 C2F81031 		str	r3, [r2, #272]
 424:../lwip-1.4.1/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 530              		.loc 1 424 0
 531 0256 084B     		ldr	r3, .L34
 532 0258 D3F8FC30 		ldr	r3, [r3, #252]
 533 025c 0133     		adds	r3, r3, #1
 534 025e 064A     		ldr	r2, .L34
 535 0260 C2F8FC30 		str	r3, [r2, #252]
 425:../lwip-1.4.1/src/core/udp.c ****       snmp_inc_udpnoports();
 426:../lwip-1.4.1/src/core/udp.c ****       pbuf_free(p);
 536              		.loc 1 426 0
 537 0264 7868     		ldr	r0, [r7, #4]
 538 0266 FFF7FEFF 		bl	pbuf_free
 350:../lwip-1.4.1/src/core/udp.c ****       snmp_inc_udpindatagrams();
 539              		.loc 1 350 0
 540 026a 02E0     		b	.L12
 541              	.L28:
 427:../lwip-1.4.1/src/core/udp.c ****     }
 428:../lwip-1.4.1/src/core/udp.c ****   } else {
 429:../lwip-1.4.1/src/core/udp.c ****     pbuf_free(p);
 542              		.loc 1 429 0
 543 026c 7868     		ldr	r0, [r7, #4]
 544 026e FFF7FEFF 		bl	pbuf_free
 545              	.L15:
 546              	.L12:
 430:../lwip-1.4.1/src/core/udp.c ****   }
 431:../lwip-1.4.1/src/core/udp.c **** end:
 432:../lwip-1.4.1/src/core/udp.c ****   PERF_STOP("udp_input");
 433:../lwip-1.4.1/src/core/udp.c **** }
 547              		.loc 1 433 0
 548 0272 2C37     		adds	r7, r7, #44
 549              		.cfi_def_cfa_offset 12
 550 0274 BD46     		mov	sp, r7
 551              		.cfi_def_cfa_register 13
 552              		@ sp needed
 553 0276 90BD     		pop	{r4, r7, pc}
 554              	.L35:
 555              		.align	2
 556              	.L34:
 557 0278 00000000 		.word	lwip_stats
 558 027c 00000000 		.word	current_iphdr_dest
 559 0280 00000000 		.word	udp_pcbs
 560 0284 00000000 		.word	current_iphdr_src
 561              		.cfi_endproc
 562              	.LFE2:
 564              		.section	.text.udp_send,"ax",%progbits
 565              		.align	2
 566              		.global	udp_send
 567              		.thumb
 568              		.thumb_func
 570              	udp_send:
 571              	.LFB3:
 434:../lwip-1.4.1/src/core/udp.c **** 
 435:../lwip-1.4.1/src/core/udp.c **** /**
 436:../lwip-1.4.1/src/core/udp.c ****  * Send data using UDP.
 437:../lwip-1.4.1/src/core/udp.c ****  *
 438:../lwip-1.4.1/src/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 439:../lwip-1.4.1/src/core/udp.c ****  * @param p chain of pbuf's to be sent.
 440:../lwip-1.4.1/src/core/udp.c ****  *
 441:../lwip-1.4.1/src/core/udp.c ****  * The datagram will be sent to the current remote_ip & remote_port
 442:../lwip-1.4.1/src/core/udp.c ****  * stored in pcb. If the pcb is not bound to a port, it will
 443:../lwip-1.4.1/src/core/udp.c ****  * automatically be bound to a random port.
 444:../lwip-1.4.1/src/core/udp.c ****  *
 445:../lwip-1.4.1/src/core/udp.c ****  * @return lwIP error code.
 446:../lwip-1.4.1/src/core/udp.c ****  * - ERR_OK. Successful. No error occured.
 447:../lwip-1.4.1/src/core/udp.c ****  * - ERR_MEM. Out of memory.
 448:../lwip-1.4.1/src/core/udp.c ****  * - ERR_RTE. Could not find route to destination address.
 449:../lwip-1.4.1/src/core/udp.c ****  * - More errors could be returned by lower protocol layers.
 450:../lwip-1.4.1/src/core/udp.c ****  *
 451:../lwip-1.4.1/src/core/udp.c ****  * @see udp_disconnect() udp_sendto()
 452:../lwip-1.4.1/src/core/udp.c ****  */
 453:../lwip-1.4.1/src/core/udp.c **** err_t
 454:../lwip-1.4.1/src/core/udp.c **** udp_send(struct udp_pcb *pcb, struct pbuf *p)
 455:../lwip-1.4.1/src/core/udp.c **** {
 572              		.loc 1 455 0
 573              		.cfi_startproc
 574              		@ args = 0, pretend = 0, frame = 8
 575              		@ frame_needed = 1, uses_anonymous_args = 0
 576 0000 80B5     		push	{r7, lr}
 577              		.cfi_def_cfa_offset 8
 578              		.cfi_offset 7, -8
 579              		.cfi_offset 14, -4
 580 0002 82B0     		sub	sp, sp, #8
 581              		.cfi_def_cfa_offset 16
 582 0004 00AF     		add	r7, sp, #0
 583              		.cfi_def_cfa_register 7
 584 0006 7860     		str	r0, [r7, #4]
 585 0008 3960     		str	r1, [r7]
 456:../lwip-1.4.1/src/core/udp.c ****   /* send to the packet using remote ip and port stored in the pcb */
 457:../lwip-1.4.1/src/core/udp.c ****   return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 586              		.loc 1 457 0
 587 000a 7B68     		ldr	r3, [r7, #4]
 588 000c 1A1D     		adds	r2, r3, #4
 589 000e 7B68     		ldr	r3, [r7, #4]
 590 0010 9B8A     		ldrh	r3, [r3, #20]
 591 0012 7868     		ldr	r0, [r7, #4]
 592 0014 3968     		ldr	r1, [r7]
 593 0016 FFF7FEFF 		bl	udp_sendto
 594 001a 0346     		mov	r3, r0
 458:../lwip-1.4.1/src/core/udp.c **** }
 595              		.loc 1 458 0
 596 001c 1846     		mov	r0, r3
 597 001e 0837     		adds	r7, r7, #8
 598              		.cfi_def_cfa_offset 8
 599 0020 BD46     		mov	sp, r7
 600              		.cfi_def_cfa_register 13
 601              		@ sp needed
 602 0022 80BD     		pop	{r7, pc}
 603              		.cfi_endproc
 604              	.LFE3:
 606              		.section	.text.udp_sendto,"ax",%progbits
 607              		.align	2
 608              		.global	udp_sendto
 609              		.thumb
 610              		.thumb_func
 612              	udp_sendto:
 613              	.LFB4:
 459:../lwip-1.4.1/src/core/udp.c **** 
 460:../lwip-1.4.1/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 461:../lwip-1.4.1/src/core/udp.c **** /** Same as udp_send() but with checksum
 462:../lwip-1.4.1/src/core/udp.c ****  */
 463:../lwip-1.4.1/src/core/udp.c **** err_t
 464:../lwip-1.4.1/src/core/udp.c **** udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
 465:../lwip-1.4.1/src/core/udp.c ****                 u8_t have_chksum, u16_t chksum)
 466:../lwip-1.4.1/src/core/udp.c **** {
 467:../lwip-1.4.1/src/core/udp.c ****   /* send to the packet using remote ip and port stored in the pcb */
 468:../lwip-1.4.1/src/core/udp.c ****   return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
 469:../lwip-1.4.1/src/core/udp.c ****     have_chksum, chksum);
 470:../lwip-1.4.1/src/core/udp.c **** }
 471:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 472:../lwip-1.4.1/src/core/udp.c **** 
 473:../lwip-1.4.1/src/core/udp.c **** /**
 474:../lwip-1.4.1/src/core/udp.c ****  * Send data to a specified address using UDP.
 475:../lwip-1.4.1/src/core/udp.c ****  *
 476:../lwip-1.4.1/src/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 477:../lwip-1.4.1/src/core/udp.c ****  * @param p chain of pbuf's to be sent.
 478:../lwip-1.4.1/src/core/udp.c ****  * @param dst_ip Destination IP address.
 479:../lwip-1.4.1/src/core/udp.c ****  * @param dst_port Destination UDP port.
 480:../lwip-1.4.1/src/core/udp.c ****  *
 481:../lwip-1.4.1/src/core/udp.c ****  * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 482:../lwip-1.4.1/src/core/udp.c ****  *
 483:../lwip-1.4.1/src/core/udp.c ****  * If the PCB already has a remote address association, it will
 484:../lwip-1.4.1/src/core/udp.c ****  * be restored after the data is sent.
 485:../lwip-1.4.1/src/core/udp.c ****  * 
 486:../lwip-1.4.1/src/core/udp.c ****  * @return lwIP error code (@see udp_send for possible error codes)
 487:../lwip-1.4.1/src/core/udp.c ****  *
 488:../lwip-1.4.1/src/core/udp.c ****  * @see udp_disconnect() udp_send()
 489:../lwip-1.4.1/src/core/udp.c ****  */
 490:../lwip-1.4.1/src/core/udp.c **** err_t
 491:../lwip-1.4.1/src/core/udp.c **** udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
 492:../lwip-1.4.1/src/core/udp.c ****   ip_addr_t *dst_ip, u16_t dst_port)
 493:../lwip-1.4.1/src/core/udp.c **** {
 614              		.loc 1 493 0
 615              		.cfi_startproc
 616              		@ args = 0, pretend = 0, frame = 24
 617              		@ frame_needed = 1, uses_anonymous_args = 0
 618 0000 90B5     		push	{r4, r7, lr}
 619              		.cfi_def_cfa_offset 12
 620              		.cfi_offset 4, -12
 621              		.cfi_offset 7, -8
 622              		.cfi_offset 14, -4
 623 0002 89B0     		sub	sp, sp, #36
 624              		.cfi_def_cfa_offset 48
 625 0004 02AF     		add	r7, sp, #8
 626              		.cfi_def_cfa 7, 40
 627 0006 F860     		str	r0, [r7, #12]
 628 0008 B960     		str	r1, [r7, #8]
 629 000a 7A60     		str	r2, [r7, #4]
 630 000c 7B80     		strh	r3, [r7, #2]	@ movhi
 494:../lwip-1.4.1/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 495:../lwip-1.4.1/src/core/udp.c ****   return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 496:../lwip-1.4.1/src/core/udp.c **** }
 497:../lwip-1.4.1/src/core/udp.c **** 
 498:../lwip-1.4.1/src/core/udp.c **** /** Same as udp_sendto(), but with checksum */
 499:../lwip-1.4.1/src/core/udp.c **** err_t
 500:../lwip-1.4.1/src/core/udp.c **** udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
 501:../lwip-1.4.1/src/core/udp.c ****                   u16_t dst_port, u8_t have_chksum, u16_t chksum)
 502:../lwip-1.4.1/src/core/udp.c **** {
 503:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 504:../lwip-1.4.1/src/core/udp.c ****   struct netif *netif;
 505:../lwip-1.4.1/src/core/udp.c **** 
 506:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
 507:../lwip-1.4.1/src/core/udp.c **** 
 508:../lwip-1.4.1/src/core/udp.c ****   /* find the outgoing network interface for this packet */
 509:../lwip-1.4.1/src/core/udp.c **** #if LWIP_IGMP
 510:../lwip-1.4.1/src/core/udp.c ****   netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
 511:../lwip-1.4.1/src/core/udp.c **** #else
 512:../lwip-1.4.1/src/core/udp.c ****   netif = ip_route(dst_ip);
 631              		.loc 1 512 0
 632 000e 7868     		ldr	r0, [r7, #4]
 633 0010 FFF7FEFF 		bl	ip_route
 634 0014 7861     		str	r0, [r7, #20]
 513:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_IGMP */
 514:../lwip-1.4.1/src/core/udp.c **** 
 515:../lwip-1.4.1/src/core/udp.c ****   /* no outgoing network interface could be found? */
 516:../lwip-1.4.1/src/core/udp.c ****   if (netif == NULL) {
 635              		.loc 1 516 0
 636 0016 7B69     		ldr	r3, [r7, #20]
 637 0018 002B     		cmp	r3, #0
 638 001a 08D1     		bne	.L39
 517:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16
 518:../lwip-1.4.1/src/core/udp.c ****       ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
 519:../lwip-1.4.1/src/core/udp.c ****     UDP_STATS_INC(udp.rterr);
 639              		.loc 1 519 0
 640 001c 0B4B     		ldr	r3, .L41
 641 001e D3F80C31 		ldr	r3, [r3, #268]
 642 0022 0133     		adds	r3, r3, #1
 643 0024 094A     		ldr	r2, .L41
 644 0026 C2F80C31 		str	r3, [r2, #268]
 520:../lwip-1.4.1/src/core/udp.c ****     return ERR_RTE;
 645              		.loc 1 520 0
 646 002a FC23     		movs	r3, #252
 647 002c 09E0     		b	.L40
 648              	.L39:
 521:../lwip-1.4.1/src/core/udp.c ****   }
 522:../lwip-1.4.1/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 523:../lwip-1.4.1/src/core/udp.c ****   return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 524:../lwip-1.4.1/src/core/udp.c **** #else /* LWIP_CHECKSUM_ON_COPY */
 525:../lwip-1.4.1/src/core/udp.c ****   return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 649              		.loc 1 525 0
 650 002e 7C88     		ldrh	r4, [r7, #2]
 651 0030 7B69     		ldr	r3, [r7, #20]
 652 0032 0093     		str	r3, [sp]
 653 0034 F868     		ldr	r0, [r7, #12]
 654 0036 B968     		ldr	r1, [r7, #8]
 655 0038 7A68     		ldr	r2, [r7, #4]
 656 003a 2346     		mov	r3, r4
 657 003c FFF7FEFF 		bl	udp_sendto_if
 658 0040 0346     		mov	r3, r0
 659              	.L40:
 660 0042 5BB2     		sxtb	r3, r3
 526:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 527:../lwip-1.4.1/src/core/udp.c **** }
 661              		.loc 1 527 0
 662 0044 1846     		mov	r0, r3
 663 0046 1C37     		adds	r7, r7, #28
 664              		.cfi_def_cfa_offset 12
 665 0048 BD46     		mov	sp, r7
 666              		.cfi_def_cfa_register 13
 667              		@ sp needed
 668 004a 90BD     		pop	{r4, r7, pc}
 669              	.L42:
 670              		.align	2
 671              	.L41:
 672 004c 00000000 		.word	lwip_stats
 673              		.cfi_endproc
 674              	.LFE4:
 676              		.section	.text.udp_sendto_if,"ax",%progbits
 677              		.align	2
 678              		.global	udp_sendto_if
 679              		.thumb
 680              		.thumb_func
 682              	udp_sendto_if:
 683              	.LFB5:
 528:../lwip-1.4.1/src/core/udp.c **** 
 529:../lwip-1.4.1/src/core/udp.c **** /**
 530:../lwip-1.4.1/src/core/udp.c ****  * Send data to a specified address using UDP.
 531:../lwip-1.4.1/src/core/udp.c ****  * The netif used for sending can be specified.
 532:../lwip-1.4.1/src/core/udp.c ****  *
 533:../lwip-1.4.1/src/core/udp.c ****  * This function exists mainly for DHCP, to be able to send UDP packets
 534:../lwip-1.4.1/src/core/udp.c ****  * on a netif that is still down.
 535:../lwip-1.4.1/src/core/udp.c ****  *
 536:../lwip-1.4.1/src/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 537:../lwip-1.4.1/src/core/udp.c ****  * @param p chain of pbuf's to be sent.
 538:../lwip-1.4.1/src/core/udp.c ****  * @param dst_ip Destination IP address.
 539:../lwip-1.4.1/src/core/udp.c ****  * @param dst_port Destination UDP port.
 540:../lwip-1.4.1/src/core/udp.c ****  * @param netif the netif used for sending.
 541:../lwip-1.4.1/src/core/udp.c ****  *
 542:../lwip-1.4.1/src/core/udp.c ****  * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 543:../lwip-1.4.1/src/core/udp.c ****  *
 544:../lwip-1.4.1/src/core/udp.c ****  * @return lwIP error code (@see udp_send for possible error codes)
 545:../lwip-1.4.1/src/core/udp.c ****  *
 546:../lwip-1.4.1/src/core/udp.c ****  * @see udp_disconnect() udp_send()
 547:../lwip-1.4.1/src/core/udp.c ****  */
 548:../lwip-1.4.1/src/core/udp.c **** err_t
 549:../lwip-1.4.1/src/core/udp.c **** udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
 550:../lwip-1.4.1/src/core/udp.c ****   ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 551:../lwip-1.4.1/src/core/udp.c **** {
 684              		.loc 1 551 0
 685              		.cfi_startproc
 686              		@ args = 4, pretend = 0, frame = 32
 687              		@ frame_needed = 1, uses_anonymous_args = 0
 688 0000 90B5     		push	{r4, r7, lr}
 689              		.cfi_def_cfa_offset 12
 690              		.cfi_offset 4, -12
 691              		.cfi_offset 7, -8
 692              		.cfi_offset 14, -4
 693 0002 8DB0     		sub	sp, sp, #52
 694              		.cfi_def_cfa_offset 64
 695 0004 04AF     		add	r7, sp, #16
 696              		.cfi_def_cfa 7, 48
 697 0006 F860     		str	r0, [r7, #12]
 698 0008 B960     		str	r1, [r7, #8]
 699 000a 7A60     		str	r2, [r7, #4]
 700 000c 7B80     		strh	r3, [r7, #2]	@ movhi
 552:../lwip-1.4.1/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 553:../lwip-1.4.1/src/core/udp.c ****   return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
 554:../lwip-1.4.1/src/core/udp.c **** }
 555:../lwip-1.4.1/src/core/udp.c **** 
 556:../lwip-1.4.1/src/core/udp.c **** /** Same as udp_sendto_if(), but with checksum */
 557:../lwip-1.4.1/src/core/udp.c **** err_t
 558:../lwip-1.4.1/src/core/udp.c **** udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
 559:../lwip-1.4.1/src/core/udp.c ****                      u16_t dst_port, struct netif *netif, u8_t have_chksum,
 560:../lwip-1.4.1/src/core/udp.c ****                      u16_t chksum)
 561:../lwip-1.4.1/src/core/udp.c **** {
 562:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 563:../lwip-1.4.1/src/core/udp.c ****   struct udp_hdr *udphdr;
 564:../lwip-1.4.1/src/core/udp.c ****   ip_addr_t *src_ip;
 565:../lwip-1.4.1/src/core/udp.c ****   err_t err;
 566:../lwip-1.4.1/src/core/udp.c ****   struct pbuf *q; /* q will be sent down the stack */
 567:../lwip-1.4.1/src/core/udp.c **** 
 568:../lwip-1.4.1/src/core/udp.c **** #if IP_SOF_BROADCAST
 569:../lwip-1.4.1/src/core/udp.c ****   /* broadcast filter? */
 570:../lwip-1.4.1/src/core/udp.c ****   if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(dst_ip, netif)) {
 571:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 572:../lwip-1.4.1/src/core/udp.c ****       ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
 573:../lwip-1.4.1/src/core/udp.c ****     return ERR_VAL;
 574:../lwip-1.4.1/src/core/udp.c ****   }
 575:../lwip-1.4.1/src/core/udp.c **** #endif /* IP_SOF_BROADCAST */
 576:../lwip-1.4.1/src/core/udp.c **** 
 577:../lwip-1.4.1/src/core/udp.c ****   /* if the PCB is not yet bound to a port, bind it here */
 578:../lwip-1.4.1/src/core/udp.c ****   if (pcb->local_port == 0) {
 701              		.loc 1 578 0
 702 000e FB68     		ldr	r3, [r7, #12]
 703 0010 5B8A     		ldrh	r3, [r3, #18]
 704 0012 002B     		cmp	r3, #0
 705 0014 0FD1     		bne	.L44
 579:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 580:../lwip-1.4.1/src/core/udp.c ****     err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 706              		.loc 1 580 0
 707 0016 FA68     		ldr	r2, [r7, #12]
 708 0018 FB68     		ldr	r3, [r7, #12]
 709 001a 5B8A     		ldrh	r3, [r3, #18]
 710 001c F868     		ldr	r0, [r7, #12]
 711 001e 1146     		mov	r1, r2
 712 0020 1A46     		mov	r2, r3
 713 0022 FFF7FEFF 		bl	udp_bind
 714 0026 0346     		mov	r3, r0
 715 0028 FB75     		strb	r3, [r7, #23]
 581:../lwip-1.4.1/src/core/udp.c ****     if (err != ERR_OK) {
 716              		.loc 1 581 0
 717 002a 97F91730 		ldrsb	r3, [r7, #23]
 718 002e 002B     		cmp	r3, #0
 719 0030 01D0     		beq	.L44
 582:../lwip-1.4.1/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 583:../lwip-1.4.1/src/core/udp.c ****       return err;
 720              		.loc 1 583 0
 721 0032 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 722 0034 7EE0     		b	.L45
 723              	.L44:
 584:../lwip-1.4.1/src/core/udp.c ****     }
 585:../lwip-1.4.1/src/core/udp.c ****   }
 586:../lwip-1.4.1/src/core/udp.c **** 
 587:../lwip-1.4.1/src/core/udp.c ****   /*  */
 588:../lwip-1.4.1/src/core/udp.c ****   if (pbuf_header(p, UDP_HLEN)) {
 724              		.loc 1 588 0
 725 0036 B868     		ldr	r0, [r7, #8]
 726 0038 0821     		movs	r1, #8
 727 003a FFF7FEFF 		bl	pbuf_header
 728 003e 0346     		mov	r3, r0
 729 0040 002B     		cmp	r3, #0
 730 0042 13D0     		beq	.L46
 589:../lwip-1.4.1/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 590:../lwip-1.4.1/src/core/udp.c ****     q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 731              		.loc 1 590 0
 732 0044 0120     		movs	r0, #1
 733 0046 0821     		movs	r1, #8
 734 0048 0022     		movs	r2, #0
 735 004a FFF7FEFF 		bl	pbuf_alloc
 736 004e B861     		str	r0, [r7, #24]
 591:../lwip-1.4.1/src/core/udp.c ****     /* new header pbuf could not be allocated? */
 592:../lwip-1.4.1/src/core/udp.c ****     if (q == NULL) {
 737              		.loc 1 592 0
 738 0050 BB69     		ldr	r3, [r7, #24]
 739 0052 002B     		cmp	r3, #0
 740 0054 01D1     		bne	.L47
 593:../lwip-1.4.1/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not alloca
 594:../lwip-1.4.1/src/core/udp.c ****       return ERR_MEM;
 741              		.loc 1 594 0
 742 0056 FF23     		movs	r3, #255
 743 0058 6CE0     		b	.L45
 744              	.L47:
 595:../lwip-1.4.1/src/core/udp.c ****     }
 596:../lwip-1.4.1/src/core/udp.c ****     if (p->tot_len != 0) {
 745              		.loc 1 596 0
 746 005a BB68     		ldr	r3, [r7, #8]
 747 005c 1B89     		ldrh	r3, [r3, #8]
 748 005e 002B     		cmp	r3, #0
 749 0060 06D0     		beq	.L49
 597:../lwip-1.4.1/src/core/udp.c ****       /* chain header q in front of given pbuf p (only if p contains data) */
 598:../lwip-1.4.1/src/core/udp.c ****       pbuf_chain(q, p);
 750              		.loc 1 598 0
 751 0062 B869     		ldr	r0, [r7, #24]
 752 0064 B968     		ldr	r1, [r7, #8]
 753 0066 FFF7FEFF 		bl	pbuf_chain
 754 006a 01E0     		b	.L49
 755              	.L46:
 599:../lwip-1.4.1/src/core/udp.c ****     }
 600:../lwip-1.4.1/src/core/udp.c ****     /* first pbuf q points to header pbuf */
 601:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG,
 602:../lwip-1.4.1/src/core/udp.c ****                 ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
 603:../lwip-1.4.1/src/core/udp.c ****   } else {
 604:../lwip-1.4.1/src/core/udp.c ****     /* adding space for header within p succeeded */
 605:../lwip-1.4.1/src/core/udp.c ****     /* first pbuf q equals given pbuf */
 606:../lwip-1.4.1/src/core/udp.c ****     q = p;
 756              		.loc 1 606 0
 757 006c BB68     		ldr	r3, [r7, #8]
 758 006e BB61     		str	r3, [r7, #24]
 759              	.L49:
 607:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
 608:../lwip-1.4.1/src/core/udp.c ****   }
 609:../lwip-1.4.1/src/core/udp.c ****   LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 610:../lwip-1.4.1/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 611:../lwip-1.4.1/src/core/udp.c ****   /* q now represents the packet to be sent */
 612:../lwip-1.4.1/src/core/udp.c ****   udphdr = (struct udp_hdr *)q->payload;
 760              		.loc 1 612 0
 761 0070 BB69     		ldr	r3, [r7, #24]
 762 0072 5B68     		ldr	r3, [r3, #4]
 763 0074 3B61     		str	r3, [r7, #16]
 613:../lwip-1.4.1/src/core/udp.c ****   udphdr->src = htons(pcb->local_port);
 764              		.loc 1 613 0
 765 0076 FB68     		ldr	r3, [r7, #12]
 766 0078 5B8A     		ldrh	r3, [r3, #18]
 767 007a 1846     		mov	r0, r3
 768 007c FFF7FEFF 		bl	lwip_htons
 769 0080 0346     		mov	r3, r0
 770 0082 1A46     		mov	r2, r3
 771 0084 3B69     		ldr	r3, [r7, #16]
 772 0086 1A80     		strh	r2, [r3]	@ unaligned
 614:../lwip-1.4.1/src/core/udp.c ****   udphdr->dest = htons(dst_port);
 773              		.loc 1 614 0
 774 0088 7B88     		ldrh	r3, [r7, #2]
 775 008a 1846     		mov	r0, r3
 776 008c FFF7FEFF 		bl	lwip_htons
 777 0090 0346     		mov	r3, r0
 778 0092 1A46     		mov	r2, r3
 779 0094 3B69     		ldr	r3, [r7, #16]
 780 0096 5A80     		strh	r2, [r3, #2]	@ unaligned
 615:../lwip-1.4.1/src/core/udp.c ****   /* in UDP, 0 checksum means 'no checksum' */
 616:../lwip-1.4.1/src/core/udp.c ****   udphdr->chksum = 0x0000; 
 781              		.loc 1 616 0
 782 0098 3B69     		ldr	r3, [r7, #16]
 783 009a 0022     		movs	r2, #0
 784 009c 9A71     		strb	r2, [r3, #6]
 785 009e 0022     		movs	r2, #0
 786 00a0 DA71     		strb	r2, [r3, #7]
 617:../lwip-1.4.1/src/core/udp.c **** 
 618:../lwip-1.4.1/src/core/udp.c ****   /* Multicast Loop? */
 619:../lwip-1.4.1/src/core/udp.c **** #if LWIP_IGMP
 620:../lwip-1.4.1/src/core/udp.c ****   if (ip_addr_ismulticast(dst_ip) && ((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0)) {
 621:../lwip-1.4.1/src/core/udp.c ****     q->flags |= PBUF_FLAG_MCASTLOOP;
 622:../lwip-1.4.1/src/core/udp.c ****   }
 623:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_IGMP */
 624:../lwip-1.4.1/src/core/udp.c **** 
 625:../lwip-1.4.1/src/core/udp.c **** 
 626:../lwip-1.4.1/src/core/udp.c ****   /* PCB local address is IP_ANY_ADDR? */
 627:../lwip-1.4.1/src/core/udp.c ****   if (ip_addr_isany(&pcb->local_ip)) {
 787              		.loc 1 627 0
 788 00a2 FB68     		ldr	r3, [r7, #12]
 789 00a4 002B     		cmp	r3, #0
 790 00a6 03D0     		beq	.L50
 791              		.loc 1 627 0 is_stmt 0 discriminator 1
 792 00a8 FB68     		ldr	r3, [r7, #12]
 793 00aa 1B68     		ldr	r3, [r3]
 794 00ac 002B     		cmp	r3, #0
 795 00ae 03D1     		bne	.L51
 796              	.L50:
 628:../lwip-1.4.1/src/core/udp.c ****     /* use outgoing network interface IP address as source address */
 629:../lwip-1.4.1/src/core/udp.c ****     src_ip = &(netif->ip_addr);
 797              		.loc 1 629 0 is_stmt 1
 798 00b0 3B6B     		ldr	r3, [r7, #48]
 799 00b2 0433     		adds	r3, r3, #4
 800 00b4 FB61     		str	r3, [r7, #28]
 801 00b6 12E0     		b	.L52
 802              	.L51:
 630:../lwip-1.4.1/src/core/udp.c ****   } else {
 631:../lwip-1.4.1/src/core/udp.c ****     /* check if UDP PCB local IP address is correct
 632:../lwip-1.4.1/src/core/udp.c ****      * this could be an old address if netif->ip_addr has changed */
 633:../lwip-1.4.1/src/core/udp.c ****     if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 803              		.loc 1 633 0
 804 00b8 FB68     		ldr	r3, [r7, #12]
 805 00ba 1A68     		ldr	r2, [r3]
 806 00bc 3B6B     		ldr	r3, [r7, #48]
 807 00be 5B68     		ldr	r3, [r3, #4]
 808 00c0 9A42     		cmp	r2, r3
 809 00c2 0AD0     		beq	.L53
 634:../lwip-1.4.1/src/core/udp.c ****       /* local_ip doesn't match, drop the packet */
 635:../lwip-1.4.1/src/core/udp.c ****       if (q != p) {
 810              		.loc 1 635 0
 811 00c4 BA69     		ldr	r2, [r7, #24]
 812 00c6 BB68     		ldr	r3, [r7, #8]
 813 00c8 9A42     		cmp	r2, r3
 814 00ca 04D0     		beq	.L54
 636:../lwip-1.4.1/src/core/udp.c ****         /* free the header pbuf */
 637:../lwip-1.4.1/src/core/udp.c ****         pbuf_free(q);
 815              		.loc 1 637 0
 816 00cc B869     		ldr	r0, [r7, #24]
 817 00ce FFF7FEFF 		bl	pbuf_free
 638:../lwip-1.4.1/src/core/udp.c ****         q = NULL;
 818              		.loc 1 638 0
 819 00d2 0023     		movs	r3, #0
 820 00d4 BB61     		str	r3, [r7, #24]
 821              	.L54:
 639:../lwip-1.4.1/src/core/udp.c ****         /* p is still referenced by the caller, and will live on */
 640:../lwip-1.4.1/src/core/udp.c ****       }
 641:../lwip-1.4.1/src/core/udp.c ****       return ERR_VAL;
 822              		.loc 1 641 0
 823 00d6 FA23     		movs	r3, #250
 824 00d8 2CE0     		b	.L45
 825              	.L53:
 642:../lwip-1.4.1/src/core/udp.c ****     }
 643:../lwip-1.4.1/src/core/udp.c ****     /* use UDP PCB local IP address as source address */
 644:../lwip-1.4.1/src/core/udp.c ****     src_ip = &(pcb->local_ip);
 826              		.loc 1 644 0
 827 00da FB68     		ldr	r3, [r7, #12]
 828 00dc FB61     		str	r3, [r7, #28]
 829              	.L52:
 645:../lwip-1.4.1/src/core/udp.c ****   }
 646:../lwip-1.4.1/src/core/udp.c **** 
 647:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
 648:../lwip-1.4.1/src/core/udp.c **** 
 649:../lwip-1.4.1/src/core/udp.c **** #if LWIP_UDPLITE
 650:../lwip-1.4.1/src/core/udp.c ****   /* UDP Lite protocol? */
 651:../lwip-1.4.1/src/core/udp.c ****   if (pcb->flags & UDP_FLAGS_UDPLITE) {
 652:../lwip-1.4.1/src/core/udp.c ****     u16_t chklen, chklen_hdr;
 653:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
 654:../lwip-1.4.1/src/core/udp.c ****     /* set UDP message length in UDP header */
 655:../lwip-1.4.1/src/core/udp.c ****     chklen_hdr = chklen = pcb->chksum_len_tx;
 656:../lwip-1.4.1/src/core/udp.c ****     if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
 657:../lwip-1.4.1/src/core/udp.c ****       if (chklen != 0) {
 658:../lwip-1.4.1/src/core/udp.c ****         LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen
 659:../lwip-1.4.1/src/core/udp.c ****       }
 660:../lwip-1.4.1/src/core/udp.c ****       /* For UDP-Lite, checksum length of 0 means checksum
 661:../lwip-1.4.1/src/core/udp.c ****          over the complete packet. (See RFC 3828 chap. 3.1)
 662:../lwip-1.4.1/src/core/udp.c ****          At least the UDP-Lite header must be covered by the
 663:../lwip-1.4.1/src/core/udp.c ****          checksum, therefore, if chksum_len has an illegal
 664:../lwip-1.4.1/src/core/udp.c ****          value, we generate the checksum over the complete
 665:../lwip-1.4.1/src/core/udp.c ****          packet to be safe. */
 666:../lwip-1.4.1/src/core/udp.c ****       chklen_hdr = 0;
 667:../lwip-1.4.1/src/core/udp.c ****       chklen = q->tot_len;
 668:../lwip-1.4.1/src/core/udp.c ****     }
 669:../lwip-1.4.1/src/core/udp.c ****     udphdr->len = htons(chklen_hdr);
 670:../lwip-1.4.1/src/core/udp.c ****     /* calculate checksum */
 671:../lwip-1.4.1/src/core/udp.c **** #if CHECKSUM_GEN_UDP
 672:../lwip-1.4.1/src/core/udp.c ****     udphdr->chksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip,
 673:../lwip-1.4.1/src/core/udp.c ****       IP_PROTO_UDPLITE, q->tot_len,
 674:../lwip-1.4.1/src/core/udp.c **** #if !LWIP_CHECKSUM_ON_COPY
 675:../lwip-1.4.1/src/core/udp.c ****       chklen);
 676:../lwip-1.4.1/src/core/udp.c **** #else /* !LWIP_CHECKSUM_ON_COPY */
 677:../lwip-1.4.1/src/core/udp.c ****       (have_chksum ? UDP_HLEN : chklen));
 678:../lwip-1.4.1/src/core/udp.c ****     if (have_chksum) {
 679:../lwip-1.4.1/src/core/udp.c ****       u32_t acc;
 680:../lwip-1.4.1/src/core/udp.c ****       acc = udphdr->chksum + (u16_t)~(chksum);
 681:../lwip-1.4.1/src/core/udp.c ****       udphdr->chksum = FOLD_U32T(acc);
 682:../lwip-1.4.1/src/core/udp.c ****     }
 683:../lwip-1.4.1/src/core/udp.c **** #endif /* !LWIP_CHECKSUM_ON_COPY */
 684:../lwip-1.4.1/src/core/udp.c **** 
 685:../lwip-1.4.1/src/core/udp.c ****     /* chksum zero must become 0xffff, as zero means 'no checksum' */
 686:../lwip-1.4.1/src/core/udp.c ****     if (udphdr->chksum == 0x0000) {
 687:../lwip-1.4.1/src/core/udp.c ****       udphdr->chksum = 0xffff;
 688:../lwip-1.4.1/src/core/udp.c ****     }
 689:../lwip-1.4.1/src/core/udp.c **** #endif /* CHECKSUM_GEN_UDP */
 690:../lwip-1.4.1/src/core/udp.c ****     /* output to IP */
 691:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
 692:../lwip-1.4.1/src/core/udp.c ****     NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
 693:../lwip-1.4.1/src/core/udp.c ****     err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);
 694:../lwip-1.4.1/src/core/udp.c ****     NETIF_SET_HWADDRHINT(netif, NULL);
 695:../lwip-1.4.1/src/core/udp.c ****   } else
 696:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_UDPLITE */
 697:../lwip-1.4.1/src/core/udp.c ****   {      /* UDP */
 698:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
 699:../lwip-1.4.1/src/core/udp.c ****     udphdr->len = htons(q->tot_len);
 830              		.loc 1 699 0
 831 00de BB69     		ldr	r3, [r7, #24]
 832 00e0 1B89     		ldrh	r3, [r3, #8]
 833 00e2 1846     		mov	r0, r3
 834 00e4 FFF7FEFF 		bl	lwip_htons
 835 00e8 0346     		mov	r3, r0
 836 00ea 1A46     		mov	r2, r3
 837 00ec 3B69     		ldr	r3, [r7, #16]
 838 00ee 9A80     		strh	r2, [r3, #4]	@ unaligned
 700:../lwip-1.4.1/src/core/udp.c ****     /* calculate checksum */
 701:../lwip-1.4.1/src/core/udp.c **** #if CHECKSUM_GEN_UDP
 702:../lwip-1.4.1/src/core/udp.c ****     if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 703:../lwip-1.4.1/src/core/udp.c ****       u16_t udpchksum;
 704:../lwip-1.4.1/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 705:../lwip-1.4.1/src/core/udp.c ****       if (have_chksum) {
 706:../lwip-1.4.1/src/core/udp.c ****         u32_t acc;
 707:../lwip-1.4.1/src/core/udp.c ****         udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
 708:../lwip-1.4.1/src/core/udp.c ****           q->tot_len, UDP_HLEN);
 709:../lwip-1.4.1/src/core/udp.c ****         acc = udpchksum + (u16_t)~(chksum);
 710:../lwip-1.4.1/src/core/udp.c ****         udpchksum = FOLD_U32T(acc);
 711:../lwip-1.4.1/src/core/udp.c ****       } else
 712:../lwip-1.4.1/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 713:../lwip-1.4.1/src/core/udp.c ****       {
 714:../lwip-1.4.1/src/core/udp.c ****         udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
 715:../lwip-1.4.1/src/core/udp.c ****       }
 716:../lwip-1.4.1/src/core/udp.c **** 
 717:../lwip-1.4.1/src/core/udp.c ****       /* chksum zero must become 0xffff, as zero means 'no checksum' */
 718:../lwip-1.4.1/src/core/udp.c ****       if (udpchksum == 0x0000) {
 719:../lwip-1.4.1/src/core/udp.c ****         udpchksum = 0xffff;
 720:../lwip-1.4.1/src/core/udp.c ****       }
 721:../lwip-1.4.1/src/core/udp.c ****       udphdr->chksum = udpchksum;
 722:../lwip-1.4.1/src/core/udp.c ****     }
 723:../lwip-1.4.1/src/core/udp.c **** #endif /* CHECKSUM_GEN_UDP */
 724:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
 725:../lwip-1.4.1/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
 726:../lwip-1.4.1/src/core/udp.c ****     /* output to IP */
 727:../lwip-1.4.1/src/core/udp.c ****     NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
 728:../lwip-1.4.1/src/core/udp.c ****     err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 839              		.loc 1 728 0
 840 00f0 FB68     		ldr	r3, [r7, #12]
 841 00f2 9C7A     		ldrb	r4, [r3, #10]	@ zero_extendqisi2
 842 00f4 FB68     		ldr	r3, [r7, #12]
 843 00f6 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 844 00f8 0093     		str	r3, [sp]
 845 00fa 1123     		movs	r3, #17
 846 00fc 0193     		str	r3, [sp, #4]
 847 00fe 3B6B     		ldr	r3, [r7, #48]
 848 0100 0293     		str	r3, [sp, #8]
 849 0102 B869     		ldr	r0, [r7, #24]
 850 0104 F969     		ldr	r1, [r7, #28]
 851 0106 7A68     		ldr	r2, [r7, #4]
 852 0108 2346     		mov	r3, r4
 853 010a FFF7FEFF 		bl	ip_output_if
 854 010e 0346     		mov	r3, r0
 855 0110 FB75     		strb	r3, [r7, #23]
 729:../lwip-1.4.1/src/core/udp.c ****     NETIF_SET_HWADDRHINT(netif, NULL);
 730:../lwip-1.4.1/src/core/udp.c ****   }
 731:../lwip-1.4.1/src/core/udp.c ****   /* TODO: must this be increased even if error occured? */
 732:../lwip-1.4.1/src/core/udp.c ****   snmp_inc_udpoutdatagrams();
 733:../lwip-1.4.1/src/core/udp.c **** 
 734:../lwip-1.4.1/src/core/udp.c ****   /* did we chain a separate header pbuf earlier? */
 735:../lwip-1.4.1/src/core/udp.c ****   if (q != p) {
 856              		.loc 1 735 0
 857 0112 BA69     		ldr	r2, [r7, #24]
 858 0114 BB68     		ldr	r3, [r7, #8]
 859 0116 9A42     		cmp	r2, r3
 860 0118 04D0     		beq	.L55
 736:../lwip-1.4.1/src/core/udp.c ****     /* free the header pbuf */
 737:../lwip-1.4.1/src/core/udp.c ****     pbuf_free(q);
 861              		.loc 1 737 0
 862 011a B869     		ldr	r0, [r7, #24]
 863 011c FFF7FEFF 		bl	pbuf_free
 738:../lwip-1.4.1/src/core/udp.c ****     q = NULL;
 864              		.loc 1 738 0
 865 0120 0023     		movs	r3, #0
 866 0122 BB61     		str	r3, [r7, #24]
 867              	.L55:
 739:../lwip-1.4.1/src/core/udp.c ****     /* p is still referenced by the caller, and will live on */
 740:../lwip-1.4.1/src/core/udp.c ****   }
 741:../lwip-1.4.1/src/core/udp.c **** 
 742:../lwip-1.4.1/src/core/udp.c ****   UDP_STATS_INC(udp.xmit);
 868              		.loc 1 742 0
 869 0124 064B     		ldr	r3, .L56
 870 0126 D3F8F030 		ldr	r3, [r3, #240]
 871 012a 0133     		adds	r3, r3, #1
 872 012c 044A     		ldr	r2, .L56
 873 012e C2F8F030 		str	r3, [r2, #240]
 743:../lwip-1.4.1/src/core/udp.c ****   return err;
 874              		.loc 1 743 0
 875 0132 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 876              	.L45:
 877 0134 5BB2     		sxtb	r3, r3
 744:../lwip-1.4.1/src/core/udp.c **** }
 878              		.loc 1 744 0
 879 0136 1846     		mov	r0, r3
 880 0138 2437     		adds	r7, r7, #36
 881              		.cfi_def_cfa_offset 12
 882 013a BD46     		mov	sp, r7
 883              		.cfi_def_cfa_register 13
 884              		@ sp needed
 885 013c 90BD     		pop	{r4, r7, pc}
 886              	.L57:
 887 013e 00BF     		.align	2
 888              	.L56:
 889 0140 00000000 		.word	lwip_stats
 890              		.cfi_endproc
 891              	.LFE5:
 893              		.section	.text.udp_bind,"ax",%progbits
 894              		.align	2
 895              		.global	udp_bind
 896              		.thumb
 897              		.thumb_func
 899              	udp_bind:
 900              	.LFB6:
 745:../lwip-1.4.1/src/core/udp.c **** 
 746:../lwip-1.4.1/src/core/udp.c **** /**
 747:../lwip-1.4.1/src/core/udp.c ****  * Bind an UDP PCB.
 748:../lwip-1.4.1/src/core/udp.c ****  *
 749:../lwip-1.4.1/src/core/udp.c ****  * @param pcb UDP PCB to be bound with a local address ipaddr and port.
 750:../lwip-1.4.1/src/core/udp.c ****  * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 751:../lwip-1.4.1/src/core/udp.c ****  * bind to all local interfaces.
 752:../lwip-1.4.1/src/core/udp.c ****  * @param port local UDP port to bind with. Use 0 to automatically bind
 753:../lwip-1.4.1/src/core/udp.c ****  * to a random port between UDP_LOCAL_PORT_RANGE_START and
 754:../lwip-1.4.1/src/core/udp.c ****  * UDP_LOCAL_PORT_RANGE_END.
 755:../lwip-1.4.1/src/core/udp.c ****  *
 756:../lwip-1.4.1/src/core/udp.c ****  * ipaddr & port are expected to be in the same byte order as in the pcb.
 757:../lwip-1.4.1/src/core/udp.c ****  *
 758:../lwip-1.4.1/src/core/udp.c ****  * @return lwIP error code.
 759:../lwip-1.4.1/src/core/udp.c ****  * - ERR_OK. Successful. No error occured.
 760:../lwip-1.4.1/src/core/udp.c ****  * - ERR_USE. The specified ipaddr and port are already bound to by
 761:../lwip-1.4.1/src/core/udp.c ****  * another UDP PCB.
 762:../lwip-1.4.1/src/core/udp.c ****  *
 763:../lwip-1.4.1/src/core/udp.c ****  * @see udp_disconnect()
 764:../lwip-1.4.1/src/core/udp.c ****  */
 765:../lwip-1.4.1/src/core/udp.c **** err_t
 766:../lwip-1.4.1/src/core/udp.c **** udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
 767:../lwip-1.4.1/src/core/udp.c **** {
 901              		.loc 1 767 0
 902              		.cfi_startproc
 903              		@ args = 0, pretend = 0, frame = 24
 904              		@ frame_needed = 1, uses_anonymous_args = 0
 905 0000 80B5     		push	{r7, lr}
 906              		.cfi_def_cfa_offset 8
 907              		.cfi_offset 7, -8
 908              		.cfi_offset 14, -4
 909 0002 86B0     		sub	sp, sp, #24
 910              		.cfi_def_cfa_offset 32
 911 0004 00AF     		add	r7, sp, #0
 912              		.cfi_def_cfa_register 7
 913 0006 F860     		str	r0, [r7, #12]
 914 0008 B960     		str	r1, [r7, #8]
 915 000a 1346     		mov	r3, r2
 916 000c FB80     		strh	r3, [r7, #6]	@ movhi
 768:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *ipcb;
 769:../lwip-1.4.1/src/core/udp.c ****   u8_t rebind;
 770:../lwip-1.4.1/src/core/udp.c **** 
 771:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
 772:../lwip-1.4.1/src/core/udp.c ****   ip_addr_debug_print(UDP_DEBUG, ipaddr);
 773:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
 774:../lwip-1.4.1/src/core/udp.c **** 
 775:../lwip-1.4.1/src/core/udp.c ****   rebind = 0;
 917              		.loc 1 775 0
 918 000e 0023     		movs	r3, #0
 919 0010 FB74     		strb	r3, [r7, #19]
 776:../lwip-1.4.1/src/core/udp.c ****   /* Check for double bind and rebind of the same pcb */
 777:../lwip-1.4.1/src/core/udp.c ****   for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 920              		.loc 1 777 0
 921 0012 2A4B     		ldr	r3, .L70
 922 0014 1B68     		ldr	r3, [r3]
 923 0016 7B61     		str	r3, [r7, #20]
 924 0018 24E0     		b	.L59
 925              	.L64:
 778:../lwip-1.4.1/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 779:../lwip-1.4.1/src/core/udp.c ****     if (pcb == ipcb) {
 926              		.loc 1 779 0
 927 001a FA68     		ldr	r2, [r7, #12]
 928 001c 7B69     		ldr	r3, [r7, #20]
 929 001e 9A42     		cmp	r2, r3
 930 0020 02D1     		bne	.L60
 780:../lwip-1.4.1/src/core/udp.c ****       /* pcb may occur at most once in active list */
 781:../lwip-1.4.1/src/core/udp.c ****       LWIP_ASSERT("rebind == 0", rebind == 0);
 782:../lwip-1.4.1/src/core/udp.c ****       /* pcb already in list, just rebind */
 783:../lwip-1.4.1/src/core/udp.c ****       rebind = 1;
 931              		.loc 1 783 0
 932 0022 0123     		movs	r3, #1
 933 0024 FB74     		strb	r3, [r7, #19]
 934 0026 1AE0     		b	.L61
 935              	.L60:
 784:../lwip-1.4.1/src/core/udp.c ****     }
 785:../lwip-1.4.1/src/core/udp.c **** 
 786:../lwip-1.4.1/src/core/udp.c ****     /* By default, we don't allow to bind to a port that any other udp
 787:../lwip-1.4.1/src/core/udp.c ****        PCB is alread bound to, unless *all* PCBs with that port have tha
 788:../lwip-1.4.1/src/core/udp.c ****        REUSEADDR flag set. */
 789:../lwip-1.4.1/src/core/udp.c **** #if SO_REUSE
 790:../lwip-1.4.1/src/core/udp.c ****     else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
 791:../lwip-1.4.1/src/core/udp.c ****              !ip_get_option(ipcb, SOF_REUSEADDR)) {
 792:../lwip-1.4.1/src/core/udp.c **** #else /* SO_REUSE */
 793:../lwip-1.4.1/src/core/udp.c ****     /* port matches that of PCB in list and REUSEADDR not set -> reject */
 794:../lwip-1.4.1/src/core/udp.c ****     else {
 795:../lwip-1.4.1/src/core/udp.c **** #endif /* SO_REUSE */
 796:../lwip-1.4.1/src/core/udp.c ****       if ((ipcb->local_port == port) &&
 936              		.loc 1 796 0
 937 0028 7B69     		ldr	r3, [r7, #20]
 938 002a 5B8A     		ldrh	r3, [r3, #18]
 939 002c FA88     		ldrh	r2, [r7, #6]
 940 002e 9A42     		cmp	r2, r3
 941 0030 15D1     		bne	.L61
 797:../lwip-1.4.1/src/core/udp.c ****           /* IP address matches, or one is IP_ADDR_ANY? */
 798:../lwip-1.4.1/src/core/udp.c ****           (ip_addr_isany(&(ipcb->local_ip)) ||
 942              		.loc 1 798 0 discriminator 1
 943 0032 7B69     		ldr	r3, [r7, #20]
 796:../lwip-1.4.1/src/core/udp.c ****           /* IP address matches, or one is IP_ADDR_ANY? */
 944              		.loc 1 796 0 discriminator 1
 945 0034 002B     		cmp	r3, #0
 946 0036 10D0     		beq	.L62
 947              		.loc 1 798 0
 948 0038 7B69     		ldr	r3, [r7, #20]
 949 003a 1B68     		ldr	r3, [r3]
 950 003c 002B     		cmp	r3, #0
 951 003e 0CD0     		beq	.L62
 952              		.loc 1 798 0 is_stmt 0 discriminator 1
 953 0040 BB68     		ldr	r3, [r7, #8]
 954 0042 002B     		cmp	r3, #0
 955 0044 09D0     		beq	.L62
 799:../lwip-1.4.1/src/core/udp.c ****            ip_addr_isany(ipaddr) ||
 956              		.loc 1 799 0 is_stmt 1
 957 0046 BB68     		ldr	r3, [r7, #8]
 958 0048 1B68     		ldr	r3, [r3]
 959 004a 002B     		cmp	r3, #0
 960 004c 05D0     		beq	.L62
 800:../lwip-1.4.1/src/core/udp.c ****            ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
 961              		.loc 1 800 0 discriminator 1
 962 004e 7B69     		ldr	r3, [r7, #20]
 963 0050 1A68     		ldr	r2, [r3]
 964 0052 BB68     		ldr	r3, [r7, #8]
 965 0054 1B68     		ldr	r3, [r3]
 799:../lwip-1.4.1/src/core/udp.c ****            ip_addr_isany(ipaddr) ||
 966              		.loc 1 799 0 discriminator 1
 967 0056 9A42     		cmp	r2, r3
 968 0058 01D1     		bne	.L61
 969              	.L62:
 801:../lwip-1.4.1/src/core/udp.c ****         /* other PCB already binds to this local IP and port */
 802:../lwip-1.4.1/src/core/udp.c ****         LWIP_DEBUGF(UDP_DEBUG,
 803:../lwip-1.4.1/src/core/udp.c ****                     ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
 804:../lwip-1.4.1/src/core/udp.c ****         return ERR_USE;
 970              		.loc 1 804 0
 971 005a F823     		movs	r3, #248
 972 005c 28E0     		b	.L63
 973              	.L61:
 777:../lwip-1.4.1/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 974              		.loc 1 777 0 discriminator 2
 975 005e 7B69     		ldr	r3, [r7, #20]
 976 0060 DB68     		ldr	r3, [r3, #12]
 977 0062 7B61     		str	r3, [r7, #20]
 978              	.L59:
 777:../lwip-1.4.1/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 979              		.loc 1 777 0 is_stmt 0 discriminator 1
 980 0064 7B69     		ldr	r3, [r7, #20]
 981 0066 002B     		cmp	r3, #0
 982 0068 D7D1     		bne	.L64
 805:../lwip-1.4.1/src/core/udp.c ****       }
 806:../lwip-1.4.1/src/core/udp.c ****     }
 807:../lwip-1.4.1/src/core/udp.c ****   }
 808:../lwip-1.4.1/src/core/udp.c **** 
 809:../lwip-1.4.1/src/core/udp.c ****   ip_addr_set(&pcb->local_ip, ipaddr);
 983              		.loc 1 809 0 is_stmt 1
 984 006a BB68     		ldr	r3, [r7, #8]
 985 006c 002B     		cmp	r3, #0
 986 006e 02D0     		beq	.L65
 987              		.loc 1 809 0 is_stmt 0 discriminator 1
 988 0070 BB68     		ldr	r3, [r7, #8]
 989 0072 1B68     		ldr	r3, [r3]
 990 0074 00E0     		b	.L66
 991              	.L65:
 992              		.loc 1 809 0 discriminator 2
 993 0076 0023     		movs	r3, #0
 994              	.L66:
 995              		.loc 1 809 0 discriminator 4
 996 0078 FA68     		ldr	r2, [r7, #12]
 997 007a 1360     		str	r3, [r2]
 810:../lwip-1.4.1/src/core/udp.c **** 
 811:../lwip-1.4.1/src/core/udp.c ****   /* no port specified? */
 812:../lwip-1.4.1/src/core/udp.c ****   if (port == 0) {
 998              		.loc 1 812 0 is_stmt 1 discriminator 4
 999 007c FB88     		ldrh	r3, [r7, #6]
 1000 007e 002B     		cmp	r3, #0
 1001 0080 08D1     		bne	.L67
 813:../lwip-1.4.1/src/core/udp.c ****     port = udp_new_port();
 1002              		.loc 1 813 0
 1003 0082 FFF7FEFF 		bl	udp_new_port
 1004 0086 0346     		mov	r3, r0
 1005 0088 FB80     		strh	r3, [r7, #6]	@ movhi
 814:../lwip-1.4.1/src/core/udp.c ****     if (port == 0) {
 1006              		.loc 1 814 0
 1007 008a FB88     		ldrh	r3, [r7, #6]
 1008 008c 002B     		cmp	r3, #0
 1009 008e 01D1     		bne	.L67
 815:../lwip-1.4.1/src/core/udp.c ****       /* no more ports available in local range */
 816:../lwip-1.4.1/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
 817:../lwip-1.4.1/src/core/udp.c ****       return ERR_USE;
 1010              		.loc 1 817 0
 1011 0090 F823     		movs	r3, #248
 1012 0092 0DE0     		b	.L63
 1013              	.L67:
 818:../lwip-1.4.1/src/core/udp.c ****     }
 819:../lwip-1.4.1/src/core/udp.c ****   }
 820:../lwip-1.4.1/src/core/udp.c ****   pcb->local_port = port;
 1014              		.loc 1 820 0
 1015 0094 FB68     		ldr	r3, [r7, #12]
 1016 0096 FA88     		ldrh	r2, [r7, #6]	@ movhi
 1017 0098 5A82     		strh	r2, [r3, #18]	@ movhi
 821:../lwip-1.4.1/src/core/udp.c ****   snmp_insert_udpidx_tree(pcb);
 822:../lwip-1.4.1/src/core/udp.c ****   /* pcb not active yet? */
 823:../lwip-1.4.1/src/core/udp.c ****   if (rebind == 0) {
 1018              		.loc 1 823 0
 1019 009a FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1020 009c 002B     		cmp	r3, #0
 1021 009e 06D1     		bne	.L69
 824:../lwip-1.4.1/src/core/udp.c ****     /* place the PCB on the active list if not already there */
 825:../lwip-1.4.1/src/core/udp.c ****     pcb->next = udp_pcbs;
 1022              		.loc 1 825 0
 1023 00a0 064B     		ldr	r3, .L70
 1024 00a2 1A68     		ldr	r2, [r3]
 1025 00a4 FB68     		ldr	r3, [r7, #12]
 1026 00a6 DA60     		str	r2, [r3, #12]
 826:../lwip-1.4.1/src/core/udp.c ****     udp_pcbs = pcb;
 1027              		.loc 1 826 0
 1028 00a8 044A     		ldr	r2, .L70
 1029 00aa FB68     		ldr	r3, [r7, #12]
 1030 00ac 1360     		str	r3, [r2]
 1031              	.L69:
 827:../lwip-1.4.1/src/core/udp.c ****   }
 828:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
 829:../lwip-1.4.1/src/core/udp.c ****               ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
 830:../lwip-1.4.1/src/core/udp.c ****                ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
 831:../lwip-1.4.1/src/core/udp.c ****                ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
 832:../lwip-1.4.1/src/core/udp.c ****                pcb->local_port));
 833:../lwip-1.4.1/src/core/udp.c ****   return ERR_OK;
 1032              		.loc 1 833 0
 1033 00ae 0023     		movs	r3, #0
 1034              	.L63:
 1035 00b0 5BB2     		sxtb	r3, r3
 834:../lwip-1.4.1/src/core/udp.c **** }
 1036              		.loc 1 834 0
 1037 00b2 1846     		mov	r0, r3
 1038 00b4 1837     		adds	r7, r7, #24
 1039              		.cfi_def_cfa_offset 8
 1040 00b6 BD46     		mov	sp, r7
 1041              		.cfi_def_cfa_register 13
 1042              		@ sp needed
 1043 00b8 80BD     		pop	{r7, pc}
 1044              	.L71:
 1045 00ba 00BF     		.align	2
 1046              	.L70:
 1047 00bc 00000000 		.word	udp_pcbs
 1048              		.cfi_endproc
 1049              	.LFE6:
 1051              		.section	.text.udp_connect,"ax",%progbits
 1052              		.align	2
 1053              		.global	udp_connect
 1054              		.thumb
 1055              		.thumb_func
 1057              	udp_connect:
 1058              	.LFB7:
 835:../lwip-1.4.1/src/core/udp.c **** /**
 836:../lwip-1.4.1/src/core/udp.c ****  * Connect an UDP PCB.
 837:../lwip-1.4.1/src/core/udp.c ****  *
 838:../lwip-1.4.1/src/core/udp.c ****  * This will associate the UDP PCB with the remote address.
 839:../lwip-1.4.1/src/core/udp.c ****  *
 840:../lwip-1.4.1/src/core/udp.c ****  * @param pcb UDP PCB to be connected with remote address ipaddr and port.
 841:../lwip-1.4.1/src/core/udp.c ****  * @param ipaddr remote IP address to connect with.
 842:../lwip-1.4.1/src/core/udp.c ****  * @param port remote UDP port to connect with.
 843:../lwip-1.4.1/src/core/udp.c ****  *
 844:../lwip-1.4.1/src/core/udp.c ****  * @return lwIP error code
 845:../lwip-1.4.1/src/core/udp.c ****  *
 846:../lwip-1.4.1/src/core/udp.c ****  * ipaddr & port are expected to be in the same byte order as in the pcb.
 847:../lwip-1.4.1/src/core/udp.c ****  *
 848:../lwip-1.4.1/src/core/udp.c ****  * The udp pcb is bound to a random local port if not already bound.
 849:../lwip-1.4.1/src/core/udp.c ****  *
 850:../lwip-1.4.1/src/core/udp.c ****  * @see udp_disconnect()
 851:../lwip-1.4.1/src/core/udp.c ****  */
 852:../lwip-1.4.1/src/core/udp.c **** err_t
 853:../lwip-1.4.1/src/core/udp.c **** udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
 854:../lwip-1.4.1/src/core/udp.c **** {
 1059              		.loc 1 854 0
 1060              		.cfi_startproc
 1061              		@ args = 0, pretend = 0, frame = 24
 1062              		@ frame_needed = 1, uses_anonymous_args = 0
 1063 0000 80B5     		push	{r7, lr}
 1064              		.cfi_def_cfa_offset 8
 1065              		.cfi_offset 7, -8
 1066              		.cfi_offset 14, -4
 1067 0002 86B0     		sub	sp, sp, #24
 1068              		.cfi_def_cfa_offset 32
 1069 0004 00AF     		add	r7, sp, #0
 1070              		.cfi_def_cfa_register 7
 1071 0006 F860     		str	r0, [r7, #12]
 1072 0008 B960     		str	r1, [r7, #8]
 1073 000a 1346     		mov	r3, r2
 1074 000c FB80     		strh	r3, [r7, #6]	@ movhi
 855:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *ipcb;
 856:../lwip-1.4.1/src/core/udp.c **** 
 857:../lwip-1.4.1/src/core/udp.c ****   if (pcb->local_port == 0) {
 1075              		.loc 1 857 0
 1076 000e FB68     		ldr	r3, [r7, #12]
 1077 0010 5B8A     		ldrh	r3, [r3, #18]
 1078 0012 002B     		cmp	r3, #0
 1079 0014 0FD1     		bne	.L73
 1080              	.LBB2:
 858:../lwip-1.4.1/src/core/udp.c ****     err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 1081              		.loc 1 858 0
 1082 0016 FA68     		ldr	r2, [r7, #12]
 1083 0018 FB68     		ldr	r3, [r7, #12]
 1084 001a 5B8A     		ldrh	r3, [r3, #18]
 1085 001c F868     		ldr	r0, [r7, #12]
 1086 001e 1146     		mov	r1, r2
 1087 0020 1A46     		mov	r2, r3
 1088 0022 FFF7FEFF 		bl	udp_bind
 1089 0026 0346     		mov	r3, r0
 1090 0028 FB74     		strb	r3, [r7, #19]
 859:../lwip-1.4.1/src/core/udp.c ****     if (err != ERR_OK) {
 1091              		.loc 1 859 0
 1092 002a 97F91330 		ldrsb	r3, [r7, #19]
 1093 002e 002B     		cmp	r3, #0
 1094 0030 01D0     		beq	.L73
 860:../lwip-1.4.1/src/core/udp.c ****       return err;
 1095              		.loc 1 860 0
 1096 0032 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1097 0034 2AE0     		b	.L74
 1098              	.L73:
 1099              	.LBE2:
 861:../lwip-1.4.1/src/core/udp.c ****     }
 862:../lwip-1.4.1/src/core/udp.c ****   }
 863:../lwip-1.4.1/src/core/udp.c **** 
 864:../lwip-1.4.1/src/core/udp.c ****   ip_addr_set(&pcb->remote_ip, ipaddr);
 1100              		.loc 1 864 0
 1101 0036 BB68     		ldr	r3, [r7, #8]
 1102 0038 002B     		cmp	r3, #0
 1103 003a 02D0     		beq	.L75
 1104              		.loc 1 864 0 is_stmt 0 discriminator 1
 1105 003c BB68     		ldr	r3, [r7, #8]
 1106 003e 1B68     		ldr	r3, [r3]
 1107 0040 00E0     		b	.L76
 1108              	.L75:
 1109              		.loc 1 864 0 discriminator 2
 1110 0042 0023     		movs	r3, #0
 1111              	.L76:
 1112              		.loc 1 864 0 discriminator 4
 1113 0044 FA68     		ldr	r2, [r7, #12]
 1114 0046 5360     		str	r3, [r2, #4]
 865:../lwip-1.4.1/src/core/udp.c ****   pcb->remote_port = port;
 1115              		.loc 1 865 0 is_stmt 1 discriminator 4
 1116 0048 FB68     		ldr	r3, [r7, #12]
 1117 004a FA88     		ldrh	r2, [r7, #6]	@ movhi
 1118 004c 9A82     		strh	r2, [r3, #20]	@ movhi
 866:../lwip-1.4.1/src/core/udp.c ****   pcb->flags |= UDP_FLAGS_CONNECTED;
 1119              		.loc 1 866 0 discriminator 4
 1120 004e FB68     		ldr	r3, [r7, #12]
 1121 0050 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1122 0052 43F00403 		orr	r3, r3, #4
 1123 0056 DAB2     		uxtb	r2, r3
 1124 0058 FB68     		ldr	r3, [r7, #12]
 1125 005a 1A74     		strb	r2, [r3, #16]
 867:../lwip-1.4.1/src/core/udp.c **** /** TODO: this functionality belongs in upper layers */
 868:../lwip-1.4.1/src/core/udp.c **** #ifdef LWIP_UDP_TODO
 869:../lwip-1.4.1/src/core/udp.c ****   /* Nail down local IP for netconn_addr()/getsockname() */
 870:../lwip-1.4.1/src/core/udp.c ****   if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
 871:../lwip-1.4.1/src/core/udp.c ****     struct netif *netif;
 872:../lwip-1.4.1/src/core/udp.c **** 
 873:../lwip-1.4.1/src/core/udp.c ****     if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
 874:../lwip-1.4.1/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
 875:../lwip-1.4.1/src/core/udp.c ****       UDP_STATS_INC(udp.rterr);
 876:../lwip-1.4.1/src/core/udp.c ****       return ERR_RTE;
 877:../lwip-1.4.1/src/core/udp.c ****     }
 878:../lwip-1.4.1/src/core/udp.c ****     /** TODO: this will bind the udp pcb locally, to the interface which
 879:../lwip-1.4.1/src/core/udp.c ****         is used to route output packets to the remote address. However, we
 880:../lwip-1.4.1/src/core/udp.c ****         might want to accept incoming packets on any interface! */
 881:../lwip-1.4.1/src/core/udp.c ****     pcb->local_ip = netif->ip_addr;
 882:../lwip-1.4.1/src/core/udp.c ****   } else if (ip_addr_isany(&pcb->remote_ip)) {
 883:../lwip-1.4.1/src/core/udp.c ****     pcb->local_ip.addr = 0;
 884:../lwip-1.4.1/src/core/udp.c ****   }
 885:../lwip-1.4.1/src/core/udp.c **** #endif
 886:../lwip-1.4.1/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
 887:../lwip-1.4.1/src/core/udp.c ****               ("udp_connect: connected to %"U16_F".%"U16_F".%"U16_F".%"U16_F",port %"U16_F"\n",
 888:../lwip-1.4.1/src/core/udp.c ****                ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
 889:../lwip-1.4.1/src/core/udp.c ****                ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
 890:../lwip-1.4.1/src/core/udp.c ****                pcb->local_port));
 891:../lwip-1.4.1/src/core/udp.c **** 
 892:../lwip-1.4.1/src/core/udp.c ****   /* Insert UDP PCB into the list of active UDP PCBs. */
 893:../lwip-1.4.1/src/core/udp.c ****   for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 1126              		.loc 1 893 0 discriminator 4
 1127 005c 0E4B     		ldr	r3, .L80
 1128 005e 1B68     		ldr	r3, [r3]
 1129 0060 7B61     		str	r3, [r7, #20]
 1130 0062 08E0     		b	.L77
 1131              	.L79:
 894:../lwip-1.4.1/src/core/udp.c ****     if (pcb == ipcb) {
 1132              		.loc 1 894 0
 1133 0064 FA68     		ldr	r2, [r7, #12]
 1134 0066 7B69     		ldr	r3, [r7, #20]
 1135 0068 9A42     		cmp	r2, r3
 1136 006a 01D1     		bne	.L78
 895:../lwip-1.4.1/src/core/udp.c ****       /* already on the list, just return */
 896:../lwip-1.4.1/src/core/udp.c ****       return ERR_OK;
 1137              		.loc 1 896 0
 1138 006c 0023     		movs	r3, #0
 1139 006e 0DE0     		b	.L74
 1140              	.L78:
 893:../lwip-1.4.1/src/core/udp.c ****     if (pcb == ipcb) {
 1141              		.loc 1 893 0 discriminator 2
 1142 0070 7B69     		ldr	r3, [r7, #20]
 1143 0072 DB68     		ldr	r3, [r3, #12]
 1144 0074 7B61     		str	r3, [r7, #20]
 1145              	.L77:
 893:../lwip-1.4.1/src/core/udp.c ****     if (pcb == ipcb) {
 1146              		.loc 1 893 0 is_stmt 0 discriminator 1
 1147 0076 7B69     		ldr	r3, [r7, #20]
 1148 0078 002B     		cmp	r3, #0
 1149 007a F3D1     		bne	.L79
 897:../lwip-1.4.1/src/core/udp.c ****     }
 898:../lwip-1.4.1/src/core/udp.c ****   }
 899:../lwip-1.4.1/src/core/udp.c ****   /* PCB not yet on the list, add PCB now */
 900:../lwip-1.4.1/src/core/udp.c ****   pcb->next = udp_pcbs;
 1150              		.loc 1 900 0 is_stmt 1
 1151 007c 064B     		ldr	r3, .L80
 1152 007e 1A68     		ldr	r2, [r3]
 1153 0080 FB68     		ldr	r3, [r7, #12]
 1154 0082 DA60     		str	r2, [r3, #12]
 901:../lwip-1.4.1/src/core/udp.c ****   udp_pcbs = pcb;
 1155              		.loc 1 901 0
 1156 0084 044A     		ldr	r2, .L80
 1157 0086 FB68     		ldr	r3, [r7, #12]
 1158 0088 1360     		str	r3, [r2]
 902:../lwip-1.4.1/src/core/udp.c ****   return ERR_OK;
 1159              		.loc 1 902 0
 1160 008a 0023     		movs	r3, #0
 1161              	.L74:
 1162 008c 5BB2     		sxtb	r3, r3
 903:../lwip-1.4.1/src/core/udp.c **** }
 1163              		.loc 1 903 0
 1164 008e 1846     		mov	r0, r3
 1165 0090 1837     		adds	r7, r7, #24
 1166              		.cfi_def_cfa_offset 8
 1167 0092 BD46     		mov	sp, r7
 1168              		.cfi_def_cfa_register 13
 1169              		@ sp needed
 1170 0094 80BD     		pop	{r7, pc}
 1171              	.L81:
 1172 0096 00BF     		.align	2
 1173              	.L80:
 1174 0098 00000000 		.word	udp_pcbs
 1175              		.cfi_endproc
 1176              	.LFE7:
 1178              		.section	.text.udp_disconnect,"ax",%progbits
 1179              		.align	2
 1180              		.global	udp_disconnect
 1181              		.thumb
 1182              		.thumb_func
 1184              	udp_disconnect:
 1185              	.LFB8:
 904:../lwip-1.4.1/src/core/udp.c **** 
 905:../lwip-1.4.1/src/core/udp.c **** /**
 906:../lwip-1.4.1/src/core/udp.c ****  * Disconnect a UDP PCB
 907:../lwip-1.4.1/src/core/udp.c ****  *
 908:../lwip-1.4.1/src/core/udp.c ****  * @param pcb the udp pcb to disconnect.
 909:../lwip-1.4.1/src/core/udp.c ****  */
 910:../lwip-1.4.1/src/core/udp.c **** void
 911:../lwip-1.4.1/src/core/udp.c **** udp_disconnect(struct udp_pcb *pcb)
 912:../lwip-1.4.1/src/core/udp.c **** {
 1186              		.loc 1 912 0
 1187              		.cfi_startproc
 1188              		@ args = 0, pretend = 0, frame = 8
 1189              		@ frame_needed = 1, uses_anonymous_args = 0
 1190              		@ link register save eliminated.
 1191 0000 80B4     		push	{r7}
 1192              		.cfi_def_cfa_offset 4
 1193              		.cfi_offset 7, -4
 1194 0002 83B0     		sub	sp, sp, #12
 1195              		.cfi_def_cfa_offset 16
 1196 0004 00AF     		add	r7, sp, #0
 1197              		.cfi_def_cfa_register 7
 1198 0006 7860     		str	r0, [r7, #4]
 913:../lwip-1.4.1/src/core/udp.c ****   /* reset remote address association */
 914:../lwip-1.4.1/src/core/udp.c ****   ip_addr_set_any(&pcb->remote_ip);
 1199              		.loc 1 914 0
 1200 0008 7B68     		ldr	r3, [r7, #4]
 1201 000a 0022     		movs	r2, #0
 1202 000c 5A60     		str	r2, [r3, #4]
 915:../lwip-1.4.1/src/core/udp.c ****   pcb->remote_port = 0;
 1203              		.loc 1 915 0
 1204 000e 7B68     		ldr	r3, [r7, #4]
 1205 0010 0022     		movs	r2, #0
 1206 0012 9A82     		strh	r2, [r3, #20]	@ movhi
 916:../lwip-1.4.1/src/core/udp.c ****   /* mark PCB as unconnected */
 917:../lwip-1.4.1/src/core/udp.c ****   pcb->flags &= ~UDP_FLAGS_CONNECTED;
 1207              		.loc 1 917 0
 1208 0014 7B68     		ldr	r3, [r7, #4]
 1209 0016 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1210 0018 23F00403 		bic	r3, r3, #4
 1211 001c DAB2     		uxtb	r2, r3
 1212 001e 7B68     		ldr	r3, [r7, #4]
 1213 0020 1A74     		strb	r2, [r3, #16]
 918:../lwip-1.4.1/src/core/udp.c **** }
 1214              		.loc 1 918 0
 1215 0022 0C37     		adds	r7, r7, #12
 1216              		.cfi_def_cfa_offset 4
 1217 0024 BD46     		mov	sp, r7
 1218              		.cfi_def_cfa_register 13
 1219              		@ sp needed
 1220 0026 5DF8047B 		ldr	r7, [sp], #4
 1221              		.cfi_restore 7
 1222              		.cfi_def_cfa_offset 0
 1223 002a 7047     		bx	lr
 1224              		.cfi_endproc
 1225              	.LFE8:
 1227              		.section	.text.udp_recv,"ax",%progbits
 1228              		.align	2
 1229              		.global	udp_recv
 1230              		.thumb
 1231              		.thumb_func
 1233              	udp_recv:
 1234              	.LFB9:
 919:../lwip-1.4.1/src/core/udp.c **** 
 920:../lwip-1.4.1/src/core/udp.c **** /**
 921:../lwip-1.4.1/src/core/udp.c ****  * Set a receive callback for a UDP PCB
 922:../lwip-1.4.1/src/core/udp.c ****  *
 923:../lwip-1.4.1/src/core/udp.c ****  * This callback will be called when receiving a datagram for the pcb.
 924:../lwip-1.4.1/src/core/udp.c ****  *
 925:../lwip-1.4.1/src/core/udp.c ****  * @param pcb the pcb for wich to set the recv callback
 926:../lwip-1.4.1/src/core/udp.c ****  * @param recv function pointer of the callback function
 927:../lwip-1.4.1/src/core/udp.c ****  * @param recv_arg additional argument to pass to the callback function
 928:../lwip-1.4.1/src/core/udp.c ****  */
 929:../lwip-1.4.1/src/core/udp.c **** void
 930:../lwip-1.4.1/src/core/udp.c **** udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
 931:../lwip-1.4.1/src/core/udp.c **** {
 1235              		.loc 1 931 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 16
 1238              		@ frame_needed = 1, uses_anonymous_args = 0
 1239              		@ link register save eliminated.
 1240 0000 80B4     		push	{r7}
 1241              		.cfi_def_cfa_offset 4
 1242              		.cfi_offset 7, -4
 1243 0002 85B0     		sub	sp, sp, #20
 1244              		.cfi_def_cfa_offset 24
 1245 0004 00AF     		add	r7, sp, #0
 1246              		.cfi_def_cfa_register 7
 1247 0006 F860     		str	r0, [r7, #12]
 1248 0008 B960     		str	r1, [r7, #8]
 1249 000a 7A60     		str	r2, [r7, #4]
 932:../lwip-1.4.1/src/core/udp.c ****   /* remember recv() callback and user data */
 933:../lwip-1.4.1/src/core/udp.c ****   pcb->recv = recv;
 1250              		.loc 1 933 0
 1251 000c FB68     		ldr	r3, [r7, #12]
 1252 000e BA68     		ldr	r2, [r7, #8]
 1253 0010 9A61     		str	r2, [r3, #24]
 934:../lwip-1.4.1/src/core/udp.c ****   pcb->recv_arg = recv_arg;
 1254              		.loc 1 934 0
 1255 0012 FB68     		ldr	r3, [r7, #12]
 1256 0014 7A68     		ldr	r2, [r7, #4]
 1257 0016 DA61     		str	r2, [r3, #28]
 935:../lwip-1.4.1/src/core/udp.c **** }
 1258              		.loc 1 935 0
 1259 0018 1437     		adds	r7, r7, #20
 1260              		.cfi_def_cfa_offset 4
 1261 001a BD46     		mov	sp, r7
 1262              		.cfi_def_cfa_register 13
 1263              		@ sp needed
 1264 001c 5DF8047B 		ldr	r7, [sp], #4
 1265              		.cfi_restore 7
 1266              		.cfi_def_cfa_offset 0
 1267 0020 7047     		bx	lr
 1268              		.cfi_endproc
 1269              	.LFE9:
 1271 0022 00BF     		.section	.text.udp_remove,"ax",%progbits
 1272              		.align	2
 1273              		.global	udp_remove
 1274              		.thumb
 1275              		.thumb_func
 1277              	udp_remove:
 1278              	.LFB10:
 936:../lwip-1.4.1/src/core/udp.c **** 
 937:../lwip-1.4.1/src/core/udp.c **** /**
 938:../lwip-1.4.1/src/core/udp.c ****  * Remove an UDP PCB.
 939:../lwip-1.4.1/src/core/udp.c ****  *
 940:../lwip-1.4.1/src/core/udp.c ****  * @param pcb UDP PCB to be removed. The PCB is removed from the list of
 941:../lwip-1.4.1/src/core/udp.c ****  * UDP PCB's and the data structure is freed from memory.
 942:../lwip-1.4.1/src/core/udp.c ****  *
 943:../lwip-1.4.1/src/core/udp.c ****  * @see udp_new()
 944:../lwip-1.4.1/src/core/udp.c ****  */
 945:../lwip-1.4.1/src/core/udp.c **** void
 946:../lwip-1.4.1/src/core/udp.c **** udp_remove(struct udp_pcb *pcb)
 947:../lwip-1.4.1/src/core/udp.c **** {
 1279              		.loc 1 947 0
 1280              		.cfi_startproc
 1281              		@ args = 0, pretend = 0, frame = 16
 1282              		@ frame_needed = 1, uses_anonymous_args = 0
 1283 0000 80B5     		push	{r7, lr}
 1284              		.cfi_def_cfa_offset 8
 1285              		.cfi_offset 7, -8
 1286              		.cfi_offset 14, -4
 1287 0002 84B0     		sub	sp, sp, #16
 1288              		.cfi_def_cfa_offset 24
 1289 0004 00AF     		add	r7, sp, #0
 1290              		.cfi_def_cfa_register 7
 1291 0006 7860     		str	r0, [r7, #4]
 948:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *pcb2;
 949:../lwip-1.4.1/src/core/udp.c **** 
 950:../lwip-1.4.1/src/core/udp.c ****   snmp_delete_udpidx_tree(pcb);
 951:../lwip-1.4.1/src/core/udp.c ****   /* pcb to be removed is first in list? */
 952:../lwip-1.4.1/src/core/udp.c ****   if (udp_pcbs == pcb) {
 1292              		.loc 1 952 0
 1293 0008 144B     		ldr	r3, .L90
 1294 000a 1A68     		ldr	r2, [r3]
 1295 000c 7B68     		ldr	r3, [r7, #4]
 1296 000e 9A42     		cmp	r2, r3
 1297 0010 05D1     		bne	.L85
 953:../lwip-1.4.1/src/core/udp.c ****     /* make list start at 2nd pcb */
 954:../lwip-1.4.1/src/core/udp.c ****     udp_pcbs = udp_pcbs->next;
 1298              		.loc 1 954 0
 1299 0012 124B     		ldr	r3, .L90
 1300 0014 1B68     		ldr	r3, [r3]
 1301 0016 DB68     		ldr	r3, [r3, #12]
 1302 0018 104A     		ldr	r2, .L90
 1303 001a 1360     		str	r3, [r2]
 1304 001c 16E0     		b	.L86
 1305              	.L85:
 955:../lwip-1.4.1/src/core/udp.c ****     /* pcb not 1st in list */
 956:../lwip-1.4.1/src/core/udp.c ****   } else {
 957:../lwip-1.4.1/src/core/udp.c ****     for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 1306              		.loc 1 957 0
 1307 001e 0F4B     		ldr	r3, .L90
 1308 0020 1B68     		ldr	r3, [r3]
 1309 0022 FB60     		str	r3, [r7, #12]
 1310 0024 0FE0     		b	.L87
 1311              	.L89:
 958:../lwip-1.4.1/src/core/udp.c ****       /* find pcb in udp_pcbs list */
 959:../lwip-1.4.1/src/core/udp.c ****       if (pcb2->next != NULL && pcb2->next == pcb) {
 1312              		.loc 1 959 0
 1313 0026 FB68     		ldr	r3, [r7, #12]
 1314 0028 DB68     		ldr	r3, [r3, #12]
 1315 002a 002B     		cmp	r3, #0
 1316 002c 08D0     		beq	.L88
 1317              		.loc 1 959 0 is_stmt 0 discriminator 1
 1318 002e FB68     		ldr	r3, [r7, #12]
 1319 0030 DA68     		ldr	r2, [r3, #12]
 1320 0032 7B68     		ldr	r3, [r7, #4]
 1321 0034 9A42     		cmp	r2, r3
 1322 0036 03D1     		bne	.L88
 960:../lwip-1.4.1/src/core/udp.c ****         /* remove pcb from list */
 961:../lwip-1.4.1/src/core/udp.c ****         pcb2->next = pcb->next;
 1323              		.loc 1 961 0 is_stmt 1
 1324 0038 7B68     		ldr	r3, [r7, #4]
 1325 003a DA68     		ldr	r2, [r3, #12]
 1326 003c FB68     		ldr	r3, [r7, #12]
 1327 003e DA60     		str	r2, [r3, #12]
 1328              	.L88:
 957:../lwip-1.4.1/src/core/udp.c ****       /* find pcb in udp_pcbs list */
 1329              		.loc 1 957 0 discriminator 2
 1330 0040 FB68     		ldr	r3, [r7, #12]
 1331 0042 DB68     		ldr	r3, [r3, #12]
 1332 0044 FB60     		str	r3, [r7, #12]
 1333              	.L87:
 957:../lwip-1.4.1/src/core/udp.c ****       /* find pcb in udp_pcbs list */
 1334              		.loc 1 957 0 is_stmt 0 discriminator 1
 1335 0046 FB68     		ldr	r3, [r7, #12]
 1336 0048 002B     		cmp	r3, #0
 1337 004a ECD1     		bne	.L89
 1338              	.L86:
 962:../lwip-1.4.1/src/core/udp.c ****       }
 963:../lwip-1.4.1/src/core/udp.c ****     }
 964:../lwip-1.4.1/src/core/udp.c ****   }
 965:../lwip-1.4.1/src/core/udp.c ****   memp_free(MEMP_UDP_PCB, pcb);
 1339              		.loc 1 965 0 is_stmt 1
 1340 004c 0120     		movs	r0, #1
 1341 004e 7968     		ldr	r1, [r7, #4]
 1342 0050 FFF7FEFF 		bl	memp_free
 966:../lwip-1.4.1/src/core/udp.c **** }
 1343              		.loc 1 966 0
 1344 0054 1037     		adds	r7, r7, #16
 1345              		.cfi_def_cfa_offset 8
 1346 0056 BD46     		mov	sp, r7
 1347              		.cfi_def_cfa_register 13
 1348              		@ sp needed
 1349 0058 80BD     		pop	{r7, pc}
 1350              	.L91:
 1351 005a 00BF     		.align	2
 1352              	.L90:
 1353 005c 00000000 		.word	udp_pcbs
 1354              		.cfi_endproc
 1355              	.LFE10:
 1357              		.section	.text.udp_new,"ax",%progbits
 1358              		.align	2
 1359              		.global	udp_new
 1360              		.thumb
 1361              		.thumb_func
 1363              	udp_new:
 1364              	.LFB11:
 967:../lwip-1.4.1/src/core/udp.c **** 
 968:../lwip-1.4.1/src/core/udp.c **** /**
 969:../lwip-1.4.1/src/core/udp.c ****  * Create a UDP PCB.
 970:../lwip-1.4.1/src/core/udp.c ****  *
 971:../lwip-1.4.1/src/core/udp.c ****  * @return The UDP PCB which was created. NULL if the PCB data structure
 972:../lwip-1.4.1/src/core/udp.c ****  * could not be allocated.
 973:../lwip-1.4.1/src/core/udp.c ****  *
 974:../lwip-1.4.1/src/core/udp.c ****  * @see udp_remove()
 975:../lwip-1.4.1/src/core/udp.c ****  */
 976:../lwip-1.4.1/src/core/udp.c **** struct udp_pcb *
 977:../lwip-1.4.1/src/core/udp.c **** udp_new(void)
 978:../lwip-1.4.1/src/core/udp.c **** {
 1365              		.loc 1 978 0
 1366              		.cfi_startproc
 1367              		@ args = 0, pretend = 0, frame = 8
 1368              		@ frame_needed = 1, uses_anonymous_args = 0
 1369 0000 80B5     		push	{r7, lr}
 1370              		.cfi_def_cfa_offset 8
 1371              		.cfi_offset 7, -8
 1372              		.cfi_offset 14, -4
 1373 0002 82B0     		sub	sp, sp, #8
 1374              		.cfi_def_cfa_offset 16
 1375 0004 00AF     		add	r7, sp, #0
 1376              		.cfi_def_cfa_register 7
 979:../lwip-1.4.1/src/core/udp.c ****   struct udp_pcb *pcb;
 980:../lwip-1.4.1/src/core/udp.c ****   pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 1377              		.loc 1 980 0
 1378 0006 0120     		movs	r0, #1
 1379 0008 FFF7FEFF 		bl	memp_malloc
 1380 000c 7860     		str	r0, [r7, #4]
 981:../lwip-1.4.1/src/core/udp.c ****   /* could allocate UDP PCB? */
 982:../lwip-1.4.1/src/core/udp.c ****   if (pcb != NULL) {
 1381              		.loc 1 982 0
 1382 000e 7B68     		ldr	r3, [r7, #4]
 1383 0010 002B     		cmp	r3, #0
 1384 0012 07D0     		beq	.L93
 983:../lwip-1.4.1/src/core/udp.c ****     /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
 984:../lwip-1.4.1/src/core/udp.c ****      * which means checksum is generated over the whole datagram per default
 985:../lwip-1.4.1/src/core/udp.c ****      * (recommended as default by RFC 3828). */
 986:../lwip-1.4.1/src/core/udp.c ****     /* initialize PCB to all zeroes */
 987:../lwip-1.4.1/src/core/udp.c ****     memset(pcb, 0, sizeof(struct udp_pcb));
 1385              		.loc 1 987 0
 1386 0014 7868     		ldr	r0, [r7, #4]
 1387 0016 0021     		movs	r1, #0
 1388 0018 2022     		movs	r2, #32
 1389 001a FFF7FEFF 		bl	memset
 988:../lwip-1.4.1/src/core/udp.c ****     pcb->ttl = UDP_TTL;
 1390              		.loc 1 988 0
 1391 001e 7B68     		ldr	r3, [r7, #4]
 1392 0020 FF22     		movs	r2, #255
 1393 0022 9A72     		strb	r2, [r3, #10]
 1394              	.L93:
 989:../lwip-1.4.1/src/core/udp.c ****   }
 990:../lwip-1.4.1/src/core/udp.c ****   return pcb;
 1395              		.loc 1 990 0
 1396 0024 7B68     		ldr	r3, [r7, #4]
 991:../lwip-1.4.1/src/core/udp.c **** }
 1397              		.loc 1 991 0
 1398 0026 1846     		mov	r0, r3
 1399 0028 0837     		adds	r7, r7, #8
 1400              		.cfi_def_cfa_offset 8
 1401 002a BD46     		mov	sp, r7
 1402              		.cfi_def_cfa_register 13
 1403              		@ sp needed
 1404 002c 80BD     		pop	{r7, pc}
 1405              		.cfi_endproc
 1406              	.LFE11:
 1408 002e 00BF     		.text
 1409              	.Letext0:
 1410              		.file 2 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\port/arch/cc.h"
 1411              		.file 3 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/err.h"
 1412              		.file 4 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/pbuf.h
 1413              		.file 5 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip/
 1414              		.file 6 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/netif.
 1415              		.file 7 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip/
 1416              		.file 8 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/udp.h"
 1417              		.file 9 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/memp.h
 1418              		.file 10 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/mem.h
 1419              		.file 11 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/stats
 1420              		.file 12 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip
DEFINED SYMBOLS
                            *ABS*:00000000 udp.c
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:19     .data:00000000 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:22     .data:00000000 udp_port
                            *COM*:00000004 udp_pcbs
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:26     .text.udp_init:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:31     .text.udp_init:00000000 udp_init
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:56     .text.udp_new_port:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:60     .text.udp_new_port:00000000 udp_new_port
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:147    .text.udp_new_port:0000006c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:153    .text.udp_input:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:158    .text.udp_input:00000000 udp_input
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:557    .text.udp_input:00000278 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:565    .text.udp_send:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:570    .text.udp_send:00000000 udp_send
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:612    .text.udp_sendto:00000000 udp_sendto
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:607    .text.udp_sendto:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:682    .text.udp_sendto_if:00000000 udp_sendto_if
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:672    .text.udp_sendto:0000004c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:677    .text.udp_sendto_if:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:899    .text.udp_bind:00000000 udp_bind
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:889    .text.udp_sendto_if:00000140 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:894    .text.udp_bind:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1047   .text.udp_bind:000000bc $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1052   .text.udp_connect:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1057   .text.udp_connect:00000000 udp_connect
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1174   .text.udp_connect:00000098 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1179   .text.udp_disconnect:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1184   .text.udp_disconnect:00000000 udp_disconnect
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1228   .text.udp_recv:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1233   .text.udp_recv:00000000 udp_recv
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1272   .text.udp_remove:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1277   .text.udp_remove:00000000 udp_remove
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1353   .text.udp_remove:0000005c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1358   .text.udp_new:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccMSeWqd.s:1363   .text.udp_new:00000000 udp_new
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.2d80f1b5ce3c69d13e258577ddf29668
                           .group:00000000 wm4.lwipopts.h.25.76e03deb318fbe54d896a83c1b611e55
                           .group:00000000 wm4.arch.h.33.6fa4aa86d33d1490ae882caef7316405
                           .group:00000000 wm4.cpu.h.33.0ec64ad8cd52614da6479c7936fa3efa
                           .group:00000000 wm4.cc.h.49.217a0c46a6dd8448cb36cccbf00f897f
                           .group:00000000 wm4.arch.h.52.2e97dbd839a1aa815d8c47878a7f8e2b
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.24.b2be5f53932a9c9d07787288b29b6d75
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.82.82b71f3f44c70e3a459d0f66642b05eb
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.68.ff6d7571d3ad75c55f15e26dbaa81e35
                           .group:00000000 wm4.debug.h.45.223028a5c052c9f879ffd43dd519f3f1
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.opt.h.76.0e16bb9c23144e1f631b5b5afa9a69f6
                           .group:00000000 wm4.err.h.33.909ff4b35439192d64931f0a04fc8fdb
                           .group:00000000 wm4.pbuf.h.45.444f43edbf93d1b2ead9ba1554355b0e
                           .group:00000000 wm4.netif.h.33.e68fa2fc48174dad7292f51867e80534
                           .group:00000000 wm4.def.h.33.d4208c3cd3e0fc64e20a8b9f95a681f3
                           .group:00000000 wm4.ip_addr.h.92.064dfb1f61acc5ba1dffbdba3104a668
                           .group:00000000 wm4.netif.h.61.25a4ec33204158dc7a027270d7b19690
                           .group:00000000 wm4.ip.h.33.cd1106783490741294b06617fff8c08f
                           .group:00000000 wm4.udp.h.48.857e3ff95638be9b5ea28a33da1bdddb
                           .group:00000000 wm4.memp.h.34.a409f52ec6d44b5681de26eb10b0c08b
                           .group:00000000 wm4.memp_std.h.15.637bb4287b70e9d70dbd8dd3c6f62f3b
                           .group:00000000 wm4.inet_chksum.h.33.8f33e706cb8ab6b406ce83637c67c459
                           .group:00000000 wm4.icmp.h.33.9c8da59f6edf08fae1a2f37336a6e965
                           .group:00000000 wm4.mem.h.33.ae21028c0b1f3dc3305003fc71edaf5a
                           .group:00000000 wm4.stats.h.51.0db2d210618aedce9edea4fb7e0fbaf1
                           .group:00000000 wm4.snmp.h.34.65cd272594ba53b669353bfbd8cfaef5
                           .group:00000000 wm4.perf.h.33.85c55671e1b7570634f49777a207ad9f

UNDEFINED SYMBOLS
pbuf_header
pbuf_free
ip4_addr_isbroadcast
lwip_ntohs
icmp_dest_unreach
lwip_stats
current_iphdr_dest
current_iphdr_src
ip_route
pbuf_alloc
pbuf_chain
lwip_htons
ip_output_if
memp_free
memp_malloc
memset
