   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tcp.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	tcp_state_str
  19              		.section	.rodata
  20              		.align	2
  21              	.LC0:
  22 0000 434C4F53 		.ascii	"CLOSED\000"
  22      454400
  23 0007 00       		.align	2
  24              	.LC1:
  25 0008 4C495354 		.ascii	"LISTEN\000"
  25      454E00
  26 000f 00       		.align	2
  27              	.LC2:
  28 0010 53594E5F 		.ascii	"SYN_SENT\000"
  28      53454E54 
  28      00
  29 0019 000000   		.align	2
  30              	.LC3:
  31 001c 53594E5F 		.ascii	"SYN_RCVD\000"
  31      52435644 
  31      00
  32 0025 000000   		.align	2
  33              	.LC4:
  34 0028 45535441 		.ascii	"ESTABLISHED\000"
  34      424C4953 
  34      48454400 
  35              		.align	2
  36              	.LC5:
  37 0034 46494E5F 		.ascii	"FIN_WAIT_1\000"
  37      57414954 
  37      5F3100
  38 003f 00       		.align	2
  39              	.LC6:
  40 0040 46494E5F 		.ascii	"FIN_WAIT_2\000"
  40      57414954 
  40      5F3200
  41 004b 00       		.align	2
  42              	.LC7:
  43 004c 434C4F53 		.ascii	"CLOSE_WAIT\000"
  43      455F5741 
  43      495400
  44 0057 00       		.align	2
  45              	.LC8:
  46 0058 434C4F53 		.ascii	"CLOSING\000"
  46      494E4700 
  47              		.align	2
  48              	.LC9:
  49 0060 4C415354 		.ascii	"LAST_ACK\000"
  49      5F41434B 
  49      00
  50 0069 000000   		.align	2
  51              	.LC10:
  52 006c 54494D45 		.ascii	"TIME_WAIT\000"
  52      5F574149 
  52      5400
  53 0076 0000     		.align	2
  56              	tcp_state_str:
  57 0078 00000000 		.word	.LC0
  58 007c 08000000 		.word	.LC1
  59 0080 10000000 		.word	.LC2
  60 0084 1C000000 		.word	.LC3
  61 0088 28000000 		.word	.LC4
  62 008c 34000000 		.word	.LC5
  63 0090 40000000 		.word	.LC6
  64 0094 4C000000 		.word	.LC7
  65 0098 58000000 		.word	.LC8
  66 009c 60000000 		.word	.LC9
  67 00a0 6C000000 		.word	.LC10
  68              		.data
  69              		.align	1
  72              	tcp_port:
  73 0000 00C0     		.short	-16384
  74              		.comm	tcp_ticks,4,4
  75              		.global	tcp_backoff
  76              		.section	.rodata
  77              		.align	2
  80              	tcp_backoff:
  81 00a4 01       		.byte	1
  82 00a5 02       		.byte	2
  83 00a6 03       		.byte	3
  84 00a7 04       		.byte	4
  85 00a8 05       		.byte	5
  86 00a9 06       		.byte	6
  87 00aa 07       		.byte	7
  88 00ab 07       		.byte	7
  89 00ac 07       		.byte	7
  90 00ad 07       		.byte	7
  91 00ae 07       		.byte	7
  92 00af 07       		.byte	7
  93 00b0 07       		.byte	7
  94              		.global	tcp_persist_backoff
  95 00b1 000000   		.align	2
  98              	tcp_persist_backoff:
  99 00b4 03       		.byte	3
 100 00b5 06       		.byte	6
 101 00b6 0C       		.byte	12
 102 00b7 18       		.byte	24
 103 00b8 30       		.byte	48
 104 00b9 60       		.byte	96
 105 00ba 78       		.byte	120
 106              		.comm	tcp_bound_pcbs,4,4
 107              		.comm	tcp_listen_pcbs,4,4
 108              		.comm	tcp_active_pcbs,4,4
 109              		.comm	tcp_tw_pcbs,4,4
 110              		.global	tcp_pcb_lists
 111 00bb 00       		.align	2
 114              	tcp_pcb_lists:
 115 00bc 00000000 		.word	tcp_listen_pcbs
 116 00c0 00000000 		.word	tcp_bound_pcbs
 117 00c4 00000000 		.word	tcp_active_pcbs
 118 00c8 00000000 		.word	tcp_tw_pcbs
 119              		.comm	tcp_tmp_pcb,4,4
 120              		.comm	tcp_active_pcbs_changed,1,1
 121              		.bss
 122              	tcp_timer:
 123 0000 00       		.space	1
 124              	tcp_timer_ctr:
 125 0001 00       		.space	1
 126              		.section	.text.tcp_init,"ax",%progbits
 127              		.align	2
 128              		.global	tcp_init
 129              		.thumb
 130              		.thumb_func
 132              	tcp_init:
 133              	.LFB0:
 134              		.file 1 "../lwip-1.4.1/src/core/tcp.c"
   1:../lwip-1.4.1/src/core/tcp.c **** /**
   2:../lwip-1.4.1/src/core/tcp.c ****  * @file
   3:../lwip-1.4.1/src/core/tcp.c ****  * Transmission Control Protocol for IP
   4:../lwip-1.4.1/src/core/tcp.c ****  *
   5:../lwip-1.4.1/src/core/tcp.c ****  * This file contains common functions for the TCP implementation, such as functinos
   6:../lwip-1.4.1/src/core/tcp.c ****  * for manipulating the data structures and the TCP timer functions. TCP functions
   7:../lwip-1.4.1/src/core/tcp.c ****  * related to input and output is found in tcp_in.c and tcp_out.c respectively.
   8:../lwip-1.4.1/src/core/tcp.c ****  *
   9:../lwip-1.4.1/src/core/tcp.c ****  */
  10:../lwip-1.4.1/src/core/tcp.c **** 
  11:../lwip-1.4.1/src/core/tcp.c **** /*
  12:../lwip-1.4.1/src/core/tcp.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  13:../lwip-1.4.1/src/core/tcp.c ****  * All rights reserved. 
  14:../lwip-1.4.1/src/core/tcp.c ****  * 
  15:../lwip-1.4.1/src/core/tcp.c ****  * Redistribution and use in source and binary forms, with or without modification, 
  16:../lwip-1.4.1/src/core/tcp.c ****  * are permitted provided that the following conditions are met:
  17:../lwip-1.4.1/src/core/tcp.c ****  *
  18:../lwip-1.4.1/src/core/tcp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../lwip-1.4.1/src/core/tcp.c ****  *    this list of conditions and the following disclaimer.
  20:../lwip-1.4.1/src/core/tcp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  21:../lwip-1.4.1/src/core/tcp.c ****  *    this list of conditions and the following disclaimer in the documentation
  22:../lwip-1.4.1/src/core/tcp.c ****  *    and/or other materials provided with the distribution.
  23:../lwip-1.4.1/src/core/tcp.c ****  * 3. The name of the author may not be used to endorse or promote products
  24:../lwip-1.4.1/src/core/tcp.c ****  *    derived from this software without specific prior written permission. 
  25:../lwip-1.4.1/src/core/tcp.c ****  *
  26:../lwip-1.4.1/src/core/tcp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
  27:../lwip-1.4.1/src/core/tcp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
  28:../lwip-1.4.1/src/core/tcp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
  29:../lwip-1.4.1/src/core/tcp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
  30:../lwip-1.4.1/src/core/tcp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
  31:../lwip-1.4.1/src/core/tcp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  32:../lwip-1.4.1/src/core/tcp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  33:../lwip-1.4.1/src/core/tcp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
  34:../lwip-1.4.1/src/core/tcp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
  35:../lwip-1.4.1/src/core/tcp.c ****  * OF SUCH DAMAGE.
  36:../lwip-1.4.1/src/core/tcp.c ****  *
  37:../lwip-1.4.1/src/core/tcp.c ****  * This file is part of the lwIP TCP/IP stack.
  38:../lwip-1.4.1/src/core/tcp.c ****  * 
  39:../lwip-1.4.1/src/core/tcp.c ****  * Author: Adam Dunkels <adam@sics.se>
  40:../lwip-1.4.1/src/core/tcp.c ****  *
  41:../lwip-1.4.1/src/core/tcp.c ****  */
  42:../lwip-1.4.1/src/core/tcp.c **** 
  43:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/opt.h"
  44:../lwip-1.4.1/src/core/tcp.c **** 
  45:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
  46:../lwip-1.4.1/src/core/tcp.c **** 
  47:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/def.h"
  48:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/mem.h"
  49:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/memp.h"
  50:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/snmp.h"
  51:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/tcp.h"
  52:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/tcp_impl.h"
  53:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/debug.h"
  54:../lwip-1.4.1/src/core/tcp.c **** #include "lwip/stats.h"
  55:../lwip-1.4.1/src/core/tcp.c **** #include <string.h>
  56:../lwip-1.4.1/src/core/tcp.c **** 
  57:../lwip-1.4.1/src/core/tcp.c **** #ifndef TCP_LOCAL_PORT_RANGE_START
  58:../lwip-1.4.1/src/core/tcp.c **** /* From http://www.iana.org/assignments/port-numbers:
  59:../lwip-1.4.1/src/core/tcp.c ****    "The Dynamic and/or Private Ports are those from 49152 through 65535" */
  60:../lwip-1.4.1/src/core/tcp.c **** #define TCP_LOCAL_PORT_RANGE_START        0xc000
  61:../lwip-1.4.1/src/core/tcp.c **** #define TCP_LOCAL_PORT_RANGE_END          0xffff
  62:../lwip-1.4.1/src/core/tcp.c **** #define TCP_ENSURE_LOCAL_PORT_RANGE(port) (((port) & ~TCP_LOCAL_PORT_RANGE_START) + TCP_LOCAL_PORT_
  63:../lwip-1.4.1/src/core/tcp.c **** #endif
  64:../lwip-1.4.1/src/core/tcp.c **** 
  65:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_TCP_KEEPALIVE
  66:../lwip-1.4.1/src/core/tcp.c **** #define TCP_KEEP_DUR(pcb)   ((pcb)->keep_cnt * (pcb)->keep_intvl)
  67:../lwip-1.4.1/src/core/tcp.c **** #define TCP_KEEP_INTVL(pcb) ((pcb)->keep_intvl)
  68:../lwip-1.4.1/src/core/tcp.c **** #else /* LWIP_TCP_KEEPALIVE */
  69:../lwip-1.4.1/src/core/tcp.c **** #define TCP_KEEP_DUR(pcb)   TCP_MAXIDLE
  70:../lwip-1.4.1/src/core/tcp.c **** #define TCP_KEEP_INTVL(pcb) TCP_KEEPINTVL_DEFAULT
  71:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_TCP_KEEPALIVE */
  72:../lwip-1.4.1/src/core/tcp.c **** 
  73:../lwip-1.4.1/src/core/tcp.c **** const char * const tcp_state_str[] = {
  74:../lwip-1.4.1/src/core/tcp.c ****   "CLOSED",      
  75:../lwip-1.4.1/src/core/tcp.c ****   "LISTEN",      
  76:../lwip-1.4.1/src/core/tcp.c ****   "SYN_SENT",    
  77:../lwip-1.4.1/src/core/tcp.c ****   "SYN_RCVD",    
  78:../lwip-1.4.1/src/core/tcp.c ****   "ESTABLISHED", 
  79:../lwip-1.4.1/src/core/tcp.c ****   "FIN_WAIT_1",  
  80:../lwip-1.4.1/src/core/tcp.c ****   "FIN_WAIT_2",  
  81:../lwip-1.4.1/src/core/tcp.c ****   "CLOSE_WAIT",  
  82:../lwip-1.4.1/src/core/tcp.c ****   "CLOSING",     
  83:../lwip-1.4.1/src/core/tcp.c ****   "LAST_ACK",    
  84:../lwip-1.4.1/src/core/tcp.c ****   "TIME_WAIT"   
  85:../lwip-1.4.1/src/core/tcp.c **** };
  86:../lwip-1.4.1/src/core/tcp.c **** 
  87:../lwip-1.4.1/src/core/tcp.c **** /* last local TCP port */
  88:../lwip-1.4.1/src/core/tcp.c **** static u16_t tcp_port = TCP_LOCAL_PORT_RANGE_START;
  89:../lwip-1.4.1/src/core/tcp.c **** 
  90:../lwip-1.4.1/src/core/tcp.c **** /* Incremented every coarse grained timer shot (typically every 500 ms). */
  91:../lwip-1.4.1/src/core/tcp.c **** u32_t tcp_ticks;
  92:../lwip-1.4.1/src/core/tcp.c **** const u8_t tcp_backoff[13] =
  93:../lwip-1.4.1/src/core/tcp.c ****     { 1, 2, 3, 4, 5, 6, 7, 7, 7, 7, 7, 7, 7};
  94:../lwip-1.4.1/src/core/tcp.c ****  /* Times per slowtmr hits */
  95:../lwip-1.4.1/src/core/tcp.c **** const u8_t tcp_persist_backoff[7] = { 3, 6, 12, 24, 48, 96, 120 };
  96:../lwip-1.4.1/src/core/tcp.c **** 
  97:../lwip-1.4.1/src/core/tcp.c **** /* The TCP PCB lists. */
  98:../lwip-1.4.1/src/core/tcp.c **** 
  99:../lwip-1.4.1/src/core/tcp.c **** /** List of all TCP PCBs bound but not yet (connected || listening) */
 100:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb *tcp_bound_pcbs;
 101:../lwip-1.4.1/src/core/tcp.c **** /** List of all TCP PCBs in LISTEN state */
 102:../lwip-1.4.1/src/core/tcp.c **** union tcp_listen_pcbs_t tcp_listen_pcbs;
 103:../lwip-1.4.1/src/core/tcp.c **** /** List of all TCP PCBs that are in a state in which
 104:../lwip-1.4.1/src/core/tcp.c ****  * they accept or send data. */
 105:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb *tcp_active_pcbs;
 106:../lwip-1.4.1/src/core/tcp.c **** /** List of all TCP PCBs in TIME-WAIT state */
 107:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb *tcp_tw_pcbs;
 108:../lwip-1.4.1/src/core/tcp.c **** 
 109:../lwip-1.4.1/src/core/tcp.c **** #define NUM_TCP_PCB_LISTS               4
 110:../lwip-1.4.1/src/core/tcp.c **** #define NUM_TCP_PCB_LISTS_NO_TIME_WAIT  3
 111:../lwip-1.4.1/src/core/tcp.c **** /** An array with all (non-temporary) PCB lists, mainly used for smaller code size */
 112:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb ** const tcp_pcb_lists[] = {&tcp_listen_pcbs.pcbs, &tcp_bound_pcbs,
 113:../lwip-1.4.1/src/core/tcp.c ****   &tcp_active_pcbs, &tcp_tw_pcbs};
 114:../lwip-1.4.1/src/core/tcp.c **** 
 115:../lwip-1.4.1/src/core/tcp.c **** /** Only used for temporary storage. */
 116:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb *tcp_tmp_pcb;
 117:../lwip-1.4.1/src/core/tcp.c **** 
 118:../lwip-1.4.1/src/core/tcp.c **** u8_t tcp_active_pcbs_changed;
 119:../lwip-1.4.1/src/core/tcp.c **** 
 120:../lwip-1.4.1/src/core/tcp.c **** /** Timer counter to handle calling slow-timer from tcp_tmr() */ 
 121:../lwip-1.4.1/src/core/tcp.c **** static u8_t tcp_timer;
 122:../lwip-1.4.1/src/core/tcp.c **** static u8_t tcp_timer_ctr;
 123:../lwip-1.4.1/src/core/tcp.c **** static u16_t tcp_new_port(void);
 124:../lwip-1.4.1/src/core/tcp.c **** 
 125:../lwip-1.4.1/src/core/tcp.c **** /**
 126:../lwip-1.4.1/src/core/tcp.c ****  * Initialize this module.
 127:../lwip-1.4.1/src/core/tcp.c ****  */
 128:../lwip-1.4.1/src/core/tcp.c **** void
 129:../lwip-1.4.1/src/core/tcp.c **** tcp_init(void)
 130:../lwip-1.4.1/src/core/tcp.c **** {
 135              		.loc 1 130 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 1, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140 0000 80B4     		push	{r7}
 141              		.cfi_def_cfa_offset 4
 142              		.cfi_offset 7, -4
 143 0002 00AF     		add	r7, sp, #0
 144              		.cfi_def_cfa_register 7
 131:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
 132:../lwip-1.4.1/src/core/tcp.c ****   tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 133:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
 134:../lwip-1.4.1/src/core/tcp.c **** }
 145              		.loc 1 134 0
 146 0004 BD46     		mov	sp, r7
 147              		.cfi_def_cfa_register 13
 148              		@ sp needed
 149 0006 5DF8047B 		ldr	r7, [sp], #4
 150              		.cfi_restore 7
 151              		.cfi_def_cfa_offset 0
 152 000a 7047     		bx	lr
 153              		.cfi_endproc
 154              	.LFE0:
 156              		.section	.text.tcp_tmr,"ax",%progbits
 157              		.align	2
 158              		.global	tcp_tmr
 159              		.thumb
 160              		.thumb_func
 162              	tcp_tmr:
 163              	.LFB1:
 135:../lwip-1.4.1/src/core/tcp.c **** 
 136:../lwip-1.4.1/src/core/tcp.c **** /**
 137:../lwip-1.4.1/src/core/tcp.c ****  * Called periodically to dispatch TCP timers.
 138:../lwip-1.4.1/src/core/tcp.c ****  */
 139:../lwip-1.4.1/src/core/tcp.c **** void
 140:../lwip-1.4.1/src/core/tcp.c **** tcp_tmr(void)
 141:../lwip-1.4.1/src/core/tcp.c **** {
 164              		.loc 1 141 0
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 0
 167              		@ frame_needed = 1, uses_anonymous_args = 0
 168 0000 80B5     		push	{r7, lr}
 169              		.cfi_def_cfa_offset 8
 170              		.cfi_offset 7, -8
 171              		.cfi_offset 14, -4
 172 0002 00AF     		add	r7, sp, #0
 173              		.cfi_def_cfa_register 7
 142:../lwip-1.4.1/src/core/tcp.c ****   /* Call tcp_fasttmr() every 250 ms */
 143:../lwip-1.4.1/src/core/tcp.c ****   tcp_fasttmr();
 174              		.loc 1 143 0
 175 0004 FFF7FEFF 		bl	tcp_fasttmr
 144:../lwip-1.4.1/src/core/tcp.c **** 
 145:../lwip-1.4.1/src/core/tcp.c ****   if (++tcp_timer & 1) {
 176              		.loc 1 145 0
 177 0008 074B     		ldr	r3, .L4
 178 000a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 179 000c 0133     		adds	r3, r3, #1
 180 000e DAB2     		uxtb	r2, r3
 181 0010 054B     		ldr	r3, .L4
 182 0012 1A70     		strb	r2, [r3]
 183 0014 044B     		ldr	r3, .L4
 184 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 185 0018 03F00103 		and	r3, r3, #1
 186 001c 002B     		cmp	r3, #0
 187 001e 01D0     		beq	.L2
 146:../lwip-1.4.1/src/core/tcp.c ****     /* Call tcp_tmr() every 500 ms, i.e., every other timer
 147:../lwip-1.4.1/src/core/tcp.c ****        tcp_tmr() is called. */
 148:../lwip-1.4.1/src/core/tcp.c ****     tcp_slowtmr();
 188              		.loc 1 148 0
 189 0020 FFF7FEFF 		bl	tcp_slowtmr
 190              	.L2:
 149:../lwip-1.4.1/src/core/tcp.c ****   }
 150:../lwip-1.4.1/src/core/tcp.c **** }
 191              		.loc 1 150 0
 192 0024 80BD     		pop	{r7, pc}
 193              	.L5:
 194 0026 00BF     		.align	2
 195              	.L4:
 196 0028 00000000 		.word	tcp_timer
 197              		.cfi_endproc
 198              	.LFE1:
 200              		.section	.text.tcp_close_shutdown,"ax",%progbits
 201              		.align	2
 202              		.thumb
 203              		.thumb_func
 205              	tcp_close_shutdown:
 206              	.LFB2:
 151:../lwip-1.4.1/src/core/tcp.c **** 
 152:../lwip-1.4.1/src/core/tcp.c **** /**
 153:../lwip-1.4.1/src/core/tcp.c ****  * Closes the TX side of a connection held by the PCB.
 154:../lwip-1.4.1/src/core/tcp.c ****  * For tcp_close(), a RST is sent if the application didn't receive all data
 155:../lwip-1.4.1/src/core/tcp.c ****  * (tcp_recved() not called for all data passed to recv callback).
 156:../lwip-1.4.1/src/core/tcp.c ****  *
 157:../lwip-1.4.1/src/core/tcp.c ****  * Listening pcbs are freed and may not be referenced any more.
 158:../lwip-1.4.1/src/core/tcp.c ****  * Connection pcbs are freed if not yet connected and may not be referenced
 159:../lwip-1.4.1/src/core/tcp.c ****  * any more. If a connection is established (at least SYN received or in
 160:../lwip-1.4.1/src/core/tcp.c ****  * a closing state), the connection is closed, and put in a closing state.
 161:../lwip-1.4.1/src/core/tcp.c ****  * The pcb is then automatically freed in tcp_slowtmr(). It is therefore
 162:../lwip-1.4.1/src/core/tcp.c ****  * unsafe to reference it.
 163:../lwip-1.4.1/src/core/tcp.c ****  *
 164:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp_pcb to close
 165:../lwip-1.4.1/src/core/tcp.c ****  * @return ERR_OK if connection has been closed
 166:../lwip-1.4.1/src/core/tcp.c ****  *         another err_t if closing failed and pcb is not freed
 167:../lwip-1.4.1/src/core/tcp.c ****  */
 168:../lwip-1.4.1/src/core/tcp.c **** static err_t
 169:../lwip-1.4.1/src/core/tcp.c **** tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
 170:../lwip-1.4.1/src/core/tcp.c **** {
 207              		.loc 1 170 0
 208              		.cfi_startproc
 209              		@ args = 0, pretend = 0, frame = 16
 210              		@ frame_needed = 1, uses_anonymous_args = 0
 211 0000 B0B5     		push	{r4, r5, r7, lr}
 212              		.cfi_def_cfa_offset 16
 213              		.cfi_offset 4, -16
 214              		.cfi_offset 5, -12
 215              		.cfi_offset 7, -8
 216              		.cfi_offset 14, -4
 217 0002 86B0     		sub	sp, sp, #24
 218              		.cfi_def_cfa_offset 40
 219 0004 02AF     		add	r7, sp, #8
 220              		.cfi_def_cfa 7, 32
 221 0006 7860     		str	r0, [r7, #4]
 222 0008 0B46     		mov	r3, r1
 223 000a FB70     		strb	r3, [r7, #3]
 171:../lwip-1.4.1/src/core/tcp.c ****   err_t err;
 172:../lwip-1.4.1/src/core/tcp.c **** 
 173:../lwip-1.4.1/src/core/tcp.c ****   if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 224              		.loc 1 173 0
 225 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 226 000e 002B     		cmp	r3, #0
 227 0010 67D0     		beq	.L7
 228              		.loc 1 173 0 is_stmt 0 discriminator 1
 229 0012 7B68     		ldr	r3, [r7, #4]
 230 0014 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 231 0016 042B     		cmp	r3, #4
 232 0018 03D0     		beq	.L8
 233              		.loc 1 173 0 discriminator 2
 234 001a 7B68     		ldr	r3, [r7, #4]
 235 001c 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 236 001e 072B     		cmp	r3, #7
 237 0020 5FD1     		bne	.L7
 238              	.L8:
 174:../lwip-1.4.1/src/core/tcp.c ****     if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 239              		.loc 1 174 0 is_stmt 1
 240 0022 7B68     		ldr	r3, [r7, #4]
 241 0024 9B6F     		ldr	r3, [r3, #120]
 242 0026 002B     		cmp	r3, #0
 243 0028 05D1     		bne	.L9
 244              		.loc 1 174 0 is_stmt 0 discriminator 1
 245 002a 7B68     		ldr	r3, [r7, #4]
 246 002c 9B8D     		ldrh	r3, [r3, #44]
 247 002e 40F66832 		movw	r2, #2920
 248 0032 9342     		cmp	r3, r2
 249 0034 55D0     		beq	.L7
 250              	.L9:
 175:../lwip-1.4.1/src/core/tcp.c ****       /* Not all data received by application, send RST to tell the remote
 176:../lwip-1.4.1/src/core/tcp.c ****          side about this. */
 177:../lwip-1.4.1/src/core/tcp.c ****       LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 178:../lwip-1.4.1/src/core/tcp.c **** 
 179:../lwip-1.4.1/src/core/tcp.c ****       /* don't call tcp_abort here: we must not deallocate the pcb since
 180:../lwip-1.4.1/src/core/tcp.c ****          that might not be expected when calling tcp_close */
 181:../lwip-1.4.1/src/core/tcp.c ****       tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 251              		.loc 1 181 0 is_stmt 1
 252 0036 7B68     		ldr	r3, [r7, #4]
 253 0038 186D     		ldr	r0, [r3, #80]
 254 003a 7B68     		ldr	r3, [r7, #4]
 255 003c 996A     		ldr	r1, [r3, #40]
 256 003e 7D68     		ldr	r5, [r7, #4]
 257 0040 7B68     		ldr	r3, [r7, #4]
 258 0042 1C1D     		adds	r4, r3, #4
 259 0044 7B68     		ldr	r3, [r7, #4]
 260 0046 5A8B     		ldrh	r2, [r3, #26]
 261 0048 7B68     		ldr	r3, [r7, #4]
 262 004a 9B8B     		ldrh	r3, [r3, #28]
 263 004c 0092     		str	r2, [sp]
 264 004e 0193     		str	r3, [sp, #4]
 265 0050 2A46     		mov	r2, r5
 266 0052 2346     		mov	r3, r4
 267 0054 FFF7FEFF 		bl	tcp_rst
 182:../lwip-1.4.1/src/core/tcp.c ****         pcb->local_port, pcb->remote_port);
 183:../lwip-1.4.1/src/core/tcp.c **** 
 184:../lwip-1.4.1/src/core/tcp.c ****       tcp_pcb_purge(pcb);
 268              		.loc 1 184 0
 269 0058 7868     		ldr	r0, [r7, #4]
 270 005a FFF7FEFF 		bl	tcp_pcb_purge
 185:../lwip-1.4.1/src/core/tcp.c ****       TCP_RMV_ACTIVE(pcb);
 271              		.loc 1 185 0
 272 005e 764B     		ldr	r3, .L37
 273 0060 1A68     		ldr	r2, [r3]
 274 0062 7B68     		ldr	r3, [r7, #4]
 275 0064 9A42     		cmp	r2, r3
 276 0066 05D1     		bne	.L10
 277              		.loc 1 185 0 is_stmt 0 discriminator 1
 278 0068 734B     		ldr	r3, .L37
 279 006a 1B68     		ldr	r3, [r3]
 280 006c DB68     		ldr	r3, [r3, #12]
 281 006e 724A     		ldr	r2, .L37
 282 0070 1360     		str	r3, [r2]
 283 0072 19E0     		b	.L11
 284              	.L10:
 285              		.loc 1 185 0 discriminator 2
 286 0074 704B     		ldr	r3, .L37
 287 0076 1B68     		ldr	r3, [r3]
 288 0078 704A     		ldr	r2, .L37+4
 289 007a 1360     		str	r3, [r2]
 290 007c 10E0     		b	.L12
 291              	.L14:
 292              		.loc 1 185 0 discriminator 9
 293 007e 6F4B     		ldr	r3, .L37+4
 294 0080 1B68     		ldr	r3, [r3]
 295 0082 DA68     		ldr	r2, [r3, #12]
 296 0084 7B68     		ldr	r3, [r7, #4]
 297 0086 9A42     		cmp	r2, r3
 298 0088 05D1     		bne	.L13
 299              		.loc 1 185 0 discriminator 5
 300 008a 6C4B     		ldr	r3, .L37+4
 301 008c 1B68     		ldr	r3, [r3]
 302 008e 7A68     		ldr	r2, [r7, #4]
 303 0090 D268     		ldr	r2, [r2, #12]
 304 0092 DA60     		str	r2, [r3, #12]
 305 0094 08E0     		b	.L11
 306              	.L13:
 307              		.loc 1 185 0 discriminator 6
 308 0096 694B     		ldr	r3, .L37+4
 309 0098 1B68     		ldr	r3, [r3]
 310 009a DB68     		ldr	r3, [r3, #12]
 311 009c 674A     		ldr	r2, .L37+4
 312 009e 1360     		str	r3, [r2]
 313              	.L12:
 314              		.loc 1 185 0 discriminator 8
 315 00a0 664B     		ldr	r3, .L37+4
 316 00a2 1B68     		ldr	r3, [r3]
 317 00a4 002B     		cmp	r3, #0
 318 00a6 EAD1     		bne	.L14
 319              	.L11:
 320              		.loc 1 185 0 discriminator 10
 321 00a8 7B68     		ldr	r3, [r7, #4]
 322 00aa 0022     		movs	r2, #0
 323 00ac DA60     		str	r2, [r3, #12]
 324 00ae 644B     		ldr	r3, .L37+8
 325 00b0 0122     		movs	r2, #1
 326 00b2 1A70     		strb	r2, [r3]
 186:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->state == ESTABLISHED) {
 327              		.loc 1 186 0 is_stmt 1 discriminator 10
 328 00b4 7B68     		ldr	r3, [r7, #4]
 329 00b6 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 330 00b8 042B     		cmp	r3, #4
 331 00ba 0CD1     		bne	.L15
 187:../lwip-1.4.1/src/core/tcp.c ****         /* move to TIME_WAIT since we close actively */
 188:../lwip-1.4.1/src/core/tcp.c ****         pcb->state = TIME_WAIT;
 332              		.loc 1 188 0
 333 00bc 7B68     		ldr	r3, [r7, #4]
 334 00be 0A22     		movs	r2, #10
 335 00c0 1A76     		strb	r2, [r3, #24]
 189:../lwip-1.4.1/src/core/tcp.c ****         TCP_REG(&tcp_tw_pcbs, pcb);
 336              		.loc 1 189 0
 337 00c2 604B     		ldr	r3, .L37+12
 338 00c4 1A68     		ldr	r2, [r3]
 339 00c6 7B68     		ldr	r3, [r7, #4]
 340 00c8 DA60     		str	r2, [r3, #12]
 341 00ca 5E4A     		ldr	r2, .L37+12
 342 00cc 7B68     		ldr	r3, [r7, #4]
 343 00ce 1360     		str	r3, [r2]
 344 00d0 FFF7FEFF 		bl	tcp_timer_needed
 345 00d4 03E0     		b	.L16
 346              	.L15:
 190:../lwip-1.4.1/src/core/tcp.c ****       } else {
 191:../lwip-1.4.1/src/core/tcp.c ****         /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
 192:../lwip-1.4.1/src/core/tcp.c ****         memp_free(MEMP_TCP_PCB, pcb);
 347              		.loc 1 192 0
 348 00d6 0220     		movs	r0, #2
 349 00d8 7968     		ldr	r1, [r7, #4]
 350 00da FFF7FEFF 		bl	memp_free
 351              	.L16:
 193:../lwip-1.4.1/src/core/tcp.c ****       }
 194:../lwip-1.4.1/src/core/tcp.c ****       return ERR_OK;
 352              		.loc 1 194 0
 353 00de 0023     		movs	r3, #0
 354 00e0 A4E0     		b	.L17
 355              	.L7:
 195:../lwip-1.4.1/src/core/tcp.c ****     }
 196:../lwip-1.4.1/src/core/tcp.c ****   }
 197:../lwip-1.4.1/src/core/tcp.c **** 
 198:../lwip-1.4.1/src/core/tcp.c ****   switch (pcb->state) {
 356              		.loc 1 198 0
 357 00e2 7B68     		ldr	r3, [r7, #4]
 358 00e4 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 359 00e6 072B     		cmp	r3, #7
 360 00e8 00F29080 		bhi	.L18
 361 00ec 01A2     		adr	r2, .L20
 362 00ee 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 363 00f2 00BF     		.p2align 2
 364              	.L20:
 365 00f4 15010000 		.word	.L19+1
 366 00f8 7F010000 		.word	.L21+1
 367 00fc 99010000 		.word	.L22+1
 368 0100 B9010000 		.word	.L23+1
 369 0104 D5010000 		.word	.L24+1
 370 0108 0D020000 		.word	.L18+1
 371 010c 0D020000 		.word	.L18+1
 372 0110 F1010000 		.word	.L25+1
 373              		.p2align 1
 374              	.L19:
 199:../lwip-1.4.1/src/core/tcp.c ****   case CLOSED:
 200:../lwip-1.4.1/src/core/tcp.c ****     /* Closing a pcb in the CLOSED state might seem erroneous,
 201:../lwip-1.4.1/src/core/tcp.c ****      * however, it is in this state once allocated and as yet unused
 202:../lwip-1.4.1/src/core/tcp.c ****      * and the user needs some way to free it should the need arise.
 203:../lwip-1.4.1/src/core/tcp.c ****      * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
 204:../lwip-1.4.1/src/core/tcp.c ****      * or for a pcb that has been used and then entered the CLOSED state 
 205:../lwip-1.4.1/src/core/tcp.c ****      * is erroneous, but this should never happen as the pcb has in those cases
 206:../lwip-1.4.1/src/core/tcp.c ****      * been freed, and so any remaining handles are bogus. */
 207:../lwip-1.4.1/src/core/tcp.c ****     err = ERR_OK;
 375              		.loc 1 207 0
 376 0114 0023     		movs	r3, #0
 377 0116 FB73     		strb	r3, [r7, #15]
 208:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->local_port != 0) {
 378              		.loc 1 208 0
 379 0118 7B68     		ldr	r3, [r7, #4]
 380 011a 5B8B     		ldrh	r3, [r3, #26]
 381 011c 002B     		cmp	r3, #0
 382 011e 27D0     		beq	.L26
 209:../lwip-1.4.1/src/core/tcp.c ****       TCP_RMV(&tcp_bound_pcbs, pcb);
 383              		.loc 1 209 0
 384 0120 494B     		ldr	r3, .L37+16
 385 0122 1A68     		ldr	r2, [r3]
 386 0124 7B68     		ldr	r3, [r7, #4]
 387 0126 9A42     		cmp	r2, r3
 388 0128 05D1     		bne	.L27
 389              		.loc 1 209 0 is_stmt 0 discriminator 1
 390 012a 474B     		ldr	r3, .L37+16
 391 012c 1B68     		ldr	r3, [r3]
 392 012e DB68     		ldr	r3, [r3, #12]
 393 0130 454A     		ldr	r2, .L37+16
 394 0132 1360     		str	r3, [r2]
 395 0134 19E0     		b	.L28
 396              	.L27:
 397              		.loc 1 209 0 discriminator 2
 398 0136 444B     		ldr	r3, .L37+16
 399 0138 1B68     		ldr	r3, [r3]
 400 013a 404A     		ldr	r2, .L37+4
 401 013c 1360     		str	r3, [r2]
 402 013e 10E0     		b	.L29
 403              	.L31:
 404              		.loc 1 209 0 discriminator 9
 405 0140 3E4B     		ldr	r3, .L37+4
 406 0142 1B68     		ldr	r3, [r3]
 407 0144 DA68     		ldr	r2, [r3, #12]
 408 0146 7B68     		ldr	r3, [r7, #4]
 409 0148 9A42     		cmp	r2, r3
 410 014a 05D1     		bne	.L30
 411              		.loc 1 209 0 discriminator 5
 412 014c 3B4B     		ldr	r3, .L37+4
 413 014e 1B68     		ldr	r3, [r3]
 414 0150 7A68     		ldr	r2, [r7, #4]
 415 0152 D268     		ldr	r2, [r2, #12]
 416 0154 DA60     		str	r2, [r3, #12]
 417 0156 08E0     		b	.L28
 418              	.L30:
 419              		.loc 1 209 0 discriminator 6
 420 0158 384B     		ldr	r3, .L37+4
 421 015a 1B68     		ldr	r3, [r3]
 422 015c DB68     		ldr	r3, [r3, #12]
 423 015e 374A     		ldr	r2, .L37+4
 424 0160 1360     		str	r3, [r2]
 425              	.L29:
 426              		.loc 1 209 0 discriminator 8
 427 0162 364B     		ldr	r3, .L37+4
 428 0164 1B68     		ldr	r3, [r3]
 429 0166 002B     		cmp	r3, #0
 430 0168 EAD1     		bne	.L31
 431              	.L28:
 432              		.loc 1 209 0 discriminator 10
 433 016a 7B68     		ldr	r3, [r7, #4]
 434 016c 0022     		movs	r2, #0
 435 016e DA60     		str	r2, [r3, #12]
 436              	.L26:
 210:../lwip-1.4.1/src/core/tcp.c ****     }
 211:../lwip-1.4.1/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 437              		.loc 1 211 0 is_stmt 1
 438 0170 0220     		movs	r0, #2
 439 0172 7968     		ldr	r1, [r7, #4]
 440 0174 FFF7FEFF 		bl	memp_free
 212:../lwip-1.4.1/src/core/tcp.c ****     pcb = NULL;
 441              		.loc 1 212 0
 442 0178 0023     		movs	r3, #0
 443 017a 7B60     		str	r3, [r7, #4]
 213:../lwip-1.4.1/src/core/tcp.c ****     break;
 444              		.loc 1 213 0
 445 017c 4BE0     		b	.L32
 446              	.L21:
 214:../lwip-1.4.1/src/core/tcp.c ****   case LISTEN:
 215:../lwip-1.4.1/src/core/tcp.c ****     err = ERR_OK;
 447              		.loc 1 215 0
 448 017e 0023     		movs	r3, #0
 449 0180 FB73     		strb	r3, [r7, #15]
 216:../lwip-1.4.1/src/core/tcp.c ****     tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 450              		.loc 1 216 0
 451 0182 3248     		ldr	r0, .L37+20
 452 0184 7968     		ldr	r1, [r7, #4]
 453 0186 FFF7FEFF 		bl	tcp_pcb_remove
 217:../lwip-1.4.1/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 454              		.loc 1 217 0
 455 018a 0320     		movs	r0, #3
 456 018c 7968     		ldr	r1, [r7, #4]
 457 018e FFF7FEFF 		bl	memp_free
 218:../lwip-1.4.1/src/core/tcp.c ****     pcb = NULL;
 458              		.loc 1 218 0
 459 0192 0023     		movs	r3, #0
 460 0194 7B60     		str	r3, [r7, #4]
 219:../lwip-1.4.1/src/core/tcp.c ****     break;
 461              		.loc 1 219 0
 462 0196 3EE0     		b	.L32
 463              	.L22:
 220:../lwip-1.4.1/src/core/tcp.c ****   case SYN_SENT:
 221:../lwip-1.4.1/src/core/tcp.c ****     err = ERR_OK;
 464              		.loc 1 221 0
 465 0198 0023     		movs	r3, #0
 466 019a FB73     		strb	r3, [r7, #15]
 222:../lwip-1.4.1/src/core/tcp.c ****     TCP_PCB_REMOVE_ACTIVE(pcb);
 467              		.loc 1 222 0
 468 019c 2648     		ldr	r0, .L37
 469 019e 7968     		ldr	r1, [r7, #4]
 470 01a0 FFF7FEFF 		bl	tcp_pcb_remove
 471 01a4 264B     		ldr	r3, .L37+8
 472 01a6 0122     		movs	r2, #1
 473 01a8 1A70     		strb	r2, [r3]
 223:../lwip-1.4.1/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 474              		.loc 1 223 0
 475 01aa 0220     		movs	r0, #2
 476 01ac 7968     		ldr	r1, [r7, #4]
 477 01ae FFF7FEFF 		bl	memp_free
 224:../lwip-1.4.1/src/core/tcp.c ****     pcb = NULL;
 478              		.loc 1 224 0
 479 01b2 0023     		movs	r3, #0
 480 01b4 7B60     		str	r3, [r7, #4]
 225:../lwip-1.4.1/src/core/tcp.c ****     snmp_inc_tcpattemptfails();
 226:../lwip-1.4.1/src/core/tcp.c ****     break;
 481              		.loc 1 226 0
 482 01b6 2EE0     		b	.L32
 483              	.L23:
 227:../lwip-1.4.1/src/core/tcp.c ****   case SYN_RCVD:
 228:../lwip-1.4.1/src/core/tcp.c ****     err = tcp_send_fin(pcb);
 484              		.loc 1 228 0
 485 01b8 7868     		ldr	r0, [r7, #4]
 486 01ba FFF7FEFF 		bl	tcp_send_fin
 487 01be 0346     		mov	r3, r0
 488 01c0 FB73     		strb	r3, [r7, #15]
 229:../lwip-1.4.1/src/core/tcp.c ****     if (err == ERR_OK) {
 489              		.loc 1 229 0
 490 01c2 97F90F30 		ldrsb	r3, [r7, #15]
 491 01c6 002B     		cmp	r3, #0
 492 01c8 03D1     		bne	.L33
 230:../lwip-1.4.1/src/core/tcp.c ****       snmp_inc_tcpattemptfails();
 231:../lwip-1.4.1/src/core/tcp.c ****       pcb->state = FIN_WAIT_1;
 493              		.loc 1 231 0
 494 01ca 7B68     		ldr	r3, [r7, #4]
 495 01cc 0522     		movs	r2, #5
 496 01ce 1A76     		strb	r2, [r3, #24]
 232:../lwip-1.4.1/src/core/tcp.c ****     }
 233:../lwip-1.4.1/src/core/tcp.c ****     break;
 497              		.loc 1 233 0
 498 01d0 21E0     		b	.L32
 499              	.L33:
 500 01d2 20E0     		b	.L32
 501              	.L24:
 234:../lwip-1.4.1/src/core/tcp.c ****   case ESTABLISHED:
 235:../lwip-1.4.1/src/core/tcp.c ****     err = tcp_send_fin(pcb);
 502              		.loc 1 235 0
 503 01d4 7868     		ldr	r0, [r7, #4]
 504 01d6 FFF7FEFF 		bl	tcp_send_fin
 505 01da 0346     		mov	r3, r0
 506 01dc FB73     		strb	r3, [r7, #15]
 236:../lwip-1.4.1/src/core/tcp.c ****     if (err == ERR_OK) {
 507              		.loc 1 236 0
 508 01de 97F90F30 		ldrsb	r3, [r7, #15]
 509 01e2 002B     		cmp	r3, #0
 510 01e4 03D1     		bne	.L34
 237:../lwip-1.4.1/src/core/tcp.c ****       snmp_inc_tcpestabresets();
 238:../lwip-1.4.1/src/core/tcp.c ****       pcb->state = FIN_WAIT_1;
 511              		.loc 1 238 0
 512 01e6 7B68     		ldr	r3, [r7, #4]
 513 01e8 0522     		movs	r2, #5
 514 01ea 1A76     		strb	r2, [r3, #24]
 239:../lwip-1.4.1/src/core/tcp.c ****     }
 240:../lwip-1.4.1/src/core/tcp.c ****     break;
 515              		.loc 1 240 0
 516 01ec 13E0     		b	.L32
 517              	.L34:
 518 01ee 12E0     		b	.L32
 519              	.L25:
 241:../lwip-1.4.1/src/core/tcp.c ****   case CLOSE_WAIT:
 242:../lwip-1.4.1/src/core/tcp.c ****     err = tcp_send_fin(pcb);
 520              		.loc 1 242 0
 521 01f0 7868     		ldr	r0, [r7, #4]
 522 01f2 FFF7FEFF 		bl	tcp_send_fin
 523 01f6 0346     		mov	r3, r0
 524 01f8 FB73     		strb	r3, [r7, #15]
 243:../lwip-1.4.1/src/core/tcp.c ****     if (err == ERR_OK) {
 525              		.loc 1 243 0
 526 01fa 97F90F30 		ldrsb	r3, [r7, #15]
 527 01fe 002B     		cmp	r3, #0
 528 0200 03D1     		bne	.L35
 244:../lwip-1.4.1/src/core/tcp.c ****       snmp_inc_tcpestabresets();
 245:../lwip-1.4.1/src/core/tcp.c ****       pcb->state = LAST_ACK;
 529              		.loc 1 245 0
 530 0202 7B68     		ldr	r3, [r7, #4]
 531 0204 0922     		movs	r2, #9
 532 0206 1A76     		strb	r2, [r3, #24]
 246:../lwip-1.4.1/src/core/tcp.c ****     }
 247:../lwip-1.4.1/src/core/tcp.c ****     break;
 533              		.loc 1 247 0
 534 0208 05E0     		b	.L32
 535              	.L35:
 536 020a 04E0     		b	.L32
 537              	.L18:
 248:../lwip-1.4.1/src/core/tcp.c ****   default:
 249:../lwip-1.4.1/src/core/tcp.c ****     /* Has already been closed, do nothing. */
 250:../lwip-1.4.1/src/core/tcp.c ****     err = ERR_OK;
 538              		.loc 1 250 0
 539 020c 0023     		movs	r3, #0
 540 020e FB73     		strb	r3, [r7, #15]
 251:../lwip-1.4.1/src/core/tcp.c ****     pcb = NULL;
 541              		.loc 1 251 0
 542 0210 0023     		movs	r3, #0
 543 0212 7B60     		str	r3, [r7, #4]
 252:../lwip-1.4.1/src/core/tcp.c ****     break;
 544              		.loc 1 252 0
 545 0214 00BF     		nop
 546              	.L32:
 253:../lwip-1.4.1/src/core/tcp.c ****   }
 254:../lwip-1.4.1/src/core/tcp.c **** 
 255:../lwip-1.4.1/src/core/tcp.c ****   if (pcb != NULL && err == ERR_OK) {
 547              		.loc 1 255 0
 548 0216 7B68     		ldr	r3, [r7, #4]
 549 0218 002B     		cmp	r3, #0
 550 021a 06D0     		beq	.L36
 551              		.loc 1 255 0 is_stmt 0 discriminator 1
 552 021c 97F90F30 		ldrsb	r3, [r7, #15]
 553 0220 002B     		cmp	r3, #0
 554 0222 02D1     		bne	.L36
 256:../lwip-1.4.1/src/core/tcp.c ****     /* To ensure all data has been sent when tcp_close returns, we have
 257:../lwip-1.4.1/src/core/tcp.c ****        to make sure tcp_output doesn't fail.
 258:../lwip-1.4.1/src/core/tcp.c ****        Since we don't really have to ensure all data has been sent when tcp_close
 259:../lwip-1.4.1/src/core/tcp.c ****        returns (unsent data is sent from tcp timer functions, also), we don't care
 260:../lwip-1.4.1/src/core/tcp.c ****        for the return value of tcp_output for now. */
 261:../lwip-1.4.1/src/core/tcp.c ****     /* @todo: When implementing SO_LINGER, this must be changed somehow:
 262:../lwip-1.4.1/src/core/tcp.c ****        If SOF_LINGER is set, the data should be sent and acked before close returns.
 263:../lwip-1.4.1/src/core/tcp.c ****        This can only be valid for sequential APIs, not for the raw API. */
 264:../lwip-1.4.1/src/core/tcp.c ****     tcp_output(pcb);
 555              		.loc 1 264 0 is_stmt 1
 556 0224 7868     		ldr	r0, [r7, #4]
 557 0226 FFF7FEFF 		bl	tcp_output
 558              	.L36:
 265:../lwip-1.4.1/src/core/tcp.c ****   }
 266:../lwip-1.4.1/src/core/tcp.c ****   return err;
 559              		.loc 1 266 0
 560 022a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 561              	.L17:
 562 022c 5BB2     		sxtb	r3, r3
 267:../lwip-1.4.1/src/core/tcp.c **** }
 563              		.loc 1 267 0
 564 022e 1846     		mov	r0, r3
 565 0230 1037     		adds	r7, r7, #16
 566              		.cfi_def_cfa_offset 16
 567 0232 BD46     		mov	sp, r7
 568              		.cfi_def_cfa_register 13
 569              		@ sp needed
 570 0234 B0BD     		pop	{r4, r5, r7, pc}
 571              	.L38:
 572 0236 00BF     		.align	2
 573              	.L37:
 574 0238 00000000 		.word	tcp_active_pcbs
 575 023c 00000000 		.word	tcp_tmp_pcb
 576 0240 00000000 		.word	tcp_active_pcbs_changed
 577 0244 00000000 		.word	tcp_tw_pcbs
 578 0248 00000000 		.word	tcp_bound_pcbs
 579 024c 00000000 		.word	tcp_listen_pcbs
 580              		.cfi_endproc
 581              	.LFE2:
 583              		.section	.text.tcp_close,"ax",%progbits
 584              		.align	2
 585              		.global	tcp_close
 586              		.thumb
 587              		.thumb_func
 589              	tcp_close:
 590              	.LFB3:
 268:../lwip-1.4.1/src/core/tcp.c **** 
 269:../lwip-1.4.1/src/core/tcp.c **** /**
 270:../lwip-1.4.1/src/core/tcp.c ****  * Closes the connection held by the PCB.
 271:../lwip-1.4.1/src/core/tcp.c ****  *
 272:../lwip-1.4.1/src/core/tcp.c ****  * Listening pcbs are freed and may not be referenced any more.
 273:../lwip-1.4.1/src/core/tcp.c ****  * Connection pcbs are freed if not yet connected and may not be referenced
 274:../lwip-1.4.1/src/core/tcp.c ****  * any more. If a connection is established (at least SYN received or in
 275:../lwip-1.4.1/src/core/tcp.c ****  * a closing state), the connection is closed, and put in a closing state.
 276:../lwip-1.4.1/src/core/tcp.c ****  * The pcb is then automatically freed in tcp_slowtmr(). It is therefore
 277:../lwip-1.4.1/src/core/tcp.c ****  * unsafe to reference it (unless an error is returned).
 278:../lwip-1.4.1/src/core/tcp.c ****  *
 279:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp_pcb to close
 280:../lwip-1.4.1/src/core/tcp.c ****  * @return ERR_OK if connection has been closed
 281:../lwip-1.4.1/src/core/tcp.c ****  *         another err_t if closing failed and pcb is not freed
 282:../lwip-1.4.1/src/core/tcp.c ****  */
 283:../lwip-1.4.1/src/core/tcp.c **** err_t
 284:../lwip-1.4.1/src/core/tcp.c **** tcp_close(struct tcp_pcb *pcb)
 285:../lwip-1.4.1/src/core/tcp.c **** {
 591              		.loc 1 285 0
 592              		.cfi_startproc
 593              		@ args = 0, pretend = 0, frame = 8
 594              		@ frame_needed = 1, uses_anonymous_args = 0
 595 0000 80B5     		push	{r7, lr}
 596              		.cfi_def_cfa_offset 8
 597              		.cfi_offset 7, -8
 598              		.cfi_offset 14, -4
 599 0002 82B0     		sub	sp, sp, #8
 600              		.cfi_def_cfa_offset 16
 601 0004 00AF     		add	r7, sp, #0
 602              		.cfi_def_cfa_register 7
 603 0006 7860     		str	r0, [r7, #4]
 286:../lwip-1.4.1/src/core/tcp.c **** #if TCP_DEBUG
 287:../lwip-1.4.1/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
 288:../lwip-1.4.1/src/core/tcp.c ****   tcp_debug_print_state(pcb->state);
 289:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_DEBUG */
 290:../lwip-1.4.1/src/core/tcp.c **** 
 291:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state != LISTEN) {
 604              		.loc 1 291 0
 605 0008 7B68     		ldr	r3, [r7, #4]
 606 000a 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 607 000c 012B     		cmp	r3, #1
 608 000e 06D0     		beq	.L40
 292:../lwip-1.4.1/src/core/tcp.c ****     /* Set a flag not to receive any more data... */
 293:../lwip-1.4.1/src/core/tcp.c ****     pcb->flags |= TF_RXCLOSED;
 609              		.loc 1 293 0
 610 0010 7B68     		ldr	r3, [r7, #4]
 611 0012 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 612 0014 43F01003 		orr	r3, r3, #16
 613 0018 DAB2     		uxtb	r2, r3
 614 001a 7B68     		ldr	r3, [r7, #4]
 615 001c 9A77     		strb	r2, [r3, #30]
 616              	.L40:
 294:../lwip-1.4.1/src/core/tcp.c ****   }
 295:../lwip-1.4.1/src/core/tcp.c ****   /* ... and close */
 296:../lwip-1.4.1/src/core/tcp.c ****   return tcp_close_shutdown(pcb, 1);
 617              		.loc 1 296 0
 618 001e 7868     		ldr	r0, [r7, #4]
 619 0020 0121     		movs	r1, #1
 620 0022 FFF7FEFF 		bl	tcp_close_shutdown
 621 0026 0346     		mov	r3, r0
 297:../lwip-1.4.1/src/core/tcp.c **** }
 622              		.loc 1 297 0
 623 0028 1846     		mov	r0, r3
 624 002a 0837     		adds	r7, r7, #8
 625              		.cfi_def_cfa_offset 8
 626 002c BD46     		mov	sp, r7
 627              		.cfi_def_cfa_register 13
 628              		@ sp needed
 629 002e 80BD     		pop	{r7, pc}
 630              		.cfi_endproc
 631              	.LFE3:
 633              		.section	.text.tcp_shutdown,"ax",%progbits
 634              		.align	2
 635              		.global	tcp_shutdown
 636              		.thumb
 637              		.thumb_func
 639              	tcp_shutdown:
 640              	.LFB4:
 298:../lwip-1.4.1/src/core/tcp.c **** 
 299:../lwip-1.4.1/src/core/tcp.c **** /**
 300:../lwip-1.4.1/src/core/tcp.c ****  * Causes all or part of a full-duplex connection of this PCB to be shut down.
 301:../lwip-1.4.1/src/core/tcp.c ****  * This doesn't deallocate the PCB unless shutting down both sides!
 302:../lwip-1.4.1/src/core/tcp.c ****  * Shutting down both sides is the same as calling tcp_close, so if it succeds,
 303:../lwip-1.4.1/src/core/tcp.c ****  * the PCB should not be referenced any more.
 304:../lwip-1.4.1/src/core/tcp.c ****  *
 305:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb PCB to shutdown
 306:../lwip-1.4.1/src/core/tcp.c ****  * @param shut_rx shut down receive side if this is != 0
 307:../lwip-1.4.1/src/core/tcp.c ****  * @param shut_tx shut down send side if this is != 0
 308:../lwip-1.4.1/src/core/tcp.c ****  * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 309:../lwip-1.4.1/src/core/tcp.c ****  *         another err_t on error.
 310:../lwip-1.4.1/src/core/tcp.c ****  */
 311:../lwip-1.4.1/src/core/tcp.c **** err_t
 312:../lwip-1.4.1/src/core/tcp.c **** tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
 313:../lwip-1.4.1/src/core/tcp.c **** {
 641              		.loc 1 313 0
 642              		.cfi_startproc
 643              		@ args = 0, pretend = 0, frame = 16
 644              		@ frame_needed = 1, uses_anonymous_args = 0
 645 0000 80B5     		push	{r7, lr}
 646              		.cfi_def_cfa_offset 8
 647              		.cfi_offset 7, -8
 648              		.cfi_offset 14, -4
 649 0002 84B0     		sub	sp, sp, #16
 650              		.cfi_def_cfa_offset 24
 651 0004 00AF     		add	r7, sp, #0
 652              		.cfi_def_cfa_register 7
 653 0006 F860     		str	r0, [r7, #12]
 654 0008 B960     		str	r1, [r7, #8]
 655 000a 7A60     		str	r2, [r7, #4]
 314:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state == LISTEN) {
 656              		.loc 1 314 0
 657 000c FB68     		ldr	r3, [r7, #12]
 658 000e 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 659 0010 012B     		cmp	r3, #1
 660 0012 01D1     		bne	.L43
 315:../lwip-1.4.1/src/core/tcp.c ****     return ERR_CONN;
 661              		.loc 1 315 0
 662 0014 F323     		movs	r3, #243
 663 0016 34E0     		b	.L44
 664              	.L43:
 316:../lwip-1.4.1/src/core/tcp.c ****   }
 317:../lwip-1.4.1/src/core/tcp.c ****   if (shut_rx) {
 665              		.loc 1 317 0
 666 0018 BB68     		ldr	r3, [r7, #8]
 667 001a 002B     		cmp	r3, #0
 668 001c 1BD0     		beq	.L45
 318:../lwip-1.4.1/src/core/tcp.c ****     /* shut down the receive side: set a flag not to receive any more data... */
 319:../lwip-1.4.1/src/core/tcp.c ****     pcb->flags |= TF_RXCLOSED;
 669              		.loc 1 319 0
 670 001e FB68     		ldr	r3, [r7, #12]
 671 0020 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 672 0022 43F01003 		orr	r3, r3, #16
 673 0026 DAB2     		uxtb	r2, r3
 674 0028 FB68     		ldr	r3, [r7, #12]
 675 002a 9A77     		strb	r2, [r3, #30]
 320:../lwip-1.4.1/src/core/tcp.c ****     if (shut_tx) {
 676              		.loc 1 320 0
 677 002c 7B68     		ldr	r3, [r7, #4]
 678 002e 002B     		cmp	r3, #0
 679 0030 05D0     		beq	.L46
 321:../lwip-1.4.1/src/core/tcp.c ****       /* shutting down the tx AND rx side is the same as closing for the raw API */
 322:../lwip-1.4.1/src/core/tcp.c ****       return tcp_close_shutdown(pcb, 1);
 680              		.loc 1 322 0
 681 0032 F868     		ldr	r0, [r7, #12]
 682 0034 0121     		movs	r1, #1
 683 0036 FFF7FEFF 		bl	tcp_close_shutdown
 684 003a 0346     		mov	r3, r0
 685 003c 21E0     		b	.L44
 686              	.L46:
 323:../lwip-1.4.1/src/core/tcp.c ****     }
 324:../lwip-1.4.1/src/core/tcp.c ****     /* ... and free buffered data */
 325:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->refused_data != NULL) {
 687              		.loc 1 325 0
 688 003e FB68     		ldr	r3, [r7, #12]
 689 0040 9B6F     		ldr	r3, [r3, #120]
 690 0042 002B     		cmp	r3, #0
 691 0044 07D0     		beq	.L45
 326:../lwip-1.4.1/src/core/tcp.c ****       pbuf_free(pcb->refused_data);
 692              		.loc 1 326 0
 693 0046 FB68     		ldr	r3, [r7, #12]
 694 0048 9B6F     		ldr	r3, [r3, #120]
 695 004a 1846     		mov	r0, r3
 696 004c FFF7FEFF 		bl	pbuf_free
 327:../lwip-1.4.1/src/core/tcp.c ****       pcb->refused_data = NULL;
 697              		.loc 1 327 0
 698 0050 FB68     		ldr	r3, [r7, #12]
 699 0052 0022     		movs	r2, #0
 700 0054 9A67     		str	r2, [r3, #120]
 701              	.L45:
 328:../lwip-1.4.1/src/core/tcp.c ****     }
 329:../lwip-1.4.1/src/core/tcp.c ****   }
 330:../lwip-1.4.1/src/core/tcp.c ****   if (shut_tx) {
 702              		.loc 1 330 0
 703 0056 7B68     		ldr	r3, [r7, #4]
 704 0058 002B     		cmp	r3, #0
 705 005a 11D0     		beq	.L47
 331:../lwip-1.4.1/src/core/tcp.c ****     /* This can't happen twice since if it succeeds, the pcb's state is changed.
 332:../lwip-1.4.1/src/core/tcp.c ****        Only close in these states as the others directly deallocate the PCB */
 333:../lwip-1.4.1/src/core/tcp.c ****     switch (pcb->state) {
 706              		.loc 1 333 0
 707 005c FB68     		ldr	r3, [r7, #12]
 708 005e 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 709 0060 032B     		cmp	r3, #3
 710 0062 0BDB     		blt	.L48
 711 0064 042B     		cmp	r3, #4
 712 0066 01DD     		ble	.L49
 713 0068 072B     		cmp	r3, #7
 714 006a 07D1     		bne	.L48
 715              	.L49:
 334:../lwip-1.4.1/src/core/tcp.c ****     case SYN_RCVD:
 335:../lwip-1.4.1/src/core/tcp.c ****     case ESTABLISHED:
 336:../lwip-1.4.1/src/core/tcp.c ****     case CLOSE_WAIT:
 337:../lwip-1.4.1/src/core/tcp.c ****       return tcp_close_shutdown(pcb, shut_rx);
 716              		.loc 1 337 0
 717 006c BB68     		ldr	r3, [r7, #8]
 718 006e DBB2     		uxtb	r3, r3
 719 0070 F868     		ldr	r0, [r7, #12]
 720 0072 1946     		mov	r1, r3
 721 0074 FFF7FEFF 		bl	tcp_close_shutdown
 722 0078 0346     		mov	r3, r0
 723 007a 02E0     		b	.L44
 724              	.L48:
 338:../lwip-1.4.1/src/core/tcp.c ****     default:
 339:../lwip-1.4.1/src/core/tcp.c ****       /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
 340:../lwip-1.4.1/src/core/tcp.c ****         into CLOSED state, where the PCB is deallocated. */
 341:../lwip-1.4.1/src/core/tcp.c ****       return ERR_CONN;
 725              		.loc 1 341 0
 726 007c F323     		movs	r3, #243
 727 007e 00E0     		b	.L44
 728              	.L47:
 342:../lwip-1.4.1/src/core/tcp.c ****     }
 343:../lwip-1.4.1/src/core/tcp.c ****   }
 344:../lwip-1.4.1/src/core/tcp.c ****   return ERR_OK;
 729              		.loc 1 344 0
 730 0080 0023     		movs	r3, #0
 731              	.L44:
 732 0082 5BB2     		sxtb	r3, r3
 345:../lwip-1.4.1/src/core/tcp.c **** }
 733              		.loc 1 345 0
 734 0084 1846     		mov	r0, r3
 735 0086 1037     		adds	r7, r7, #16
 736              		.cfi_def_cfa_offset 8
 737 0088 BD46     		mov	sp, r7
 738              		.cfi_def_cfa_register 13
 739              		@ sp needed
 740 008a 80BD     		pop	{r7, pc}
 741              		.cfi_endproc
 742              	.LFE4:
 744              		.section	.text.tcp_abandon,"ax",%progbits
 745              		.align	2
 746              		.global	tcp_abandon
 747              		.thumb
 748              		.thumb_func
 750              	tcp_abandon:
 751              	.LFB5:
 346:../lwip-1.4.1/src/core/tcp.c **** 
 347:../lwip-1.4.1/src/core/tcp.c **** /**
 348:../lwip-1.4.1/src/core/tcp.c ****  * Abandons a connection and optionally sends a RST to the remote
 349:../lwip-1.4.1/src/core/tcp.c ****  * host.  Deletes the local protocol control block. This is done when
 350:../lwip-1.4.1/src/core/tcp.c ****  * a connection is killed because of shortage of memory.
 351:../lwip-1.4.1/src/core/tcp.c ****  *
 352:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp_pcb to abort
 353:../lwip-1.4.1/src/core/tcp.c ****  * @param reset boolean to indicate whether a reset should be sent
 354:../lwip-1.4.1/src/core/tcp.c ****  */
 355:../lwip-1.4.1/src/core/tcp.c **** void
 356:../lwip-1.4.1/src/core/tcp.c **** tcp_abandon(struct tcp_pcb *pcb, int reset)
 357:../lwip-1.4.1/src/core/tcp.c **** {
 752              		.loc 1 357 0
 753              		.cfi_startproc
 754              		@ args = 0, pretend = 0, frame = 24
 755              		@ frame_needed = 1, uses_anonymous_args = 0
 756 0000 B0B5     		push	{r4, r5, r7, lr}
 757              		.cfi_def_cfa_offset 16
 758              		.cfi_offset 4, -16
 759              		.cfi_offset 5, -12
 760              		.cfi_offset 7, -8
 761              		.cfi_offset 14, -4
 762 0002 88B0     		sub	sp, sp, #32
 763              		.cfi_def_cfa_offset 48
 764 0004 02AF     		add	r7, sp, #8
 765              		.cfi_def_cfa 7, 40
 766 0006 7860     		str	r0, [r7, #4]
 767 0008 3960     		str	r1, [r7]
 358:../lwip-1.4.1/src/core/tcp.c ****   u32_t seqno, ackno;
 359:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API  
 360:../lwip-1.4.1/src/core/tcp.c ****   tcp_err_fn errf;
 361:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 362:../lwip-1.4.1/src/core/tcp.c ****   void *errf_arg;
 363:../lwip-1.4.1/src/core/tcp.c **** 
 364:../lwip-1.4.1/src/core/tcp.c ****   /* pcb->state LISTEN not allowed here */
 365:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 366:../lwip-1.4.1/src/core/tcp.c ****     pcb->state != LISTEN);
 367:../lwip-1.4.1/src/core/tcp.c ****   /* Figure out on which TCP PCB list we are, and remove us. If we
 368:../lwip-1.4.1/src/core/tcp.c ****      are in an active state, call the receive function associated with
 369:../lwip-1.4.1/src/core/tcp.c ****      the PCB with a NULL argument, and send an RST to the remote end. */
 370:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state == TIME_WAIT) {
 768              		.loc 1 370 0
 769 000a 7B68     		ldr	r3, [r7, #4]
 770 000c 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 771 000e 0A2B     		cmp	r3, #10
 772 0010 08D1     		bne	.L51
 371:../lwip-1.4.1/src/core/tcp.c ****     tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 773              		.loc 1 371 0
 774 0012 2C48     		ldr	r0, .L57
 775 0014 7968     		ldr	r1, [r7, #4]
 776 0016 FFF7FEFF 		bl	tcp_pcb_remove
 372:../lwip-1.4.1/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 777              		.loc 1 372 0
 778 001a 0220     		movs	r0, #2
 779 001c 7968     		ldr	r1, [r7, #4]
 780 001e FFF7FEFF 		bl	memp_free
 781 0022 4CE0     		b	.L50
 782              	.L51:
 373:../lwip-1.4.1/src/core/tcp.c ****   } else {
 374:../lwip-1.4.1/src/core/tcp.c ****     seqno = pcb->snd_nxt;
 783              		.loc 1 374 0
 784 0024 7B68     		ldr	r3, [r7, #4]
 785 0026 1B6D     		ldr	r3, [r3, #80]
 786 0028 7B61     		str	r3, [r7, #20]
 375:../lwip-1.4.1/src/core/tcp.c ****     ackno = pcb->rcv_nxt;
 787              		.loc 1 375 0
 788 002a 7B68     		ldr	r3, [r7, #4]
 789 002c 9B6A     		ldr	r3, [r3, #40]
 790 002e 3B61     		str	r3, [r7, #16]
 376:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
 377:../lwip-1.4.1/src/core/tcp.c ****     errf = pcb->errf;
 791              		.loc 1 377 0
 792 0030 7B68     		ldr	r3, [r7, #4]
 793 0032 D3F88C30 		ldr	r3, [r3, #140]
 794 0036 FB60     		str	r3, [r7, #12]
 378:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 379:../lwip-1.4.1/src/core/tcp.c ****     errf_arg = pcb->callback_arg;
 795              		.loc 1 379 0
 796 0038 7B68     		ldr	r3, [r7, #4]
 797 003a 1B69     		ldr	r3, [r3, #16]
 798 003c BB60     		str	r3, [r7, #8]
 380:../lwip-1.4.1/src/core/tcp.c ****     TCP_PCB_REMOVE_ACTIVE(pcb);
 799              		.loc 1 380 0
 800 003e 2248     		ldr	r0, .L57+4
 801 0040 7968     		ldr	r1, [r7, #4]
 802 0042 FFF7FEFF 		bl	tcp_pcb_remove
 803 0046 214B     		ldr	r3, .L57+8
 804 0048 0122     		movs	r2, #1
 805 004a 1A70     		strb	r2, [r3]
 381:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->unacked != NULL) {
 806              		.loc 1 381 0
 807 004c 7B68     		ldr	r3, [r7, #4]
 808 004e 1B6F     		ldr	r3, [r3, #112]
 809 0050 002B     		cmp	r3, #0
 810 0052 04D0     		beq	.L53
 382:../lwip-1.4.1/src/core/tcp.c ****       tcp_segs_free(pcb->unacked);
 811              		.loc 1 382 0
 812 0054 7B68     		ldr	r3, [r7, #4]
 813 0056 1B6F     		ldr	r3, [r3, #112]
 814 0058 1846     		mov	r0, r3
 815 005a FFF7FEFF 		bl	tcp_segs_free
 816              	.L53:
 383:../lwip-1.4.1/src/core/tcp.c ****     }
 384:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->unsent != NULL) {
 817              		.loc 1 384 0
 818 005e 7B68     		ldr	r3, [r7, #4]
 819 0060 DB6E     		ldr	r3, [r3, #108]
 820 0062 002B     		cmp	r3, #0
 821 0064 04D0     		beq	.L54
 385:../lwip-1.4.1/src/core/tcp.c ****       tcp_segs_free(pcb->unsent);
 822              		.loc 1 385 0
 823 0066 7B68     		ldr	r3, [r7, #4]
 824 0068 DB6E     		ldr	r3, [r3, #108]
 825 006a 1846     		mov	r0, r3
 826 006c FFF7FEFF 		bl	tcp_segs_free
 827              	.L54:
 386:../lwip-1.4.1/src/core/tcp.c ****     }
 387:../lwip-1.4.1/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ    
 388:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->ooseq != NULL) {
 828              		.loc 1 388 0
 829 0070 7B68     		ldr	r3, [r7, #4]
 830 0072 5B6F     		ldr	r3, [r3, #116]
 831 0074 002B     		cmp	r3, #0
 832 0076 04D0     		beq	.L55
 389:../lwip-1.4.1/src/core/tcp.c ****       tcp_segs_free(pcb->ooseq);
 833              		.loc 1 389 0
 834 0078 7B68     		ldr	r3, [r7, #4]
 835 007a 5B6F     		ldr	r3, [r3, #116]
 836 007c 1846     		mov	r0, r3
 837 007e FFF7FEFF 		bl	tcp_segs_free
 838              	.L55:
 390:../lwip-1.4.1/src/core/tcp.c ****     }
 391:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
 392:../lwip-1.4.1/src/core/tcp.c ****     if (reset) {
 839              		.loc 1 392 0
 840 0082 3B68     		ldr	r3, [r7]
 841 0084 002B     		cmp	r3, #0
 842 0086 0ED0     		beq	.L56
 393:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
 394:../lwip-1.4.1/src/core/tcp.c ****       tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 843              		.loc 1 394 0
 844 0088 7D68     		ldr	r5, [r7, #4]
 845 008a 7B68     		ldr	r3, [r7, #4]
 846 008c 1C1D     		adds	r4, r3, #4
 847 008e 7B68     		ldr	r3, [r7, #4]
 848 0090 5A8B     		ldrh	r2, [r3, #26]
 849 0092 7B68     		ldr	r3, [r7, #4]
 850 0094 9B8B     		ldrh	r3, [r3, #28]
 851 0096 0092     		str	r2, [sp]
 852 0098 0193     		str	r3, [sp, #4]
 853 009a 7869     		ldr	r0, [r7, #20]
 854 009c 3969     		ldr	r1, [r7, #16]
 855 009e 2A46     		mov	r2, r5
 856 00a0 2346     		mov	r3, r4
 857 00a2 FFF7FEFF 		bl	tcp_rst
 858              	.L56:
 395:../lwip-1.4.1/src/core/tcp.c ****     }
 396:../lwip-1.4.1/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 859              		.loc 1 396 0
 860 00a6 0220     		movs	r0, #2
 861 00a8 7968     		ldr	r1, [r7, #4]
 862 00aa FFF7FEFF 		bl	memp_free
 397:../lwip-1.4.1/src/core/tcp.c ****     TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 863              		.loc 1 397 0
 864 00ae FB68     		ldr	r3, [r7, #12]
 865 00b0 002B     		cmp	r3, #0
 866 00b2 04D0     		beq	.L50
 867              		.loc 1 397 0 is_stmt 0 discriminator 1
 868 00b4 FB68     		ldr	r3, [r7, #12]
 869 00b6 B868     		ldr	r0, [r7, #8]
 870 00b8 6FF00901 		mvn	r1, #9
 871 00bc 9847     		blx	r3
 872              	.L50:
 398:../lwip-1.4.1/src/core/tcp.c ****   }
 399:../lwip-1.4.1/src/core/tcp.c **** }
 873              		.loc 1 399 0 is_stmt 1
 874 00be 1837     		adds	r7, r7, #24
 875              		.cfi_def_cfa_offset 16
 876 00c0 BD46     		mov	sp, r7
 877              		.cfi_def_cfa_register 13
 878              		@ sp needed
 879 00c2 B0BD     		pop	{r4, r5, r7, pc}
 880              	.L58:
 881              		.align	2
 882              	.L57:
 883 00c4 00000000 		.word	tcp_tw_pcbs
 884 00c8 00000000 		.word	tcp_active_pcbs
 885 00cc 00000000 		.word	tcp_active_pcbs_changed
 886              		.cfi_endproc
 887              	.LFE5:
 889              		.section	.text.tcp_abort,"ax",%progbits
 890              		.align	2
 891              		.global	tcp_abort
 892              		.thumb
 893              		.thumb_func
 895              	tcp_abort:
 896              	.LFB6:
 400:../lwip-1.4.1/src/core/tcp.c **** 
 401:../lwip-1.4.1/src/core/tcp.c **** /**
 402:../lwip-1.4.1/src/core/tcp.c ****  * Aborts the connection by sending a RST (reset) segment to the remote
 403:../lwip-1.4.1/src/core/tcp.c ****  * host. The pcb is deallocated. This function never fails.
 404:../lwip-1.4.1/src/core/tcp.c ****  *
 405:../lwip-1.4.1/src/core/tcp.c ****  * ATTENTION: When calling this from one of the TCP callbacks, make
 406:../lwip-1.4.1/src/core/tcp.c ****  * sure you always return ERR_ABRT (and never return ERR_ABRT otherwise
 407:../lwip-1.4.1/src/core/tcp.c ****  * or you will risk accessing deallocated memory or memory leaks!
 408:../lwip-1.4.1/src/core/tcp.c ****  *
 409:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp pcb to abort
 410:../lwip-1.4.1/src/core/tcp.c ****  */
 411:../lwip-1.4.1/src/core/tcp.c **** void
 412:../lwip-1.4.1/src/core/tcp.c **** tcp_abort(struct tcp_pcb *pcb)
 413:../lwip-1.4.1/src/core/tcp.c **** {
 897              		.loc 1 413 0
 898              		.cfi_startproc
 899              		@ args = 0, pretend = 0, frame = 8
 900              		@ frame_needed = 1, uses_anonymous_args = 0
 901 0000 80B5     		push	{r7, lr}
 902              		.cfi_def_cfa_offset 8
 903              		.cfi_offset 7, -8
 904              		.cfi_offset 14, -4
 905 0002 82B0     		sub	sp, sp, #8
 906              		.cfi_def_cfa_offset 16
 907 0004 00AF     		add	r7, sp, #0
 908              		.cfi_def_cfa_register 7
 909 0006 7860     		str	r0, [r7, #4]
 414:../lwip-1.4.1/src/core/tcp.c ****   tcp_abandon(pcb, 1);
 910              		.loc 1 414 0
 911 0008 7868     		ldr	r0, [r7, #4]
 912 000a 0121     		movs	r1, #1
 913 000c FFF7FEFF 		bl	tcp_abandon
 415:../lwip-1.4.1/src/core/tcp.c **** }
 914              		.loc 1 415 0
 915 0010 0837     		adds	r7, r7, #8
 916              		.cfi_def_cfa_offset 8
 917 0012 BD46     		mov	sp, r7
 918              		.cfi_def_cfa_register 13
 919              		@ sp needed
 920 0014 80BD     		pop	{r7, pc}
 921              		.cfi_endproc
 922              	.LFE6:
 924 0016 00BF     		.section	.text.tcp_bind,"ax",%progbits
 925              		.align	2
 926              		.global	tcp_bind
 927              		.thumb
 928              		.thumb_func
 930              	tcp_bind:
 931              	.LFB7:
 416:../lwip-1.4.1/src/core/tcp.c **** 
 417:../lwip-1.4.1/src/core/tcp.c **** /**
 418:../lwip-1.4.1/src/core/tcp.c ****  * Binds the connection to a local portnumber and IP address. If the
 419:../lwip-1.4.1/src/core/tcp.c ****  * IP address is not given (i.e., ipaddr == NULL), the IP address of
 420:../lwip-1.4.1/src/core/tcp.c ****  * the outgoing network interface is used instead.
 421:../lwip-1.4.1/src/core/tcp.c ****  *
 422:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp_pcb to bind (no check is done whether this pcb is
 423:../lwip-1.4.1/src/core/tcp.c ****  *        already bound!)
 424:../lwip-1.4.1/src/core/tcp.c ****  * @param ipaddr the local ip address to bind to (use IP_ADDR_ANY to bind
 425:../lwip-1.4.1/src/core/tcp.c ****  *        to any local address
 426:../lwip-1.4.1/src/core/tcp.c ****  * @param port the local port to bind to
 427:../lwip-1.4.1/src/core/tcp.c ****  * @return ERR_USE if the port is already in use
 428:../lwip-1.4.1/src/core/tcp.c ****  *         ERR_VAL if bind failed because the PCB is not in a valid state
 429:../lwip-1.4.1/src/core/tcp.c ****  *         ERR_OK if bound
 430:../lwip-1.4.1/src/core/tcp.c ****  */
 431:../lwip-1.4.1/src/core/tcp.c **** err_t
 432:../lwip-1.4.1/src/core/tcp.c **** tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
 433:../lwip-1.4.1/src/core/tcp.c **** {
 932              		.loc 1 433 0
 933              		.cfi_startproc
 934              		@ args = 0, pretend = 0, frame = 32
 935              		@ frame_needed = 1, uses_anonymous_args = 0
 936 0000 80B5     		push	{r7, lr}
 937              		.cfi_def_cfa_offset 8
 938              		.cfi_offset 7, -8
 939              		.cfi_offset 14, -4
 940 0002 88B0     		sub	sp, sp, #32
 941              		.cfi_def_cfa_offset 40
 942 0004 00AF     		add	r7, sp, #0
 943              		.cfi_def_cfa_register 7
 944 0006 F860     		str	r0, [r7, #12]
 945 0008 B960     		str	r1, [r7, #8]
 946 000a 1346     		mov	r3, r2
 947 000c FB80     		strh	r3, [r7, #6]	@ movhi
 434:../lwip-1.4.1/src/core/tcp.c ****   int i;
 435:../lwip-1.4.1/src/core/tcp.c ****   int max_pcb_list = NUM_TCP_PCB_LISTS;
 948              		.loc 1 435 0
 949 000e 0423     		movs	r3, #4
 950 0010 7B61     		str	r3, [r7, #20]
 436:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb *cpcb;
 437:../lwip-1.4.1/src/core/tcp.c **** 
 438:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 951              		.loc 1 438 0
 952 0012 FB68     		ldr	r3, [r7, #12]
 953 0014 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 954 0016 002B     		cmp	r3, #0
 955 0018 01D0     		beq	.L61
 956              		.loc 1 438 0 is_stmt 0 discriminator 1
 957 001a FA23     		movs	r3, #250
 958 001c 55E0     		b	.L62
 959              	.L61:
 439:../lwip-1.4.1/src/core/tcp.c **** 
 440:../lwip-1.4.1/src/core/tcp.c **** #if SO_REUSE
 441:../lwip-1.4.1/src/core/tcp.c ****   /* Unless the REUSEADDR flag is set,
 442:../lwip-1.4.1/src/core/tcp.c ****      we have to check the pcbs in TIME-WAIT state, also.
 443:../lwip-1.4.1/src/core/tcp.c ****      We do not dump TIME_WAIT pcb's; they can still be matched by incoming
 444:../lwip-1.4.1/src/core/tcp.c ****      packets using both local and remote IP addresses and ports to distinguish.
 445:../lwip-1.4.1/src/core/tcp.c ****    */
 446:../lwip-1.4.1/src/core/tcp.c ****   if (ip_get_option(pcb, SOF_REUSEADDR)) {
 447:../lwip-1.4.1/src/core/tcp.c ****     max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
 448:../lwip-1.4.1/src/core/tcp.c ****   }
 449:../lwip-1.4.1/src/core/tcp.c **** #endif /* SO_REUSE */
 450:../lwip-1.4.1/src/core/tcp.c **** 
 451:../lwip-1.4.1/src/core/tcp.c ****   if (port == 0) {
 960              		.loc 1 451 0 is_stmt 1
 961 001e FB88     		ldrh	r3, [r7, #6]
 962 0020 002B     		cmp	r3, #0
 963 0022 08D1     		bne	.L63
 452:../lwip-1.4.1/src/core/tcp.c ****     port = tcp_new_port();
 964              		.loc 1 452 0
 965 0024 FFF7FEFF 		bl	tcp_new_port
 966 0028 0346     		mov	r3, r0
 967 002a FB80     		strh	r3, [r7, #6]	@ movhi
 453:../lwip-1.4.1/src/core/tcp.c ****     if (port == 0) {
 968              		.loc 1 453 0
 969 002c FB88     		ldrh	r3, [r7, #6]
 970 002e 002B     		cmp	r3, #0
 971 0030 01D1     		bne	.L63
 454:../lwip-1.4.1/src/core/tcp.c ****       return ERR_BUF;
 972              		.loc 1 454 0
 973 0032 FE23     		movs	r3, #254
 974 0034 49E0     		b	.L62
 975              	.L63:
 455:../lwip-1.4.1/src/core/tcp.c ****     }
 456:../lwip-1.4.1/src/core/tcp.c ****   }
 457:../lwip-1.4.1/src/core/tcp.c **** 
 458:../lwip-1.4.1/src/core/tcp.c ****   /* Check if the address already is in use (on all lists) */
 459:../lwip-1.4.1/src/core/tcp.c ****   for (i = 0; i < max_pcb_list; i++) {
 976              		.loc 1 459 0
 977 0036 0023     		movs	r3, #0
 978 0038 FB61     		str	r3, [r7, #28]
 979 003a 2AE0     		b	.L64
 980              	.L69:
 460:../lwip-1.4.1/src/core/tcp.c ****     for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 981              		.loc 1 460 0
 982 003c 254A     		ldr	r2, .L71
 983 003e FB69     		ldr	r3, [r7, #28]
 984 0040 52F82330 		ldr	r3, [r2, r3, lsl #2]
 985 0044 1B68     		ldr	r3, [r3]
 986 0046 BB61     		str	r3, [r7, #24]
 987 0048 1DE0     		b	.L65
 988              	.L68:
 461:../lwip-1.4.1/src/core/tcp.c ****       if (cpcb->local_port == port) {
 989              		.loc 1 461 0
 990 004a BB69     		ldr	r3, [r7, #24]
 991 004c 5B8B     		ldrh	r3, [r3, #26]
 992 004e FA88     		ldrh	r2, [r7, #6]
 993 0050 9A42     		cmp	r2, r3
 994 0052 15D1     		bne	.L66
 462:../lwip-1.4.1/src/core/tcp.c **** #if SO_REUSE
 463:../lwip-1.4.1/src/core/tcp.c ****         /* Omit checking for the same port if both pcbs have REUSEADDR set.
 464:../lwip-1.4.1/src/core/tcp.c ****            For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
 465:../lwip-1.4.1/src/core/tcp.c ****            tcp_connect. */
 466:../lwip-1.4.1/src/core/tcp.c ****         if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 467:../lwip-1.4.1/src/core/tcp.c ****             !ip_get_option(cpcb, SOF_REUSEADDR))
 468:../lwip-1.4.1/src/core/tcp.c **** #endif /* SO_REUSE */
 469:../lwip-1.4.1/src/core/tcp.c ****         {
 470:../lwip-1.4.1/src/core/tcp.c ****           if (ip_addr_isany(&(cpcb->local_ip)) ||
 995              		.loc 1 470 0
 996 0054 BB69     		ldr	r3, [r7, #24]
 997 0056 002B     		cmp	r3, #0
 998 0058 10D0     		beq	.L67
 999              		.loc 1 470 0 is_stmt 0 discriminator 1
 1000 005a BB69     		ldr	r3, [r7, #24]
 1001 005c 1B68     		ldr	r3, [r3]
 1002 005e 002B     		cmp	r3, #0
 1003 0060 0CD0     		beq	.L67
 1004              		.loc 1 470 0 discriminator 2
 1005 0062 BB68     		ldr	r3, [r7, #8]
 1006 0064 002B     		cmp	r3, #0
 1007 0066 09D0     		beq	.L67
 471:../lwip-1.4.1/src/core/tcp.c ****               ip_addr_isany(ipaddr) ||
 1008              		.loc 1 471 0 is_stmt 1
 1009 0068 BB68     		ldr	r3, [r7, #8]
 1010 006a 1B68     		ldr	r3, [r3]
 1011 006c 002B     		cmp	r3, #0
 1012 006e 05D0     		beq	.L67
 472:../lwip-1.4.1/src/core/tcp.c ****               ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 1013              		.loc 1 472 0 discriminator 1
 1014 0070 BB69     		ldr	r3, [r7, #24]
 1015 0072 1A68     		ldr	r2, [r3]
 1016 0074 BB68     		ldr	r3, [r7, #8]
 1017 0076 1B68     		ldr	r3, [r3]
 471:../lwip-1.4.1/src/core/tcp.c ****               ip_addr_isany(ipaddr) ||
 1018              		.loc 1 471 0 discriminator 1
 1019 0078 9A42     		cmp	r2, r3
 1020 007a 01D1     		bne	.L66
 1021              	.L67:
 473:../lwip-1.4.1/src/core/tcp.c ****             return ERR_USE;
 1022              		.loc 1 473 0
 1023 007c F823     		movs	r3, #248
 1024 007e 24E0     		b	.L62
 1025              	.L66:
 460:../lwip-1.4.1/src/core/tcp.c ****       if (cpcb->local_port == port) {
 1026              		.loc 1 460 0 discriminator 2
 1027 0080 BB69     		ldr	r3, [r7, #24]
 1028 0082 DB68     		ldr	r3, [r3, #12]
 1029 0084 BB61     		str	r3, [r7, #24]
 1030              	.L65:
 460:../lwip-1.4.1/src/core/tcp.c ****       if (cpcb->local_port == port) {
 1031              		.loc 1 460 0 is_stmt 0 discriminator 1
 1032 0086 BB69     		ldr	r3, [r7, #24]
 1033 0088 002B     		cmp	r3, #0
 1034 008a DED1     		bne	.L68
 459:../lwip-1.4.1/src/core/tcp.c ****     for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 1035              		.loc 1 459 0 is_stmt 1 discriminator 2
 1036 008c FB69     		ldr	r3, [r7, #28]
 1037 008e 0133     		adds	r3, r3, #1
 1038 0090 FB61     		str	r3, [r7, #28]
 1039              	.L64:
 459:../lwip-1.4.1/src/core/tcp.c ****     for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 1040              		.loc 1 459 0 is_stmt 0 discriminator 1
 1041 0092 FA69     		ldr	r2, [r7, #28]
 1042 0094 7B69     		ldr	r3, [r7, #20]
 1043 0096 9A42     		cmp	r2, r3
 1044 0098 D0DB     		blt	.L69
 474:../lwip-1.4.1/src/core/tcp.c ****           }
 475:../lwip-1.4.1/src/core/tcp.c ****         }
 476:../lwip-1.4.1/src/core/tcp.c ****       }
 477:../lwip-1.4.1/src/core/tcp.c ****     }
 478:../lwip-1.4.1/src/core/tcp.c ****   }
 479:../lwip-1.4.1/src/core/tcp.c **** 
 480:../lwip-1.4.1/src/core/tcp.c ****   if (!ip_addr_isany(ipaddr)) {
 1045              		.loc 1 480 0 is_stmt 1
 1046 009a BB68     		ldr	r3, [r7, #8]
 1047 009c 002B     		cmp	r3, #0
 1048 009e 07D0     		beq	.L70
 1049              		.loc 1 480 0 is_stmt 0 discriminator 1
 1050 00a0 BB68     		ldr	r3, [r7, #8]
 1051 00a2 1B68     		ldr	r3, [r3]
 1052 00a4 002B     		cmp	r3, #0
 1053 00a6 03D0     		beq	.L70
 481:../lwip-1.4.1/src/core/tcp.c ****     pcb->local_ip = *ipaddr;
 1054              		.loc 1 481 0 is_stmt 1
 1055 00a8 FB68     		ldr	r3, [r7, #12]
 1056 00aa BA68     		ldr	r2, [r7, #8]
 1057 00ac 1268     		ldr	r2, [r2]
 1058 00ae 1A60     		str	r2, [r3]
 1059              	.L70:
 482:../lwip-1.4.1/src/core/tcp.c ****   }
 483:../lwip-1.4.1/src/core/tcp.c ****   pcb->local_port = port;
 1060              		.loc 1 483 0
 1061 00b0 FB68     		ldr	r3, [r7, #12]
 1062 00b2 FA88     		ldrh	r2, [r7, #6]	@ movhi
 1063 00b4 5A83     		strh	r2, [r3, #26]	@ movhi
 484:../lwip-1.4.1/src/core/tcp.c ****   TCP_REG(&tcp_bound_pcbs, pcb);
 1064              		.loc 1 484 0
 1065 00b6 084B     		ldr	r3, .L71+4
 1066 00b8 1A68     		ldr	r2, [r3]
 1067 00ba FB68     		ldr	r3, [r7, #12]
 1068 00bc DA60     		str	r2, [r3, #12]
 1069 00be 064A     		ldr	r2, .L71+4
 1070 00c0 FB68     		ldr	r3, [r7, #12]
 1071 00c2 1360     		str	r3, [r2]
 1072 00c4 FFF7FEFF 		bl	tcp_timer_needed
 485:../lwip-1.4.1/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
 486:../lwip-1.4.1/src/core/tcp.c ****   return ERR_OK;
 1073              		.loc 1 486 0
 1074 00c8 0023     		movs	r3, #0
 1075              	.L62:
 1076 00ca 5BB2     		sxtb	r3, r3
 487:../lwip-1.4.1/src/core/tcp.c **** }
 1077              		.loc 1 487 0
 1078 00cc 1846     		mov	r0, r3
 1079 00ce 2037     		adds	r7, r7, #32
 1080              		.cfi_def_cfa_offset 8
 1081 00d0 BD46     		mov	sp, r7
 1082              		.cfi_def_cfa_register 13
 1083              		@ sp needed
 1084 00d2 80BD     		pop	{r7, pc}
 1085              	.L72:
 1086              		.align	2
 1087              	.L71:
 1088 00d4 00000000 		.word	tcp_pcb_lists
 1089 00d8 00000000 		.word	tcp_bound_pcbs
 1090              		.cfi_endproc
 1091              	.LFE7:
 1093              		.section	.text.tcp_accept_null,"ax",%progbits
 1094              		.align	2
 1095              		.thumb
 1096              		.thumb_func
 1098              	tcp_accept_null:
 1099              	.LFB8:
 488:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
 489:../lwip-1.4.1/src/core/tcp.c **** /**
 490:../lwip-1.4.1/src/core/tcp.c ****  * Default accept callback if no accept callback is specified by the user.
 491:../lwip-1.4.1/src/core/tcp.c ****  */
 492:../lwip-1.4.1/src/core/tcp.c **** static err_t
 493:../lwip-1.4.1/src/core/tcp.c **** tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
 494:../lwip-1.4.1/src/core/tcp.c **** {
 1100              		.loc 1 494 0
 1101              		.cfi_startproc
 1102              		@ args = 0, pretend = 0, frame = 16
 1103              		@ frame_needed = 1, uses_anonymous_args = 0
 1104              		@ link register save eliminated.
 1105 0000 80B4     		push	{r7}
 1106              		.cfi_def_cfa_offset 4
 1107              		.cfi_offset 7, -4
 1108 0002 85B0     		sub	sp, sp, #20
 1109              		.cfi_def_cfa_offset 24
 1110 0004 00AF     		add	r7, sp, #0
 1111              		.cfi_def_cfa_register 7
 1112 0006 F860     		str	r0, [r7, #12]
 1113 0008 B960     		str	r1, [r7, #8]
 1114 000a 1346     		mov	r3, r2
 1115 000c FB71     		strb	r3, [r7, #7]
 495:../lwip-1.4.1/src/core/tcp.c ****   LWIP_UNUSED_ARG(arg);
 496:../lwip-1.4.1/src/core/tcp.c ****   LWIP_UNUSED_ARG(pcb);
 497:../lwip-1.4.1/src/core/tcp.c ****   LWIP_UNUSED_ARG(err);
 498:../lwip-1.4.1/src/core/tcp.c **** 
 499:../lwip-1.4.1/src/core/tcp.c ****   return ERR_ABRT;
 1116              		.loc 1 499 0
 1117 000e F623     		movs	r3, #246
 1118 0010 5BB2     		sxtb	r3, r3
 500:../lwip-1.4.1/src/core/tcp.c **** }
 1119              		.loc 1 500 0
 1120 0012 1846     		mov	r0, r3
 1121 0014 1437     		adds	r7, r7, #20
 1122              		.cfi_def_cfa_offset 4
 1123 0016 BD46     		mov	sp, r7
 1124              		.cfi_def_cfa_register 13
 1125              		@ sp needed
 1126 0018 5DF8047B 		ldr	r7, [sp], #4
 1127              		.cfi_restore 7
 1128              		.cfi_def_cfa_offset 0
 1129 001c 7047     		bx	lr
 1130              		.cfi_endproc
 1131              	.LFE8:
 1133 001e 00BF     		.section	.text.tcp_listen_with_backlog,"ax",%progbits
 1134              		.align	2
 1135              		.global	tcp_listen_with_backlog
 1136              		.thumb
 1137              		.thumb_func
 1139              	tcp_listen_with_backlog:
 1140              	.LFB9:
 501:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 502:../lwip-1.4.1/src/core/tcp.c **** 
 503:../lwip-1.4.1/src/core/tcp.c **** /**
 504:../lwip-1.4.1/src/core/tcp.c ****  * Set the state of the connection to be LISTEN, which means that it
 505:../lwip-1.4.1/src/core/tcp.c ****  * is able to accept incoming connections. The protocol control block
 506:../lwip-1.4.1/src/core/tcp.c ****  * is reallocated in order to consume less memory. Setting the
 507:../lwip-1.4.1/src/core/tcp.c ****  * connection to LISTEN is an irreversible process.
 508:../lwip-1.4.1/src/core/tcp.c ****  *
 509:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the original tcp_pcb
 510:../lwip-1.4.1/src/core/tcp.c ****  * @param backlog the incoming connections queue limit
 511:../lwip-1.4.1/src/core/tcp.c ****  * @return tcp_pcb used for listening, consumes less memory.
 512:../lwip-1.4.1/src/core/tcp.c ****  *
 513:../lwip-1.4.1/src/core/tcp.c ****  * @note The original tcp_pcb is freed. This function therefore has to be
 514:../lwip-1.4.1/src/core/tcp.c ****  *       called like this:
 515:../lwip-1.4.1/src/core/tcp.c ****  *             tpcb = tcp_listen(tpcb);
 516:../lwip-1.4.1/src/core/tcp.c ****  */
 517:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb *
 518:../lwip-1.4.1/src/core/tcp.c **** tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
 519:../lwip-1.4.1/src/core/tcp.c **** {
 1141              		.loc 1 519 0
 1142              		.cfi_startproc
 1143              		@ args = 0, pretend = 0, frame = 16
 1144              		@ frame_needed = 1, uses_anonymous_args = 0
 1145 0000 80B5     		push	{r7, lr}
 1146              		.cfi_def_cfa_offset 8
 1147              		.cfi_offset 7, -8
 1148              		.cfi_offset 14, -4
 1149 0002 84B0     		sub	sp, sp, #16
 1150              		.cfi_def_cfa_offset 24
 1151 0004 00AF     		add	r7, sp, #0
 1152              		.cfi_def_cfa_register 7
 1153 0006 7860     		str	r0, [r7, #4]
 1154 0008 0B46     		mov	r3, r1
 1155 000a FB70     		strb	r3, [r7, #3]
 520:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb_listen *lpcb;
 521:../lwip-1.4.1/src/core/tcp.c **** 
 522:../lwip-1.4.1/src/core/tcp.c ****   LWIP_UNUSED_ARG(backlog);
 523:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 1156              		.loc 1 523 0
 1157 000c 7B68     		ldr	r3, [r7, #4]
 1158 000e 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 1159 0010 002B     		cmp	r3, #0
 1160 0012 01D0     		beq	.L76
 1161              		.loc 1 523 0 is_stmt 0 discriminator 1
 1162 0014 0023     		movs	r3, #0
 1163 0016 7CE0     		b	.L77
 1164              	.L76:
 524:../lwip-1.4.1/src/core/tcp.c **** 
 525:../lwip-1.4.1/src/core/tcp.c ****   /* already listening? */
 526:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state == LISTEN) {
 1165              		.loc 1 526 0 is_stmt 1
 1166 0018 7B68     		ldr	r3, [r7, #4]
 1167 001a 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 1168 001c 012B     		cmp	r3, #1
 1169 001e 01D1     		bne	.L78
 527:../lwip-1.4.1/src/core/tcp.c ****     return pcb;
 1170              		.loc 1 527 0
 1171 0020 7B68     		ldr	r3, [r7, #4]
 1172 0022 76E0     		b	.L77
 1173              	.L78:
 528:../lwip-1.4.1/src/core/tcp.c ****   }
 529:../lwip-1.4.1/src/core/tcp.c **** #if SO_REUSE
 530:../lwip-1.4.1/src/core/tcp.c ****   if (ip_get_option(pcb, SOF_REUSEADDR)) {
 531:../lwip-1.4.1/src/core/tcp.c ****     /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
 532:../lwip-1.4.1/src/core/tcp.c ****        is declared (listen-/connection-pcb), we have to make sure now that
 533:../lwip-1.4.1/src/core/tcp.c ****        this port is only used once for every local IP. */
 534:../lwip-1.4.1/src/core/tcp.c ****     for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 535:../lwip-1.4.1/src/core/tcp.c ****       if (lpcb->local_port == pcb->local_port) {
 536:../lwip-1.4.1/src/core/tcp.c ****         if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
 537:../lwip-1.4.1/src/core/tcp.c ****           /* this address/port is already used */
 538:../lwip-1.4.1/src/core/tcp.c ****           return NULL;
 539:../lwip-1.4.1/src/core/tcp.c ****         }
 540:../lwip-1.4.1/src/core/tcp.c ****       }
 541:../lwip-1.4.1/src/core/tcp.c ****     }
 542:../lwip-1.4.1/src/core/tcp.c ****   }
 543:../lwip-1.4.1/src/core/tcp.c **** #endif /* SO_REUSE */
 544:../lwip-1.4.1/src/core/tcp.c ****   lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 1174              		.loc 1 544 0
 1175 0024 0320     		movs	r0, #3
 1176 0026 FFF7FEFF 		bl	memp_malloc
 1177 002a F860     		str	r0, [r7, #12]
 545:../lwip-1.4.1/src/core/tcp.c ****   if (lpcb == NULL) {
 1178              		.loc 1 545 0
 1179 002c FB68     		ldr	r3, [r7, #12]
 1180 002e 002B     		cmp	r3, #0
 1181 0030 01D1     		bne	.L79
 546:../lwip-1.4.1/src/core/tcp.c ****     return NULL;
 1182              		.loc 1 546 0
 1183 0032 0023     		movs	r3, #0
 1184 0034 6DE0     		b	.L77
 1185              	.L79:
 547:../lwip-1.4.1/src/core/tcp.c ****   }
 548:../lwip-1.4.1/src/core/tcp.c ****   lpcb->callback_arg = pcb->callback_arg;
 1186              		.loc 1 548 0
 1187 0036 7B68     		ldr	r3, [r7, #4]
 1188 0038 1A69     		ldr	r2, [r3, #16]
 1189 003a FB68     		ldr	r3, [r7, #12]
 1190 003c 1A61     		str	r2, [r3, #16]
 549:../lwip-1.4.1/src/core/tcp.c ****   lpcb->local_port = pcb->local_port;
 1191              		.loc 1 549 0
 1192 003e 7B68     		ldr	r3, [r7, #4]
 1193 0040 5A8B     		ldrh	r2, [r3, #26]
 1194 0042 FB68     		ldr	r3, [r7, #12]
 1195 0044 5A83     		strh	r2, [r3, #26]	@ movhi
 550:../lwip-1.4.1/src/core/tcp.c ****   lpcb->state = LISTEN;
 1196              		.loc 1 550 0
 1197 0046 FB68     		ldr	r3, [r7, #12]
 1198 0048 0122     		movs	r2, #1
 1199 004a 1A76     		strb	r2, [r3, #24]
 551:../lwip-1.4.1/src/core/tcp.c ****   lpcb->prio = pcb->prio;
 1200              		.loc 1 551 0
 1201 004c 7B68     		ldr	r3, [r7, #4]
 1202 004e 5A7E     		ldrb	r2, [r3, #25]	@ zero_extendqisi2
 1203 0050 FB68     		ldr	r3, [r7, #12]
 1204 0052 5A76     		strb	r2, [r3, #25]
 552:../lwip-1.4.1/src/core/tcp.c ****   lpcb->so_options = pcb->so_options;
 1205              		.loc 1 552 0
 1206 0054 7B68     		ldr	r3, [r7, #4]
 1207 0056 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 1208 0058 FB68     		ldr	r3, [r7, #12]
 1209 005a 1A72     		strb	r2, [r3, #8]
 553:../lwip-1.4.1/src/core/tcp.c ****   ip_set_option(lpcb, SOF_ACCEPTCONN);
 1210              		.loc 1 553 0
 1211 005c FB68     		ldr	r3, [r7, #12]
 1212 005e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1213 0060 43F00203 		orr	r3, r3, #2
 1214 0064 DAB2     		uxtb	r2, r3
 1215 0066 FB68     		ldr	r3, [r7, #12]
 1216 0068 1A72     		strb	r2, [r3, #8]
 554:../lwip-1.4.1/src/core/tcp.c ****   lpcb->ttl = pcb->ttl;
 1217              		.loc 1 554 0
 1218 006a 7B68     		ldr	r3, [r7, #4]
 1219 006c 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 1220 006e FB68     		ldr	r3, [r7, #12]
 1221 0070 9A72     		strb	r2, [r3, #10]
 555:../lwip-1.4.1/src/core/tcp.c ****   lpcb->tos = pcb->tos;
 1222              		.loc 1 555 0
 1223 0072 7B68     		ldr	r3, [r7, #4]
 1224 0074 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 1225 0076 FB68     		ldr	r3, [r7, #12]
 1226 0078 5A72     		strb	r2, [r3, #9]
 556:../lwip-1.4.1/src/core/tcp.c ****   ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 1227              		.loc 1 556 0
 1228 007a 7B68     		ldr	r3, [r7, #4]
 1229 007c 1A68     		ldr	r2, [r3]
 1230 007e FB68     		ldr	r3, [r7, #12]
 1231 0080 1A60     		str	r2, [r3]
 557:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->local_port != 0) {
 1232              		.loc 1 557 0
 1233 0082 7B68     		ldr	r3, [r7, #4]
 1234 0084 5B8B     		ldrh	r3, [r3, #26]
 1235 0086 002B     		cmp	r3, #0
 1236 0088 27D0     		beq	.L80
 558:../lwip-1.4.1/src/core/tcp.c ****     TCP_RMV(&tcp_bound_pcbs, pcb);
 1237              		.loc 1 558 0
 1238 008a 244B     		ldr	r3, .L88
 1239 008c 1A68     		ldr	r2, [r3]
 1240 008e 7B68     		ldr	r3, [r7, #4]
 1241 0090 9A42     		cmp	r2, r3
 1242 0092 05D1     		bne	.L81
 1243              		.loc 1 558 0 is_stmt 0 discriminator 1
 1244 0094 214B     		ldr	r3, .L88
 1245 0096 1B68     		ldr	r3, [r3]
 1246 0098 DB68     		ldr	r3, [r3, #12]
 1247 009a 204A     		ldr	r2, .L88
 1248 009c 1360     		str	r3, [r2]
 1249 009e 19E0     		b	.L82
 1250              	.L81:
 1251              		.loc 1 558 0 discriminator 2
 1252 00a0 1E4B     		ldr	r3, .L88
 1253 00a2 1B68     		ldr	r3, [r3]
 1254 00a4 1E4A     		ldr	r2, .L88+4
 1255 00a6 1360     		str	r3, [r2]
 1256 00a8 10E0     		b	.L83
 1257              	.L85:
 1258              		.loc 1 558 0 discriminator 9
 1259 00aa 1D4B     		ldr	r3, .L88+4
 1260 00ac 1B68     		ldr	r3, [r3]
 1261 00ae DA68     		ldr	r2, [r3, #12]
 1262 00b0 7B68     		ldr	r3, [r7, #4]
 1263 00b2 9A42     		cmp	r2, r3
 1264 00b4 05D1     		bne	.L84
 1265              		.loc 1 558 0 discriminator 5
 1266 00b6 1A4B     		ldr	r3, .L88+4
 1267 00b8 1B68     		ldr	r3, [r3]
 1268 00ba 7A68     		ldr	r2, [r7, #4]
 1269 00bc D268     		ldr	r2, [r2, #12]
 1270 00be DA60     		str	r2, [r3, #12]
 1271 00c0 08E0     		b	.L82
 1272              	.L84:
 1273              		.loc 1 558 0 discriminator 6
 1274 00c2 174B     		ldr	r3, .L88+4
 1275 00c4 1B68     		ldr	r3, [r3]
 1276 00c6 DB68     		ldr	r3, [r3, #12]
 1277 00c8 154A     		ldr	r2, .L88+4
 1278 00ca 1360     		str	r3, [r2]
 1279              	.L83:
 1280              		.loc 1 558 0 discriminator 8
 1281 00cc 144B     		ldr	r3, .L88+4
 1282 00ce 1B68     		ldr	r3, [r3]
 1283 00d0 002B     		cmp	r3, #0
 1284 00d2 EAD1     		bne	.L85
 1285              	.L82:
 1286              		.loc 1 558 0 discriminator 10
 1287 00d4 7B68     		ldr	r3, [r7, #4]
 1288 00d6 0022     		movs	r2, #0
 1289 00d8 DA60     		str	r2, [r3, #12]
 1290              	.L80:
 559:../lwip-1.4.1/src/core/tcp.c ****   }
 560:../lwip-1.4.1/src/core/tcp.c ****   memp_free(MEMP_TCP_PCB, pcb);
 1291              		.loc 1 560 0 is_stmt 1
 1292 00da 0220     		movs	r0, #2
 1293 00dc 7968     		ldr	r1, [r7, #4]
 1294 00de FFF7FEFF 		bl	memp_free
 561:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
 562:../lwip-1.4.1/src/core/tcp.c ****   lpcb->accept = tcp_accept_null;
 1295              		.loc 1 562 0
 1296 00e2 FB68     		ldr	r3, [r7, #12]
 1297 00e4 0F4A     		ldr	r2, .L88+8
 1298 00e6 5A61     		str	r2, [r3, #20]
 563:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 564:../lwip-1.4.1/src/core/tcp.c **** #if TCP_LISTEN_BACKLOG
 565:../lwip-1.4.1/src/core/tcp.c ****   lpcb->accepts_pending = 0;
 1299              		.loc 1 565 0
 1300 00e8 FB68     		ldr	r3, [r7, #12]
 1301 00ea 0022     		movs	r2, #0
 1302 00ec 5A77     		strb	r2, [r3, #29]
 566:../lwip-1.4.1/src/core/tcp.c ****   lpcb->backlog = (backlog ? backlog : 1);
 1303              		.loc 1 566 0
 1304 00ee FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1305 00f0 002B     		cmp	r3, #0
 1306 00f2 01D0     		beq	.L86
 1307              		.loc 1 566 0 is_stmt 0 discriminator 1
 1308 00f4 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1309 00f6 00E0     		b	.L87
 1310              	.L86:
 1311              		.loc 1 566 0 discriminator 2
 1312 00f8 0122     		movs	r2, #1
 1313              	.L87:
 1314              		.loc 1 566 0 discriminator 4
 1315 00fa FB68     		ldr	r3, [r7, #12]
 1316 00fc 1A77     		strb	r2, [r3, #28]
 567:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_LISTEN_BACKLOG */
 568:../lwip-1.4.1/src/core/tcp.c ****   TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 1317              		.loc 1 568 0 is_stmt 1 discriminator 4
 1318 00fe 0A4B     		ldr	r3, .L88+12
 1319 0100 1A68     		ldr	r2, [r3]
 1320 0102 FB68     		ldr	r3, [r7, #12]
 1321 0104 DA60     		str	r2, [r3, #12]
 1322 0106 084A     		ldr	r2, .L88+12
 1323 0108 FB68     		ldr	r3, [r7, #12]
 1324 010a 1360     		str	r3, [r2]
 1325 010c FFF7FEFF 		bl	tcp_timer_needed
 569:../lwip-1.4.1/src/core/tcp.c ****   return (struct tcp_pcb *)lpcb;
 1326              		.loc 1 569 0 discriminator 4
 1327 0110 FB68     		ldr	r3, [r7, #12]
 1328              	.L77:
 570:../lwip-1.4.1/src/core/tcp.c **** }
 1329              		.loc 1 570 0
 1330 0112 1846     		mov	r0, r3
 1331 0114 1037     		adds	r7, r7, #16
 1332              		.cfi_def_cfa_offset 8
 1333 0116 BD46     		mov	sp, r7
 1334              		.cfi_def_cfa_register 13
 1335              		@ sp needed
 1336 0118 80BD     		pop	{r7, pc}
 1337              	.L89:
 1338 011a 00BF     		.align	2
 1339              	.L88:
 1340 011c 00000000 		.word	tcp_bound_pcbs
 1341 0120 00000000 		.word	tcp_tmp_pcb
 1342 0124 00000000 		.word	tcp_accept_null
 1343 0128 00000000 		.word	tcp_listen_pcbs
 1344              		.cfi_endproc
 1345              	.LFE9:
 1347              		.section	.text.tcp_update_rcv_ann_wnd,"ax",%progbits
 1348              		.align	2
 1349              		.global	tcp_update_rcv_ann_wnd
 1350              		.thumb
 1351              		.thumb_func
 1353              	tcp_update_rcv_ann_wnd:
 1354              	.LFB10:
 571:../lwip-1.4.1/src/core/tcp.c **** 
 572:../lwip-1.4.1/src/core/tcp.c **** /** 
 573:../lwip-1.4.1/src/core/tcp.c ****  * Update the state that tracks the available window space to advertise.
 574:../lwip-1.4.1/src/core/tcp.c ****  *
 575:../lwip-1.4.1/src/core/tcp.c ****  * Returns how much extra window would be advertised if we sent an
 576:../lwip-1.4.1/src/core/tcp.c ****  * update now.
 577:../lwip-1.4.1/src/core/tcp.c ****  */
 578:../lwip-1.4.1/src/core/tcp.c **** u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
 579:../lwip-1.4.1/src/core/tcp.c **** {
 1355              		.loc 1 579 0
 1356              		.cfi_startproc
 1357              		@ args = 0, pretend = 0, frame = 16
 1358              		@ frame_needed = 1, uses_anonymous_args = 0
 1359              		@ link register save eliminated.
 1360 0000 80B4     		push	{r7}
 1361              		.cfi_def_cfa_offset 4
 1362              		.cfi_offset 7, -4
 1363 0002 85B0     		sub	sp, sp, #20
 1364              		.cfi_def_cfa_offset 24
 1365 0004 00AF     		add	r7, sp, #0
 1366              		.cfi_def_cfa_register 7
 1367 0006 7860     		str	r0, [r7, #4]
 580:../lwip-1.4.1/src/core/tcp.c ****   u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 1368              		.loc 1 580 0
 1369 0008 7B68     		ldr	r3, [r7, #4]
 1370 000a 9B6A     		ldr	r3, [r3, #40]
 1371 000c 7A68     		ldr	r2, [r7, #4]
 1372 000e 928D     		ldrh	r2, [r2, #44]
 1373 0010 1344     		add	r3, r3, r2
 1374 0012 FB60     		str	r3, [r7, #12]
 581:../lwip-1.4.1/src/core/tcp.c **** 
 582:../lwip-1.4.1/src/core/tcp.c ****   if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 1375              		.loc 1 582 0
 1376 0014 7B68     		ldr	r3, [r7, #4]
 1377 0016 1B6B     		ldr	r3, [r3, #48]
 1378 0018 7A68     		ldr	r2, [r7, #4]
 1379 001a D28E     		ldrh	r2, [r2, #54]
 1380 001c 40F2B451 		movw	r1, #1460
 1381 0020 8A42     		cmp	r2, r1
 1382 0022 02D8     		bhi	.L91
 1383              		.loc 1 582 0 is_stmt 0 discriminator 1
 1384 0024 7A68     		ldr	r2, [r7, #4]
 1385 0026 D28E     		ldrh	r2, [r2, #54]
 1386 0028 01E0     		b	.L92
 1387              	.L91:
 1388              		.loc 1 582 0 discriminator 2
 1389 002a 40F2B452 		movw	r2, #1460
 1390              	.L92:
 1391              		.loc 1 582 0 discriminator 4
 1392 002e 1344     		add	r3, r3, r2
 1393 0030 FA68     		ldr	r2, [r7, #12]
 1394 0032 D31A     		subs	r3, r2, r3
 1395 0034 002B     		cmp	r3, #0
 1396 0036 08DB     		blt	.L93
 583:../lwip-1.4.1/src/core/tcp.c ****     /* we can advertise more window */
 584:../lwip-1.4.1/src/core/tcp.c ****     pcb->rcv_ann_wnd = pcb->rcv_wnd;
 1397              		.loc 1 584 0 is_stmt 1
 1398 0038 7B68     		ldr	r3, [r7, #4]
 1399 003a 9A8D     		ldrh	r2, [r3, #44]
 1400 003c 7B68     		ldr	r3, [r7, #4]
 1401 003e DA85     		strh	r2, [r3, #46]	@ movhi
 585:../lwip-1.4.1/src/core/tcp.c ****     return new_right_edge - pcb->rcv_ann_right_edge;
 1402              		.loc 1 585 0
 1403 0040 7B68     		ldr	r3, [r7, #4]
 1404 0042 1B6B     		ldr	r3, [r3, #48]
 1405 0044 FA68     		ldr	r2, [r7, #12]
 1406 0046 D31A     		subs	r3, r2, r3
 1407 0048 15E0     		b	.L94
 1408              	.L93:
 586:../lwip-1.4.1/src/core/tcp.c ****   } else {
 587:../lwip-1.4.1/src/core/tcp.c ****     if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 1409              		.loc 1 587 0
 1410 004a 7B68     		ldr	r3, [r7, #4]
 1411 004c 9A6A     		ldr	r2, [r3, #40]
 1412 004e 7B68     		ldr	r3, [r7, #4]
 1413 0050 1B6B     		ldr	r3, [r3, #48]
 1414 0052 D31A     		subs	r3, r2, r3
 1415 0054 002B     		cmp	r3, #0
 1416 0056 03DD     		ble	.L95
 588:../lwip-1.4.1/src/core/tcp.c ****       /* Can happen due to other end sending out of advertised window,
 589:../lwip-1.4.1/src/core/tcp.c ****        * but within actual available (but not yet advertised) window */
 590:../lwip-1.4.1/src/core/tcp.c ****       pcb->rcv_ann_wnd = 0;
 1417              		.loc 1 590 0
 1418 0058 7B68     		ldr	r3, [r7, #4]
 1419 005a 0022     		movs	r2, #0
 1420 005c DA85     		strh	r2, [r3, #46]	@ movhi
 1421 005e 09E0     		b	.L96
 1422              	.L95:
 1423              	.LBB2:
 591:../lwip-1.4.1/src/core/tcp.c ****     } else {
 592:../lwip-1.4.1/src/core/tcp.c ****       /* keep the right edge of window constant */
 593:../lwip-1.4.1/src/core/tcp.c ****       u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 1424              		.loc 1 593 0
 1425 0060 7B68     		ldr	r3, [r7, #4]
 1426 0062 1A6B     		ldr	r2, [r3, #48]
 1427 0064 7B68     		ldr	r3, [r7, #4]
 1428 0066 9B6A     		ldr	r3, [r3, #40]
 1429 0068 D31A     		subs	r3, r2, r3
 1430 006a BB60     		str	r3, [r7, #8]
 594:../lwip-1.4.1/src/core/tcp.c ****       LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 595:../lwip-1.4.1/src/core/tcp.c ****       pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 1431              		.loc 1 595 0
 1432 006c BB68     		ldr	r3, [r7, #8]
 1433 006e 9AB2     		uxth	r2, r3
 1434 0070 7B68     		ldr	r3, [r7, #4]
 1435 0072 DA85     		strh	r2, [r3, #46]	@ movhi
 1436              	.L96:
 1437              	.LBE2:
 596:../lwip-1.4.1/src/core/tcp.c ****     }
 597:../lwip-1.4.1/src/core/tcp.c ****     return 0;
 1438              		.loc 1 597 0
 1439 0074 0023     		movs	r3, #0
 1440              	.L94:
 598:../lwip-1.4.1/src/core/tcp.c ****   }
 599:../lwip-1.4.1/src/core/tcp.c **** }
 1441              		.loc 1 599 0
 1442 0076 1846     		mov	r0, r3
 1443 0078 1437     		adds	r7, r7, #20
 1444              		.cfi_def_cfa_offset 4
 1445 007a BD46     		mov	sp, r7
 1446              		.cfi_def_cfa_register 13
 1447              		@ sp needed
 1448 007c 5DF8047B 		ldr	r7, [sp], #4
 1449              		.cfi_restore 7
 1450              		.cfi_def_cfa_offset 0
 1451 0080 7047     		bx	lr
 1452              		.cfi_endproc
 1453              	.LFE10:
 1455 0082 00BF     		.section	.text.tcp_recved,"ax",%progbits
 1456              		.align	2
 1457              		.global	tcp_recved
 1458              		.thumb
 1459              		.thumb_func
 1461              	tcp_recved:
 1462              	.LFB11:
 600:../lwip-1.4.1/src/core/tcp.c **** 
 601:../lwip-1.4.1/src/core/tcp.c **** /**
 602:../lwip-1.4.1/src/core/tcp.c ****  * This function should be called by the application when it has
 603:../lwip-1.4.1/src/core/tcp.c ****  * processed the data. The purpose is to advertise a larger window
 604:../lwip-1.4.1/src/core/tcp.c ****  * when the data has been processed.
 605:../lwip-1.4.1/src/core/tcp.c ****  *
 606:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp_pcb for which data is read
 607:../lwip-1.4.1/src/core/tcp.c ****  * @param len the amount of bytes that have been read by the application
 608:../lwip-1.4.1/src/core/tcp.c ****  */
 609:../lwip-1.4.1/src/core/tcp.c **** void
 610:../lwip-1.4.1/src/core/tcp.c **** tcp_recved(struct tcp_pcb *pcb, u16_t len)
 611:../lwip-1.4.1/src/core/tcp.c **** {
 1463              		.loc 1 611 0
 1464              		.cfi_startproc
 1465              		@ args = 0, pretend = 0, frame = 16
 1466              		@ frame_needed = 1, uses_anonymous_args = 0
 1467 0000 80B5     		push	{r7, lr}
 1468              		.cfi_def_cfa_offset 8
 1469              		.cfi_offset 7, -8
 1470              		.cfi_offset 14, -4
 1471 0002 84B0     		sub	sp, sp, #16
 1472              		.cfi_def_cfa_offset 24
 1473 0004 00AF     		add	r7, sp, #0
 1474              		.cfi_def_cfa_register 7
 1475 0006 7860     		str	r0, [r7, #4]
 1476 0008 0B46     		mov	r3, r1
 1477 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 612:../lwip-1.4.1/src/core/tcp.c ****   int wnd_inflation;
 613:../lwip-1.4.1/src/core/tcp.c **** 
 614:../lwip-1.4.1/src/core/tcp.c ****   /* pcb->state LISTEN not allowed here */
 615:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 616:../lwip-1.4.1/src/core/tcp.c ****     pcb->state != LISTEN);
 617:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
 618:../lwip-1.4.1/src/core/tcp.c ****               len <= 0xffff - pcb->rcv_wnd );
 619:../lwip-1.4.1/src/core/tcp.c **** 
 620:../lwip-1.4.1/src/core/tcp.c ****   pcb->rcv_wnd += len;
 1478              		.loc 1 620 0
 1479 000c 7B68     		ldr	r3, [r7, #4]
 1480 000e 9A8D     		ldrh	r2, [r3, #44]
 1481 0010 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1482 0012 1344     		add	r3, r3, r2
 1483 0014 9AB2     		uxth	r2, r3
 1484 0016 7B68     		ldr	r3, [r7, #4]
 1485 0018 9A85     		strh	r2, [r3, #44]	@ movhi
 621:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->rcv_wnd > TCP_WND) {
 1486              		.loc 1 621 0
 1487 001a 7B68     		ldr	r3, [r7, #4]
 1488 001c 9B8D     		ldrh	r3, [r3, #44]
 1489 001e 40F66832 		movw	r2, #2920
 1490 0022 9342     		cmp	r3, r2
 1491 0024 03D9     		bls	.L98
 622:../lwip-1.4.1/src/core/tcp.c ****     pcb->rcv_wnd = TCP_WND;
 1492              		.loc 1 622 0
 1493 0026 7B68     		ldr	r3, [r7, #4]
 1494 0028 40F66832 		movw	r2, #2920
 1495 002c 9A85     		strh	r2, [r3, #44]	@ movhi
 1496              	.L98:
 623:../lwip-1.4.1/src/core/tcp.c ****   }
 624:../lwip-1.4.1/src/core/tcp.c **** 
 625:../lwip-1.4.1/src/core/tcp.c ****   wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 1497              		.loc 1 625 0
 1498 002e 7868     		ldr	r0, [r7, #4]
 1499 0030 FFF7FEFF 		bl	tcp_update_rcv_ann_wnd
 1500 0034 0346     		mov	r3, r0
 1501 0036 FB60     		str	r3, [r7, #12]
 626:../lwip-1.4.1/src/core/tcp.c **** 
 627:../lwip-1.4.1/src/core/tcp.c ****   /* If the change in the right edge of window is significant (default
 628:../lwip-1.4.1/src/core/tcp.c ****    * watermark is TCP_WND/4), then send an explicit update now.
 629:../lwip-1.4.1/src/core/tcp.c ****    * Otherwise wait for a packet to be sent in the normal course of
 630:../lwip-1.4.1/src/core/tcp.c ****    * events (or more window to be available later) */
 631:../lwip-1.4.1/src/core/tcp.c ****   if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 1502              		.loc 1 631 0
 1503 0038 FB68     		ldr	r3, [r7, #12]
 1504 003a 40F2D922 		movw	r2, #729
 1505 003e 9342     		cmp	r3, r2
 1506 0040 09DD     		ble	.L97
 632:../lwip-1.4.1/src/core/tcp.c ****     tcp_ack_now(pcb);
 1507              		.loc 1 632 0
 1508 0042 7B68     		ldr	r3, [r7, #4]
 1509 0044 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1510 0046 43F00203 		orr	r3, r3, #2
 1511 004a DAB2     		uxtb	r2, r3
 1512 004c 7B68     		ldr	r3, [r7, #4]
 1513 004e 9A77     		strb	r2, [r3, #30]
 633:../lwip-1.4.1/src/core/tcp.c ****     tcp_output(pcb);
 1514              		.loc 1 633 0
 1515 0050 7868     		ldr	r0, [r7, #4]
 1516 0052 FFF7FEFF 		bl	tcp_output
 1517              	.L97:
 634:../lwip-1.4.1/src/core/tcp.c ****   }
 635:../lwip-1.4.1/src/core/tcp.c **** 
 636:../lwip-1.4.1/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
 637:../lwip-1.4.1/src/core/tcp.c ****          len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
 638:../lwip-1.4.1/src/core/tcp.c **** }
 1518              		.loc 1 638 0
 1519 0056 1037     		adds	r7, r7, #16
 1520              		.cfi_def_cfa_offset 8
 1521 0058 BD46     		mov	sp, r7
 1522              		.cfi_def_cfa_register 13
 1523              		@ sp needed
 1524 005a 80BD     		pop	{r7, pc}
 1525              		.cfi_endproc
 1526              	.LFE11:
 1528              		.section	.text.tcp_new_port,"ax",%progbits
 1529              		.align	2
 1530              		.thumb
 1531              		.thumb_func
 1533              	tcp_new_port:
 1534              	.LFB12:
 639:../lwip-1.4.1/src/core/tcp.c **** 
 640:../lwip-1.4.1/src/core/tcp.c **** /**
 641:../lwip-1.4.1/src/core/tcp.c ****  * Allocate a new local TCP port.
 642:../lwip-1.4.1/src/core/tcp.c ****  *
 643:../lwip-1.4.1/src/core/tcp.c ****  * @return a new (free) local TCP port number
 644:../lwip-1.4.1/src/core/tcp.c ****  */
 645:../lwip-1.4.1/src/core/tcp.c **** static u16_t
 646:../lwip-1.4.1/src/core/tcp.c **** tcp_new_port(void)
 647:../lwip-1.4.1/src/core/tcp.c **** {
 1535              		.loc 1 647 0
 1536              		.cfi_startproc
 1537              		@ args = 0, pretend = 0, frame = 8
 1538              		@ frame_needed = 1, uses_anonymous_args = 0
 1539              		@ link register save eliminated.
 1540 0000 80B4     		push	{r7}
 1541              		.cfi_def_cfa_offset 4
 1542              		.cfi_offset 7, -4
 1543 0002 83B0     		sub	sp, sp, #12
 1544              		.cfi_def_cfa_offset 16
 1545 0004 00AF     		add	r7, sp, #0
 1546              		.cfi_def_cfa_register 7
 648:../lwip-1.4.1/src/core/tcp.c ****   u8_t i;
 649:../lwip-1.4.1/src/core/tcp.c ****   u16_t n = 0;
 1547              		.loc 1 649 0
 1548 0006 0023     		movs	r3, #0
 1549 0008 BB80     		strh	r3, [r7, #4]	@ movhi
 1550              	.L101:
 650:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb *pcb;
 651:../lwip-1.4.1/src/core/tcp.c ****   
 652:../lwip-1.4.1/src/core/tcp.c **** again:
 653:../lwip-1.4.1/src/core/tcp.c ****   if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 1551              		.loc 1 653 0
 1552 000a 1E4B     		ldr	r3, .L110
 1553 000c 1B88     		ldrh	r3, [r3]
 1554 000e 5A1C     		adds	r2, r3, #1
 1555 0010 91B2     		uxth	r1, r2
 1556 0012 1C4A     		ldr	r2, .L110
 1557 0014 1180     		strh	r1, [r2]	@ movhi
 1558 0016 4FF6FF72 		movw	r2, #65535
 1559 001a 9342     		cmp	r3, r2
 1560 001c 03D1     		bne	.L102
 654:../lwip-1.4.1/src/core/tcp.c ****     tcp_port = TCP_LOCAL_PORT_RANGE_START;
 1561              		.loc 1 654 0
 1562 001e 194B     		ldr	r3, .L110
 1563 0020 4FF44042 		mov	r2, #49152
 1564 0024 1A80     		strh	r2, [r3]	@ movhi
 1565              	.L102:
 655:../lwip-1.4.1/src/core/tcp.c ****   }
 656:../lwip-1.4.1/src/core/tcp.c ****   /* Check all PCB lists. */
 657:../lwip-1.4.1/src/core/tcp.c ****   for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 1566              		.loc 1 657 0
 1567 0026 0023     		movs	r3, #0
 1568 0028 FB71     		strb	r3, [r7, #7]
 1569 002a 1FE0     		b	.L103
 1570              	.L109:
 658:../lwip-1.4.1/src/core/tcp.c ****     for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 1571              		.loc 1 658 0
 1572 002c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1573 002e 164A     		ldr	r2, .L110+4
 1574 0030 52F82330 		ldr	r3, [r2, r3, lsl #2]
 1575 0034 1B68     		ldr	r3, [r3]
 1576 0036 3B60     		str	r3, [r7]
 1577 0038 12E0     		b	.L104
 1578              	.L108:
 659:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->local_port == tcp_port) {
 1579              		.loc 1 659 0
 1580 003a 3B68     		ldr	r3, [r7]
 1581 003c 5A8B     		ldrh	r2, [r3, #26]
 1582 003e 114B     		ldr	r3, .L110
 1583 0040 1B88     		ldrh	r3, [r3]
 1584 0042 9A42     		cmp	r2, r3
 1585 0044 09D1     		bne	.L105
 660:../lwip-1.4.1/src/core/tcp.c ****         if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 1586              		.loc 1 660 0
 1587 0046 BB88     		ldrh	r3, [r7, #4]	@ movhi
 1588 0048 0133     		adds	r3, r3, #1
 1589 004a BB80     		strh	r3, [r7, #4]	@ movhi
 1590 004c BB88     		ldrh	r3, [r7, #4]
 1591 004e B3F5804F 		cmp	r3, #16384
 1592 0052 01D3     		bcc	.L106
 661:../lwip-1.4.1/src/core/tcp.c ****           return 0;
 1593              		.loc 1 661 0
 1594 0054 0023     		movs	r3, #0
 1595 0056 0EE0     		b	.L107
 1596              	.L106:
 662:../lwip-1.4.1/src/core/tcp.c ****         }
 663:../lwip-1.4.1/src/core/tcp.c ****         goto again;
 1597              		.loc 1 663 0
 1598 0058 D7E7     		b	.L101
 1599              	.L105:
 658:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->local_port == tcp_port) {
 1600              		.loc 1 658 0 discriminator 2
 1601 005a 3B68     		ldr	r3, [r7]
 1602 005c DB68     		ldr	r3, [r3, #12]
 1603 005e 3B60     		str	r3, [r7]
 1604              	.L104:
 658:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->local_port == tcp_port) {
 1605              		.loc 1 658 0 is_stmt 0 discriminator 1
 1606 0060 3B68     		ldr	r3, [r7]
 1607 0062 002B     		cmp	r3, #0
 1608 0064 E9D1     		bne	.L108
 657:../lwip-1.4.1/src/core/tcp.c ****     for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 1609              		.loc 1 657 0 is_stmt 1 discriminator 2
 1610 0066 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1611 0068 0133     		adds	r3, r3, #1
 1612 006a FB71     		strb	r3, [r7, #7]
 1613              	.L103:
 657:../lwip-1.4.1/src/core/tcp.c ****     for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 1614              		.loc 1 657 0 is_stmt 0 discriminator 1
 1615 006c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1616 006e 032B     		cmp	r3, #3
 1617 0070 DCD9     		bls	.L109
 664:../lwip-1.4.1/src/core/tcp.c ****       }
 665:../lwip-1.4.1/src/core/tcp.c ****     }
 666:../lwip-1.4.1/src/core/tcp.c ****   }
 667:../lwip-1.4.1/src/core/tcp.c ****   return tcp_port;
 1618              		.loc 1 667 0 is_stmt 1
 1619 0072 044B     		ldr	r3, .L110
 1620 0074 1B88     		ldrh	r3, [r3]
 1621              	.L107:
 668:../lwip-1.4.1/src/core/tcp.c **** }
 1622              		.loc 1 668 0
 1623 0076 1846     		mov	r0, r3
 1624 0078 0C37     		adds	r7, r7, #12
 1625              		.cfi_def_cfa_offset 4
 1626 007a BD46     		mov	sp, r7
 1627              		.cfi_def_cfa_register 13
 1628              		@ sp needed
 1629 007c 5DF8047B 		ldr	r7, [sp], #4
 1630              		.cfi_restore 7
 1631              		.cfi_def_cfa_offset 0
 1632 0080 7047     		bx	lr
 1633              	.L111:
 1634 0082 00BF     		.align	2
 1635              	.L110:
 1636 0084 00000000 		.word	tcp_port
 1637 0088 00000000 		.word	tcp_pcb_lists
 1638              		.cfi_endproc
 1639              	.LFE12:
 1641              		.section	.text.tcp_connect,"ax",%progbits
 1642              		.align	2
 1643              		.global	tcp_connect
 1644              		.thumb
 1645              		.thumb_func
 1647              	tcp_connect:
 1648              	.LFB13:
 669:../lwip-1.4.1/src/core/tcp.c **** 
 670:../lwip-1.4.1/src/core/tcp.c **** /**
 671:../lwip-1.4.1/src/core/tcp.c ****  * Connects to another host. The function given as the "connected"
 672:../lwip-1.4.1/src/core/tcp.c ****  * argument will be called when the connection has been established.
 673:../lwip-1.4.1/src/core/tcp.c ****  *
 674:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp_pcb used to establish the connection
 675:../lwip-1.4.1/src/core/tcp.c ****  * @param ipaddr the remote ip address to connect to
 676:../lwip-1.4.1/src/core/tcp.c ****  * @param port the remote tcp port to connect to
 677:../lwip-1.4.1/src/core/tcp.c ****  * @param connected callback function to call when connected (or on error)
 678:../lwip-1.4.1/src/core/tcp.c ****  * @return ERR_VAL if invalid arguments are given
 679:../lwip-1.4.1/src/core/tcp.c ****  *         ERR_OK if connect request has been sent
 680:../lwip-1.4.1/src/core/tcp.c ****  *         other err_t values if connect request couldn't be sent
 681:../lwip-1.4.1/src/core/tcp.c ****  */
 682:../lwip-1.4.1/src/core/tcp.c **** err_t
 683:../lwip-1.4.1/src/core/tcp.c **** tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
 684:../lwip-1.4.1/src/core/tcp.c ****       tcp_connected_fn connected)
 685:../lwip-1.4.1/src/core/tcp.c **** {
 1649              		.loc 1 685 0
 1650              		.cfi_startproc
 1651              		@ args = 0, pretend = 0, frame = 32
 1652              		@ frame_needed = 1, uses_anonymous_args = 0
 1653 0000 80B5     		push	{r7, lr}
 1654              		.cfi_def_cfa_offset 8
 1655              		.cfi_offset 7, -8
 1656              		.cfi_offset 14, -4
 1657 0002 88B0     		sub	sp, sp, #32
 1658              		.cfi_def_cfa_offset 40
 1659 0004 00AF     		add	r7, sp, #0
 1660              		.cfi_def_cfa_register 7
 1661 0006 F860     		str	r0, [r7, #12]
 1662 0008 B960     		str	r1, [r7, #8]
 1663 000a 3B60     		str	r3, [r7]
 1664 000c 1346     		mov	r3, r2	@ movhi
 1665 000e FB80     		strh	r3, [r7, #6]	@ movhi
 686:../lwip-1.4.1/src/core/tcp.c ****   err_t ret;
 687:../lwip-1.4.1/src/core/tcp.c ****   u32_t iss;
 688:../lwip-1.4.1/src/core/tcp.c ****   u16_t old_local_port;
 689:../lwip-1.4.1/src/core/tcp.c **** 
 690:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_IS
 1666              		.loc 1 690 0
 1667 0010 FB68     		ldr	r3, [r7, #12]
 1668 0012 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 1669 0014 002B     		cmp	r3, #0
 1670 0016 01D0     		beq	.L113
 1671              		.loc 1 690 0 is_stmt 0 discriminator 1
 1672 0018 F723     		movs	r3, #247
 1673 001a BFE0     		b	.L114
 1674              	.L113:
 691:../lwip-1.4.1/src/core/tcp.c **** 
 692:../lwip-1.4.1/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
 693:../lwip-1.4.1/src/core/tcp.c ****   if (ipaddr != NULL) {
 1675              		.loc 1 693 0 is_stmt 1
 1676 001c BB68     		ldr	r3, [r7, #8]
 1677 001e 002B     		cmp	r3, #0
 1678 0020 0AD0     		beq	.L115
 694:../lwip-1.4.1/src/core/tcp.c ****     pcb->remote_ip = *ipaddr;
 1679              		.loc 1 694 0
 1680 0022 FB68     		ldr	r3, [r7, #12]
 1681 0024 BA68     		ldr	r2, [r7, #8]
 1682 0026 1268     		ldr	r2, [r2]
 1683 0028 5A60     		str	r2, [r3, #4]
 695:../lwip-1.4.1/src/core/tcp.c ****   } else {
 696:../lwip-1.4.1/src/core/tcp.c ****     return ERR_VAL;
 697:../lwip-1.4.1/src/core/tcp.c ****   }
 698:../lwip-1.4.1/src/core/tcp.c ****   pcb->remote_port = port;
 1684              		.loc 1 698 0
 1685 002a FB68     		ldr	r3, [r7, #12]
 1686 002c FA88     		ldrh	r2, [r7, #6]	@ movhi
 1687 002e 9A83     		strh	r2, [r3, #28]	@ movhi
 699:../lwip-1.4.1/src/core/tcp.c **** 
 700:../lwip-1.4.1/src/core/tcp.c ****   /* check if we have a route to the remote host */
 701:../lwip-1.4.1/src/core/tcp.c ****   if (ip_addr_isany(&(pcb->local_ip))) {
 1688              		.loc 1 701 0
 1689 0030 FB68     		ldr	r3, [r7, #12]
 1690 0032 002B     		cmp	r3, #0
 1691 0034 06D0     		beq	.L117
 1692 0036 01E0     		b	.L128
 1693              	.L115:
 696:../lwip-1.4.1/src/core/tcp.c ****   }
 1694              		.loc 1 696 0
 1695 0038 FA23     		movs	r3, #250
 1696 003a AFE0     		b	.L114
 1697              	.L128:
 1698              		.loc 1 701 0 discriminator 1
 1699 003c FB68     		ldr	r3, [r7, #12]
 1700 003e 1B68     		ldr	r3, [r3]
 1701 0040 002B     		cmp	r3, #0
 1702 0042 0ED1     		bne	.L118
 1703              	.L117:
 1704              	.LBB3:
 702:../lwip-1.4.1/src/core/tcp.c ****     /* no local IP address set, yet. */
 703:../lwip-1.4.1/src/core/tcp.c ****     struct netif *netif = ip_route(&(pcb->remote_ip));
 1705              		.loc 1 703 0
 1706 0044 FB68     		ldr	r3, [r7, #12]
 1707 0046 0433     		adds	r3, r3, #4
 1708 0048 1846     		mov	r0, r3
 1709 004a FFF7FEFF 		bl	ip_route
 1710 004e F861     		str	r0, [r7, #28]
 704:../lwip-1.4.1/src/core/tcp.c ****     if (netif == NULL) {
 1711              		.loc 1 704 0
 1712 0050 FB69     		ldr	r3, [r7, #28]
 1713 0052 002B     		cmp	r3, #0
 1714 0054 01D1     		bne	.L119
 705:../lwip-1.4.1/src/core/tcp.c ****       /* Don't even try to send a SYN packet if we have no route
 706:../lwip-1.4.1/src/core/tcp.c ****          since that will fail. */
 707:../lwip-1.4.1/src/core/tcp.c ****       return ERR_RTE;
 1715              		.loc 1 707 0
 1716 0056 FC23     		movs	r3, #252
 1717 0058 A0E0     		b	.L114
 1718              	.L119:
 708:../lwip-1.4.1/src/core/tcp.c ****     }
 709:../lwip-1.4.1/src/core/tcp.c ****     /* Use the netif's IP address as local address. */
 710:../lwip-1.4.1/src/core/tcp.c ****     ip_addr_copy(pcb->local_ip, netif->ip_addr);
 1719              		.loc 1 710 0
 1720 005a FB69     		ldr	r3, [r7, #28]
 1721 005c 5A68     		ldr	r2, [r3, #4]
 1722 005e FB68     		ldr	r3, [r7, #12]
 1723 0060 1A60     		str	r2, [r3]
 1724              	.L118:
 1725              	.LBE3:
 711:../lwip-1.4.1/src/core/tcp.c ****   }
 712:../lwip-1.4.1/src/core/tcp.c **** 
 713:../lwip-1.4.1/src/core/tcp.c ****   old_local_port = pcb->local_port;
 1726              		.loc 1 713 0
 1727 0062 FB68     		ldr	r3, [r7, #12]
 1728 0064 5B8B     		ldrh	r3, [r3, #26]	@ movhi
 1729 0066 7B83     		strh	r3, [r7, #26]	@ movhi
 714:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->local_port == 0) {
 1730              		.loc 1 714 0
 1731 0068 FB68     		ldr	r3, [r7, #12]
 1732 006a 5B8B     		ldrh	r3, [r3, #26]
 1733 006c 002B     		cmp	r3, #0
 1734 006e 0BD1     		bne	.L120
 715:../lwip-1.4.1/src/core/tcp.c ****     pcb->local_port = tcp_new_port();
 1735              		.loc 1 715 0
 1736 0070 FFF7FEFF 		bl	tcp_new_port
 1737 0074 0346     		mov	r3, r0
 1738 0076 1A46     		mov	r2, r3
 1739 0078 FB68     		ldr	r3, [r7, #12]
 1740 007a 5A83     		strh	r2, [r3, #26]	@ movhi
 716:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->local_port == 0) {
 1741              		.loc 1 716 0
 1742 007c FB68     		ldr	r3, [r7, #12]
 1743 007e 5B8B     		ldrh	r3, [r3, #26]
 1744 0080 002B     		cmp	r3, #0
 1745 0082 01D1     		bne	.L120
 717:../lwip-1.4.1/src/core/tcp.c ****       return ERR_BUF;
 1746              		.loc 1 717 0
 1747 0084 FE23     		movs	r3, #254
 1748 0086 89E0     		b	.L114
 1749              	.L120:
 718:../lwip-1.4.1/src/core/tcp.c ****     }
 719:../lwip-1.4.1/src/core/tcp.c ****   }
 720:../lwip-1.4.1/src/core/tcp.c **** #if SO_REUSE
 721:../lwip-1.4.1/src/core/tcp.c ****   if (ip_get_option(pcb, SOF_REUSEADDR)) {
 722:../lwip-1.4.1/src/core/tcp.c ****     /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
 723:../lwip-1.4.1/src/core/tcp.c ****        now that the 5-tuple is unique. */
 724:../lwip-1.4.1/src/core/tcp.c ****     struct tcp_pcb *cpcb;
 725:../lwip-1.4.1/src/core/tcp.c ****     int i;
 726:../lwip-1.4.1/src/core/tcp.c ****     /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
 727:../lwip-1.4.1/src/core/tcp.c ****     for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 728:../lwip-1.4.1/src/core/tcp.c ****       for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 729:../lwip-1.4.1/src/core/tcp.c ****         if ((cpcb->local_port == pcb->local_port) &&
 730:../lwip-1.4.1/src/core/tcp.c ****             (cpcb->remote_port == port) &&
 731:../lwip-1.4.1/src/core/tcp.c ****             ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 732:../lwip-1.4.1/src/core/tcp.c ****             ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 733:../lwip-1.4.1/src/core/tcp.c ****           /* linux returns EISCONN here, but ERR_USE should be OK for us */
 734:../lwip-1.4.1/src/core/tcp.c ****           return ERR_USE;
 735:../lwip-1.4.1/src/core/tcp.c ****         }
 736:../lwip-1.4.1/src/core/tcp.c ****       }
 737:../lwip-1.4.1/src/core/tcp.c ****     }
 738:../lwip-1.4.1/src/core/tcp.c ****   }
 739:../lwip-1.4.1/src/core/tcp.c **** #endif /* SO_REUSE */
 740:../lwip-1.4.1/src/core/tcp.c ****   iss = tcp_next_iss();
 1750              		.loc 1 740 0
 1751 0088 FFF7FEFF 		bl	tcp_next_iss
 1752 008c 7861     		str	r0, [r7, #20]
 741:../lwip-1.4.1/src/core/tcp.c ****   pcb->rcv_nxt = 0;
 1753              		.loc 1 741 0
 1754 008e FB68     		ldr	r3, [r7, #12]
 1755 0090 0022     		movs	r2, #0
 1756 0092 9A62     		str	r2, [r3, #40]
 742:../lwip-1.4.1/src/core/tcp.c ****   pcb->snd_nxt = iss;
 1757              		.loc 1 742 0
 1758 0094 FB68     		ldr	r3, [r7, #12]
 1759 0096 7A69     		ldr	r2, [r7, #20]
 1760 0098 1A65     		str	r2, [r3, #80]
 743:../lwip-1.4.1/src/core/tcp.c ****   pcb->lastack = iss - 1;
 1761              		.loc 1 743 0
 1762 009a 7B69     		ldr	r3, [r7, #20]
 1763 009c 5A1E     		subs	r2, r3, #1
 1764 009e FB68     		ldr	r3, [r7, #12]
 1765 00a0 9A64     		str	r2, [r3, #72]
 744:../lwip-1.4.1/src/core/tcp.c ****   pcb->snd_lbb = iss - 1;
 1766              		.loc 1 744 0
 1767 00a2 7B69     		ldr	r3, [r7, #20]
 1768 00a4 5A1E     		subs	r2, r3, #1
 1769 00a6 FB68     		ldr	r3, [r7, #12]
 1770 00a8 DA65     		str	r2, [r3, #92]
 745:../lwip-1.4.1/src/core/tcp.c ****   pcb->rcv_wnd = TCP_WND;
 1771              		.loc 1 745 0
 1772 00aa FB68     		ldr	r3, [r7, #12]
 1773 00ac 40F66832 		movw	r2, #2920
 1774 00b0 9A85     		strh	r2, [r3, #44]	@ movhi
 746:../lwip-1.4.1/src/core/tcp.c ****   pcb->rcv_ann_wnd = TCP_WND;
 1775              		.loc 1 746 0
 1776 00b2 FB68     		ldr	r3, [r7, #12]
 1777 00b4 40F66832 		movw	r2, #2920
 1778 00b8 DA85     		strh	r2, [r3, #46]	@ movhi
 747:../lwip-1.4.1/src/core/tcp.c ****   pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 1779              		.loc 1 747 0
 1780 00ba FB68     		ldr	r3, [r7, #12]
 1781 00bc 9A6A     		ldr	r2, [r3, #40]
 1782 00be FB68     		ldr	r3, [r7, #12]
 1783 00c0 1A63     		str	r2, [r3, #48]
 748:../lwip-1.4.1/src/core/tcp.c ****   pcb->snd_wnd = TCP_WND;
 1784              		.loc 1 748 0
 1785 00c2 FB68     		ldr	r3, [r7, #12]
 1786 00c4 40F66832 		movw	r2, #2920
 1787 00c8 A3F86020 		strh	r2, [r3, #96]	@ movhi
 749:../lwip-1.4.1/src/core/tcp.c ****   /* As initial send MSS, we use TCP_MSS but limit it to 536.
 750:../lwip-1.4.1/src/core/tcp.c ****      The send MSS is updated when an MSS option is received. */
 751:../lwip-1.4.1/src/core/tcp.c ****   pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 1788              		.loc 1 751 0
 1789 00cc FB68     		ldr	r3, [r7, #12]
 1790 00ce 4FF40672 		mov	r2, #536
 1791 00d2 DA86     		strh	r2, [r3, #54]	@ movhi
 752:../lwip-1.4.1/src/core/tcp.c **** #if TCP_CALCULATE_EFF_SEND_MSS
 753:../lwip-1.4.1/src/core/tcp.c ****   pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
 1792              		.loc 1 753 0
 1793 00d4 FB68     		ldr	r3, [r7, #12]
 1794 00d6 DB8E     		ldrh	r3, [r3, #54]
 1795 00d8 1846     		mov	r0, r3
 1796 00da B968     		ldr	r1, [r7, #8]
 1797 00dc FFF7FEFF 		bl	tcp_eff_send_mss
 1798 00e0 0346     		mov	r3, r0
 1799 00e2 1A46     		mov	r2, r3
 1800 00e4 FB68     		ldr	r3, [r7, #12]
 1801 00e6 DA86     		strh	r2, [r3, #54]	@ movhi
 754:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 755:../lwip-1.4.1/src/core/tcp.c ****   pcb->cwnd = 1;
 1802              		.loc 1 755 0
 1803 00e8 FB68     		ldr	r3, [r7, #12]
 1804 00ea 0122     		movs	r2, #1
 1805 00ec A3F84C20 		strh	r2, [r3, #76]	@ movhi
 756:../lwip-1.4.1/src/core/tcp.c ****   pcb->ssthresh = pcb->mss * 10;
 1806              		.loc 1 756 0
 1807 00f0 FB68     		ldr	r3, [r7, #12]
 1808 00f2 DB8E     		ldrh	r3, [r3, #54]
 1809 00f4 1A46     		mov	r2, r3	@ movhi
 1810 00f6 9200     		lsls	r2, r2, #2
 1811 00f8 1344     		add	r3, r3, r2
 1812 00fa 5B00     		lsls	r3, r3, #1
 1813 00fc 9AB2     		uxth	r2, r3
 1814 00fe FB68     		ldr	r3, [r7, #12]
 1815 0100 A3F84E20 		strh	r2, [r3, #78]	@ movhi
 757:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
 758:../lwip-1.4.1/src/core/tcp.c ****   pcb->connected = connected;
 1816              		.loc 1 758 0
 1817 0104 FB68     		ldr	r3, [r7, #12]
 1818 0106 3A68     		ldr	r2, [r7]
 1819 0108 C3F88420 		str	r2, [r3, #132]
 759:../lwip-1.4.1/src/core/tcp.c **** #else /* LWIP_CALLBACK_API */  
 760:../lwip-1.4.1/src/core/tcp.c ****   LWIP_UNUSED_ARG(connected);
 761:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 762:../lwip-1.4.1/src/core/tcp.c **** 
 763:../lwip-1.4.1/src/core/tcp.c ****   /* Send a SYN together with the MSS option. */
 764:../lwip-1.4.1/src/core/tcp.c ****   ret = tcp_enqueue_flags(pcb, TCP_SYN);
 1820              		.loc 1 764 0
 1821 010c F868     		ldr	r0, [r7, #12]
 1822 010e 0221     		movs	r1, #2
 1823 0110 FFF7FEFF 		bl	tcp_enqueue_flags
 1824 0114 0346     		mov	r3, r0
 1825 0116 FB74     		strb	r3, [r7, #19]
 765:../lwip-1.4.1/src/core/tcp.c ****   if (ret == ERR_OK) {
 1826              		.loc 1 765 0
 1827 0118 97F91330 		ldrsb	r3, [r7, #19]
 1828 011c 002B     		cmp	r3, #0
 1829 011e 3CD1     		bne	.L121
 766:../lwip-1.4.1/src/core/tcp.c ****     /* SYN segment was enqueued, changed the pcbs state now */
 767:../lwip-1.4.1/src/core/tcp.c ****     pcb->state = SYN_SENT;
 1830              		.loc 1 767 0
 1831 0120 FB68     		ldr	r3, [r7, #12]
 1832 0122 0222     		movs	r2, #2
 1833 0124 1A76     		strb	r2, [r3, #24]
 768:../lwip-1.4.1/src/core/tcp.c ****     if (old_local_port != 0) {
 1834              		.loc 1 768 0
 1835 0126 7B8B     		ldrh	r3, [r7, #26]
 1836 0128 002B     		cmp	r3, #0
 1837 012a 27D0     		beq	.L122
 769:../lwip-1.4.1/src/core/tcp.c ****       TCP_RMV(&tcp_bound_pcbs, pcb);
 1838              		.loc 1 769 0
 1839 012c 1E4B     		ldr	r3, .L129
 1840 012e 1A68     		ldr	r2, [r3]
 1841 0130 FB68     		ldr	r3, [r7, #12]
 1842 0132 9A42     		cmp	r2, r3
 1843 0134 05D1     		bne	.L123
 1844              		.loc 1 769 0 is_stmt 0 discriminator 1
 1845 0136 1C4B     		ldr	r3, .L129
 1846 0138 1B68     		ldr	r3, [r3]
 1847 013a DB68     		ldr	r3, [r3, #12]
 1848 013c 1A4A     		ldr	r2, .L129
 1849 013e 1360     		str	r3, [r2]
 1850 0140 19E0     		b	.L124
 1851              	.L123:
 1852              		.loc 1 769 0 discriminator 2
 1853 0142 194B     		ldr	r3, .L129
 1854 0144 1B68     		ldr	r3, [r3]
 1855 0146 194A     		ldr	r2, .L129+4
 1856 0148 1360     		str	r3, [r2]
 1857 014a 10E0     		b	.L125
 1858              	.L127:
 1859              		.loc 1 769 0 discriminator 9
 1860 014c 174B     		ldr	r3, .L129+4
 1861 014e 1B68     		ldr	r3, [r3]
 1862 0150 DA68     		ldr	r2, [r3, #12]
 1863 0152 FB68     		ldr	r3, [r7, #12]
 1864 0154 9A42     		cmp	r2, r3
 1865 0156 05D1     		bne	.L126
 1866              		.loc 1 769 0 discriminator 5
 1867 0158 144B     		ldr	r3, .L129+4
 1868 015a 1B68     		ldr	r3, [r3]
 1869 015c FA68     		ldr	r2, [r7, #12]
 1870 015e D268     		ldr	r2, [r2, #12]
 1871 0160 DA60     		str	r2, [r3, #12]
 1872 0162 08E0     		b	.L124
 1873              	.L126:
 1874              		.loc 1 769 0 discriminator 6
 1875 0164 114B     		ldr	r3, .L129+4
 1876 0166 1B68     		ldr	r3, [r3]
 1877 0168 DB68     		ldr	r3, [r3, #12]
 1878 016a 104A     		ldr	r2, .L129+4
 1879 016c 1360     		str	r3, [r2]
 1880              	.L125:
 1881              		.loc 1 769 0 discriminator 8
 1882 016e 0F4B     		ldr	r3, .L129+4
 1883 0170 1B68     		ldr	r3, [r3]
 1884 0172 002B     		cmp	r3, #0
 1885 0174 EAD1     		bne	.L127
 1886              	.L124:
 1887              		.loc 1 769 0 discriminator 10
 1888 0176 FB68     		ldr	r3, [r7, #12]
 1889 0178 0022     		movs	r2, #0
 1890 017a DA60     		str	r2, [r3, #12]
 1891              	.L122:
 770:../lwip-1.4.1/src/core/tcp.c ****     }
 771:../lwip-1.4.1/src/core/tcp.c ****     TCP_REG_ACTIVE(pcb);
 1892              		.loc 1 771 0 is_stmt 1
 1893 017c 0C4B     		ldr	r3, .L129+8
 1894 017e 1A68     		ldr	r2, [r3]
 1895 0180 FB68     		ldr	r3, [r7, #12]
 1896 0182 DA60     		str	r2, [r3, #12]
 1897 0184 0A4A     		ldr	r2, .L129+8
 1898 0186 FB68     		ldr	r3, [r7, #12]
 1899 0188 1360     		str	r3, [r2]
 1900 018a FFF7FEFF 		bl	tcp_timer_needed
 1901 018e 094B     		ldr	r3, .L129+12
 1902 0190 0122     		movs	r2, #1
 1903 0192 1A70     		strb	r2, [r3]
 772:../lwip-1.4.1/src/core/tcp.c ****     snmp_inc_tcpactiveopens();
 773:../lwip-1.4.1/src/core/tcp.c **** 
 774:../lwip-1.4.1/src/core/tcp.c ****     tcp_output(pcb);
 1904              		.loc 1 774 0
 1905 0194 F868     		ldr	r0, [r7, #12]
 1906 0196 FFF7FEFF 		bl	tcp_output
 1907              	.L121:
 775:../lwip-1.4.1/src/core/tcp.c ****   }
 776:../lwip-1.4.1/src/core/tcp.c ****   return ret;
 1908              		.loc 1 776 0
 1909 019a FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1910              	.L114:
 1911 019c 5BB2     		sxtb	r3, r3
 777:../lwip-1.4.1/src/core/tcp.c **** }
 1912              		.loc 1 777 0
 1913 019e 1846     		mov	r0, r3
 1914 01a0 2037     		adds	r7, r7, #32
 1915              		.cfi_def_cfa_offset 8
 1916 01a2 BD46     		mov	sp, r7
 1917              		.cfi_def_cfa_register 13
 1918              		@ sp needed
 1919 01a4 80BD     		pop	{r7, pc}
 1920              	.L130:
 1921 01a6 00BF     		.align	2
 1922              	.L129:
 1923 01a8 00000000 		.word	tcp_bound_pcbs
 1924 01ac 00000000 		.word	tcp_tmp_pcb
 1925 01b0 00000000 		.word	tcp_active_pcbs
 1926 01b4 00000000 		.word	tcp_active_pcbs_changed
 1927              		.cfi_endproc
 1928              	.LFE13:
 1930              		.section	.text.tcp_slowtmr,"ax",%progbits
 1931              		.align	2
 1932              		.global	tcp_slowtmr
 1933              		.thumb
 1934              		.thumb_func
 1936              	tcp_slowtmr:
 1937              	.LFB14:
 778:../lwip-1.4.1/src/core/tcp.c **** 
 779:../lwip-1.4.1/src/core/tcp.c **** /**
 780:../lwip-1.4.1/src/core/tcp.c ****  * Called every 500 ms and implements the retransmission timer and the timer that
 781:../lwip-1.4.1/src/core/tcp.c ****  * removes PCBs that have been in TIME-WAIT for enough time. It also increments
 782:../lwip-1.4.1/src/core/tcp.c ****  * various timers such as the inactivity timer in each PCB.
 783:../lwip-1.4.1/src/core/tcp.c ****  *
 784:../lwip-1.4.1/src/core/tcp.c ****  * Automatically called from tcp_tmr().
 785:../lwip-1.4.1/src/core/tcp.c ****  */
 786:../lwip-1.4.1/src/core/tcp.c **** void
 787:../lwip-1.4.1/src/core/tcp.c **** tcp_slowtmr(void)
 788:../lwip-1.4.1/src/core/tcp.c **** {
 1938              		.loc 1 788 0
 1939              		.cfi_startproc
 1940              		@ args = 0, pretend = 0, frame = 32
 1941              		@ frame_needed = 1, uses_anonymous_args = 0
 1942 0000 B0B5     		push	{r4, r5, r7, lr}
 1943              		.cfi_def_cfa_offset 16
 1944              		.cfi_offset 4, -16
 1945              		.cfi_offset 5, -12
 1946              		.cfi_offset 7, -8
 1947              		.cfi_offset 14, -4
 1948 0002 8AB0     		sub	sp, sp, #40
 1949              		.cfi_def_cfa_offset 56
 1950 0004 02AF     		add	r7, sp, #8
 1951              		.cfi_def_cfa 7, 48
 789:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb *pcb, *prev;
 790:../lwip-1.4.1/src/core/tcp.c ****   u16_t eff_wnd;
 791:../lwip-1.4.1/src/core/tcp.c ****   u8_t pcb_remove;      /* flag if a PCB should be removed */
 792:../lwip-1.4.1/src/core/tcp.c ****   u8_t pcb_reset;       /* flag if a RST should be sent when removing */
 793:../lwip-1.4.1/src/core/tcp.c ****   err_t err;
 794:../lwip-1.4.1/src/core/tcp.c **** 
 795:../lwip-1.4.1/src/core/tcp.c ****   err = ERR_OK;
 1952              		.loc 1 795 0
 1953 0006 0023     		movs	r3, #0
 1954 0008 7B75     		strb	r3, [r7, #21]
 796:../lwip-1.4.1/src/core/tcp.c **** 
 797:../lwip-1.4.1/src/core/tcp.c ****   ++tcp_ticks;
 1955              		.loc 1 797 0
 1956 000a 814B     		ldr	r3, .L167
 1957 000c 1B68     		ldr	r3, [r3]
 1958 000e 0133     		adds	r3, r3, #1
 1959 0010 7F4A     		ldr	r2, .L167
 1960 0012 1360     		str	r3, [r2]
 798:../lwip-1.4.1/src/core/tcp.c ****   ++tcp_timer_ctr;
 1961              		.loc 1 798 0
 1962 0014 7F4B     		ldr	r3, .L167+4
 1963 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1964 0018 0133     		adds	r3, r3, #1
 1965 001a DAB2     		uxtb	r2, r3
 1966 001c 7D4B     		ldr	r3, .L167+4
 1967 001e 1A70     		strb	r2, [r3]
 1968              	.L132:
 799:../lwip-1.4.1/src/core/tcp.c **** 
 800:../lwip-1.4.1/src/core/tcp.c **** tcp_slowtmr_start:
 801:../lwip-1.4.1/src/core/tcp.c ****   /* Steps through all of the active PCBs. */
 802:../lwip-1.4.1/src/core/tcp.c ****   prev = NULL;
 1969              		.loc 1 802 0
 1970 0020 0023     		movs	r3, #0
 1971 0022 BB61     		str	r3, [r7, #24]
 803:../lwip-1.4.1/src/core/tcp.c ****   pcb = tcp_active_pcbs;
 1972              		.loc 1 803 0
 1973 0024 7C4B     		ldr	r3, .L167+8
 1974 0026 1B68     		ldr	r3, [r3]
 1975 0028 FB61     		str	r3, [r7, #28]
 804:../lwip-1.4.1/src/core/tcp.c ****   if (pcb == NULL) {
 805:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
 806:../lwip-1.4.1/src/core/tcp.c ****   }
 807:../lwip-1.4.1/src/core/tcp.c ****   while (pcb != NULL) {
 1976              		.loc 1 807 0
 1977 002a D2E1     		b	.L133
 1978              	.L160:
 808:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
 809:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 810:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 811:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 812:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->last_timer == tcp_timer_ctr) {
 1979              		.loc 1 812 0
 1980 002c FB69     		ldr	r3, [r7, #28]
 1981 002e 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 1982 0032 784B     		ldr	r3, .L167+4
 1983 0034 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1984 0036 9A42     		cmp	r2, r3
 1985 0038 03D1     		bne	.L134
 813:../lwip-1.4.1/src/core/tcp.c ****       /* skip this pcb, we have already processed it */
 814:../lwip-1.4.1/src/core/tcp.c ****       pcb = pcb->next;
 1986              		.loc 1 814 0
 1987 003a FB69     		ldr	r3, [r7, #28]
 1988 003c DB68     		ldr	r3, [r3, #12]
 1989 003e FB61     		str	r3, [r7, #28]
 815:../lwip-1.4.1/src/core/tcp.c ****       continue;
 1990              		.loc 1 815 0
 1991 0040 C7E1     		b	.L133
 1992              	.L134:
 816:../lwip-1.4.1/src/core/tcp.c ****     }
 817:../lwip-1.4.1/src/core/tcp.c ****     pcb->last_timer = tcp_timer_ctr;
 1993              		.loc 1 817 0
 1994 0042 744B     		ldr	r3, .L167+4
 1995 0044 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1996 0046 FB69     		ldr	r3, [r7, #28]
 1997 0048 83F82120 		strb	r2, [r3, #33]
 818:../lwip-1.4.1/src/core/tcp.c **** 
 819:../lwip-1.4.1/src/core/tcp.c ****     pcb_remove = 0;
 1998              		.loc 1 819 0
 1999 004c 0023     		movs	r3, #0
 2000 004e FB75     		strb	r3, [r7, #23]
 820:../lwip-1.4.1/src/core/tcp.c ****     pcb_reset = 0;
 2001              		.loc 1 820 0
 2002 0050 0023     		movs	r3, #0
 2003 0052 BB75     		strb	r3, [r7, #22]
 821:../lwip-1.4.1/src/core/tcp.c **** 
 822:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 2004              		.loc 1 822 0
 2005 0054 FB69     		ldr	r3, [r7, #28]
 2006 0056 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 2007 0058 022B     		cmp	r3, #2
 2008 005a 08D1     		bne	.L135
 2009              		.loc 1 822 0 is_stmt 0 discriminator 1
 2010 005c FB69     		ldr	r3, [r7, #28]
 2011 005e 93F84630 		ldrb	r3, [r3, #70]	@ zero_extendqisi2
 2012 0062 062B     		cmp	r3, #6
 2013 0064 03D1     		bne	.L135
 823:../lwip-1.4.1/src/core/tcp.c ****       ++pcb_remove;
 2014              		.loc 1 823 0 is_stmt 1
 2015 0066 FB7D     		ldrb	r3, [r7, #23]
 2016 0068 0133     		adds	r3, r3, #1
 2017 006a FB75     		strb	r3, [r7, #23]
 824:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
 2018              		.loc 1 824 0
 2019 006c 95E0     		b	.L136
 2020              	.L135:
 825:../lwip-1.4.1/src/core/tcp.c ****     }
 826:../lwip-1.4.1/src/core/tcp.c ****     else if (pcb->nrtx == TCP_MAXRTX) {
 2021              		.loc 1 826 0
 2022 006e FB69     		ldr	r3, [r7, #28]
 2023 0070 93F84630 		ldrb	r3, [r3, #70]	@ zero_extendqisi2
 2024 0074 0C2B     		cmp	r3, #12
 2025 0076 03D1     		bne	.L137
 827:../lwip-1.4.1/src/core/tcp.c ****       ++pcb_remove;
 2026              		.loc 1 827 0
 2027 0078 FB7D     		ldrb	r3, [r7, #23]
 2028 007a 0133     		adds	r3, r3, #1
 2029 007c FB75     		strb	r3, [r7, #23]
 2030 007e 8CE0     		b	.L136
 2031              	.L137:
 828:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
 829:../lwip-1.4.1/src/core/tcp.c ****     } else {
 830:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->persist_backoff > 0) {
 2032              		.loc 1 830 0
 2033 0080 FB69     		ldr	r3, [r7, #28]
 2034 0082 93F89530 		ldrb	r3, [r3, #149]	@ zero_extendqisi2
 2035 0086 002B     		cmp	r3, #0
 2036 0088 27D0     		beq	.L138
 831:../lwip-1.4.1/src/core/tcp.c ****         /* If snd_wnd is zero, use persist timer to send 1 byte probes
 832:../lwip-1.4.1/src/core/tcp.c ****          * instead of using the standard retransmission mechanism. */
 833:../lwip-1.4.1/src/core/tcp.c ****         pcb->persist_cnt++;
 2037              		.loc 1 833 0
 2038 008a FB69     		ldr	r3, [r7, #28]
 2039 008c 93F89430 		ldrb	r3, [r3, #148]	@ zero_extendqisi2
 2040 0090 0133     		adds	r3, r3, #1
 2041 0092 DAB2     		uxtb	r2, r3
 2042 0094 FB69     		ldr	r3, [r7, #28]
 2043 0096 83F89420 		strb	r2, [r3, #148]
 834:../lwip-1.4.1/src/core/tcp.c ****         if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 2044              		.loc 1 834 0
 2045 009a FB69     		ldr	r3, [r7, #28]
 2046 009c 93F89420 		ldrb	r2, [r3, #148]	@ zero_extendqisi2
 2047 00a0 FB69     		ldr	r3, [r7, #28]
 2048 00a2 93F89530 		ldrb	r3, [r3, #149]	@ zero_extendqisi2
 2049 00a6 013B     		subs	r3, r3, #1
 2050 00a8 5C49     		ldr	r1, .L167+12
 2051 00aa CB5C     		ldrb	r3, [r1, r3]	@ zero_extendqisi2
 2052 00ac 9A42     		cmp	r2, r3
 2053 00ae 74D3     		bcc	.L136
 835:../lwip-1.4.1/src/core/tcp.c ****           pcb->persist_cnt = 0;
 2054              		.loc 1 835 0
 2055 00b0 FB69     		ldr	r3, [r7, #28]
 2056 00b2 0022     		movs	r2, #0
 2057 00b4 83F89420 		strb	r2, [r3, #148]
 836:../lwip-1.4.1/src/core/tcp.c ****           if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 2058              		.loc 1 836 0
 2059 00b8 FB69     		ldr	r3, [r7, #28]
 2060 00ba 93F89530 		ldrb	r3, [r3, #149]	@ zero_extendqisi2
 2061 00be 062B     		cmp	r3, #6
 2062 00c0 07D8     		bhi	.L140
 837:../lwip-1.4.1/src/core/tcp.c ****             pcb->persist_backoff++;
 2063              		.loc 1 837 0
 2064 00c2 FB69     		ldr	r3, [r7, #28]
 2065 00c4 93F89530 		ldrb	r3, [r3, #149]	@ zero_extendqisi2
 2066 00c8 0133     		adds	r3, r3, #1
 2067 00ca DAB2     		uxtb	r2, r3
 2068 00cc FB69     		ldr	r3, [r7, #28]
 2069 00ce 83F89520 		strb	r2, [r3, #149]
 2070              	.L140:
 838:../lwip-1.4.1/src/core/tcp.c ****           }
 839:../lwip-1.4.1/src/core/tcp.c ****           tcp_zero_window_probe(pcb);
 2071              		.loc 1 839 0
 2072 00d2 F869     		ldr	r0, [r7, #28]
 2073 00d4 FFF7FEFF 		bl	tcp_zero_window_probe
 2074 00d8 5FE0     		b	.L136
 2075              	.L138:
 840:../lwip-1.4.1/src/core/tcp.c ****         }
 841:../lwip-1.4.1/src/core/tcp.c ****       } else {
 842:../lwip-1.4.1/src/core/tcp.c ****         /* Increase the retransmission timer if it is running */
 843:../lwip-1.4.1/src/core/tcp.c ****         if(pcb->rtime >= 0) {
 2076              		.loc 1 843 0
 2077 00da FB69     		ldr	r3, [r7, #28]
 2078 00dc 9B8E     		ldrh	r3, [r3, #52]
 2079 00de 1BB2     		sxth	r3, r3
 2080 00e0 002B     		cmp	r3, #0
 2081 00e2 07DB     		blt	.L141
 844:../lwip-1.4.1/src/core/tcp.c ****           ++pcb->rtime;
 2082              		.loc 1 844 0
 2083 00e4 FB69     		ldr	r3, [r7, #28]
 2084 00e6 9B8E     		ldrh	r3, [r3, #52]
 2085 00e8 9BB2     		uxth	r3, r3
 2086 00ea 0133     		adds	r3, r3, #1
 2087 00ec 9BB2     		uxth	r3, r3
 2088 00ee 9AB2     		uxth	r2, r3
 2089 00f0 FB69     		ldr	r3, [r7, #28]
 2090 00f2 9A86     		strh	r2, [r3, #52]	@ movhi
 2091              	.L141:
 845:../lwip-1.4.1/src/core/tcp.c ****         }
 846:../lwip-1.4.1/src/core/tcp.c **** 
 847:../lwip-1.4.1/src/core/tcp.c ****         if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 2092              		.loc 1 847 0
 2093 00f4 FB69     		ldr	r3, [r7, #28]
 2094 00f6 1B6F     		ldr	r3, [r3, #112]
 2095 00f8 002B     		cmp	r3, #0
 2096 00fa 4ED0     		beq	.L136
 2097              		.loc 1 847 0 is_stmt 0 discriminator 1
 2098 00fc FB69     		ldr	r3, [r7, #28]
 2099 00fe 9A8E     		ldrh	r2, [r3, #52]
 2100 0100 FB69     		ldr	r3, [r7, #28]
 2101 0102 B3F84430 		ldrh	r3, [r3, #68]
 2102 0106 12B2     		sxth	r2, r2
 2103 0108 1BB2     		sxth	r3, r3
 2104 010a 9A42     		cmp	r2, r3
 2105 010c 45DB     		blt	.L136
 848:../lwip-1.4.1/src/core/tcp.c ****           /* Time for a retransmission. */
 849:../lwip-1.4.1/src/core/tcp.c ****           LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
 850:../lwip-1.4.1/src/core/tcp.c ****                                       " pcb->rto %"S16_F"\n",
 851:../lwip-1.4.1/src/core/tcp.c ****                                       pcb->rtime, pcb->rto));
 852:../lwip-1.4.1/src/core/tcp.c **** 
 853:../lwip-1.4.1/src/core/tcp.c ****           /* Double retransmission time-out unless we are trying to
 854:../lwip-1.4.1/src/core/tcp.c ****            * connect to somebody (i.e., we are in SYN_SENT). */
 855:../lwip-1.4.1/src/core/tcp.c ****           if (pcb->state != SYN_SENT) {
 2106              		.loc 1 855 0 is_stmt 1
 2107 010e FB69     		ldr	r3, [r7, #28]
 2108 0110 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 2109 0112 022B     		cmp	r3, #2
 2110 0114 16D0     		beq	.L142
 856:../lwip-1.4.1/src/core/tcp.c ****             pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 2111              		.loc 1 856 0
 2112 0116 FB69     		ldr	r3, [r7, #28]
 2113 0118 B3F84030 		ldrh	r3, [r3, #64]
 2114 011c 1BB2     		sxth	r3, r3
 2115 011e DB10     		asrs	r3, r3, #3
 2116 0120 9BB2     		uxth	r3, r3
 2117 0122 1AB2     		sxth	r2, r3
 2118 0124 FB69     		ldr	r3, [r7, #28]
 2119 0126 B3F84230 		ldrh	r3, [r3, #66]
 2120 012a 1BB2     		sxth	r3, r3
 2121 012c 1344     		add	r3, r3, r2
 2122 012e FA69     		ldr	r2, [r7, #28]
 2123 0130 92F84620 		ldrb	r2, [r2, #70]	@ zero_extendqisi2
 2124 0134 1146     		mov	r1, r2
 2125 0136 3A4A     		ldr	r2, .L167+16
 2126 0138 525C     		ldrb	r2, [r2, r1]	@ zero_extendqisi2
 2127 013a 9340     		lsls	r3, r3, r2
 2128 013c 9AB2     		uxth	r2, r3
 2129 013e FB69     		ldr	r3, [r7, #28]
 2130 0140 A3F84420 		strh	r2, [r3, #68]	@ movhi
 2131              	.L142:
 857:../lwip-1.4.1/src/core/tcp.c ****           }
 858:../lwip-1.4.1/src/core/tcp.c **** 
 859:../lwip-1.4.1/src/core/tcp.c ****           /* Reset the retransmission timer. */
 860:../lwip-1.4.1/src/core/tcp.c ****           pcb->rtime = 0;
 2132              		.loc 1 860 0
 2133 0144 FB69     		ldr	r3, [r7, #28]
 2134 0146 0022     		movs	r2, #0
 2135 0148 9A86     		strh	r2, [r3, #52]	@ movhi
 861:../lwip-1.4.1/src/core/tcp.c **** 
 862:../lwip-1.4.1/src/core/tcp.c ****           /* Reduce congestion window and ssthresh. */
 863:../lwip-1.4.1/src/core/tcp.c ****           eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 2136              		.loc 1 863 0
 2137 014a FB69     		ldr	r3, [r7, #28]
 2138 014c B3F86020 		ldrh	r2, [r3, #96]
 2139 0150 FB69     		ldr	r3, [r7, #28]
 2140 0152 B3F84C30 		ldrh	r3, [r3, #76]
 2141 0156 9342     		cmp	r3, r2
 2142 0158 28BF     		it	cs
 2143 015a 1346     		movcs	r3, r2
 2144 015c 7B82     		strh	r3, [r7, #18]	@ movhi
 864:../lwip-1.4.1/src/core/tcp.c ****           pcb->ssthresh = eff_wnd >> 1;
 2145              		.loc 1 864 0
 2146 015e 7B8A     		ldrh	r3, [r7, #18]
 2147 0160 5B08     		lsrs	r3, r3, #1
 2148 0162 9AB2     		uxth	r2, r3
 2149 0164 FB69     		ldr	r3, [r7, #28]
 2150 0166 A3F84E20 		strh	r2, [r3, #78]	@ movhi
 865:../lwip-1.4.1/src/core/tcp.c ****           if (pcb->ssthresh < (pcb->mss << 1)) {
 2151              		.loc 1 865 0
 2152 016a FB69     		ldr	r3, [r7, #28]
 2153 016c B3F84E30 		ldrh	r3, [r3, #78]
 2154 0170 1A46     		mov	r2, r3
 2155 0172 FB69     		ldr	r3, [r7, #28]
 2156 0174 DB8E     		ldrh	r3, [r3, #54]
 2157 0176 5B00     		lsls	r3, r3, #1
 2158 0178 9A42     		cmp	r2, r3
 2159 017a 06DA     		bge	.L143
 866:../lwip-1.4.1/src/core/tcp.c ****             pcb->ssthresh = (pcb->mss << 1);
 2160              		.loc 1 866 0
 2161 017c FB69     		ldr	r3, [r7, #28]
 2162 017e DB8E     		ldrh	r3, [r3, #54]
 2163 0180 5B00     		lsls	r3, r3, #1
 2164 0182 9AB2     		uxth	r2, r3
 2165 0184 FB69     		ldr	r3, [r7, #28]
 2166 0186 A3F84E20 		strh	r2, [r3, #78]	@ movhi
 2167              	.L143:
 867:../lwip-1.4.1/src/core/tcp.c ****           }
 868:../lwip-1.4.1/src/core/tcp.c ****           pcb->cwnd = pcb->mss;
 2168              		.loc 1 868 0
 2169 018a FB69     		ldr	r3, [r7, #28]
 2170 018c DA8E     		ldrh	r2, [r3, #54]
 2171 018e FB69     		ldr	r3, [r7, #28]
 2172 0190 A3F84C20 		strh	r2, [r3, #76]	@ movhi
 869:../lwip-1.4.1/src/core/tcp.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
 870:../lwip-1.4.1/src/core/tcp.c ****                                        " ssthresh %"U16_F"\n",
 871:../lwip-1.4.1/src/core/tcp.c ****                                        pcb->cwnd, pcb->ssthresh));
 872:../lwip-1.4.1/src/core/tcp.c ****  
 873:../lwip-1.4.1/src/core/tcp.c ****           /* The following needs to be called AFTER cwnd is set to one
 874:../lwip-1.4.1/src/core/tcp.c ****              mss - STJ */
 875:../lwip-1.4.1/src/core/tcp.c ****           tcp_rexmit_rto(pcb);
 2173              		.loc 1 875 0
 2174 0194 F869     		ldr	r0, [r7, #28]
 2175 0196 FFF7FEFF 		bl	tcp_rexmit_rto
 2176              	.L136:
 876:../lwip-1.4.1/src/core/tcp.c ****         }
 877:../lwip-1.4.1/src/core/tcp.c ****       }
 878:../lwip-1.4.1/src/core/tcp.c ****     }
 879:../lwip-1.4.1/src/core/tcp.c ****     /* Check if this PCB has stayed too long in FIN-WAIT-2 */
 880:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->state == FIN_WAIT_2) {
 2177              		.loc 1 880 0
 2178 019a FB69     		ldr	r3, [r7, #28]
 2179 019c 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 2180 019e 062B     		cmp	r3, #6
 2181 01a0 0FD1     		bne	.L144
 881:../lwip-1.4.1/src/core/tcp.c ****       /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
 882:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->flags & TF_RXCLOSED) {
 2182              		.loc 1 882 0
 2183 01a2 FB69     		ldr	r3, [r7, #28]
 2184 01a4 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 2185 01a6 03F01003 		and	r3, r3, #16
 2186 01aa 002B     		cmp	r3, #0
 2187 01ac 09D0     		beq	.L144
 883:../lwip-1.4.1/src/core/tcp.c ****         /* PCB was fully closed (either through close() or SHUT_RDWR):
 884:../lwip-1.4.1/src/core/tcp.c ****            normal FIN-WAIT timeout handling. */
 885:../lwip-1.4.1/src/core/tcp.c ****         if ((u32_t)(tcp_ticks - pcb->tmr) >
 2188              		.loc 1 885 0
 2189 01ae 184B     		ldr	r3, .L167
 2190 01b0 1A68     		ldr	r2, [r3]
 2191 01b2 FB69     		ldr	r3, [r7, #28]
 2192 01b4 5B6A     		ldr	r3, [r3, #36]
 2193 01b6 D31A     		subs	r3, r2, r3
 2194 01b8 282B     		cmp	r3, #40
 2195 01ba 02D9     		bls	.L144
 886:../lwip-1.4.1/src/core/tcp.c ****             TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
 887:../lwip-1.4.1/src/core/tcp.c ****           ++pcb_remove;
 2196              		.loc 1 887 0
 2197 01bc FB7D     		ldrb	r3, [r7, #23]
 2198 01be 0133     		adds	r3, r3, #1
 2199 01c0 FB75     		strb	r3, [r7, #23]
 2200              	.L144:
 888:../lwip-1.4.1/src/core/tcp.c ****           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
 889:../lwip-1.4.1/src/core/tcp.c ****         }
 890:../lwip-1.4.1/src/core/tcp.c ****       }
 891:../lwip-1.4.1/src/core/tcp.c ****     }
 892:../lwip-1.4.1/src/core/tcp.c **** 
 893:../lwip-1.4.1/src/core/tcp.c ****     /* Check if KEEPALIVE should be sent */
 894:../lwip-1.4.1/src/core/tcp.c ****     if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 2201              		.loc 1 894 0
 2202 01c2 FB69     		ldr	r3, [r7, #28]
 2203 01c4 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2204 01c6 03F00803 		and	r3, r3, #8
 2205 01ca 002B     		cmp	r3, #0
 2206 01cc 4DD0     		beq	.L145
 895:../lwip-1.4.1/src/core/tcp.c ****        ((pcb->state == ESTABLISHED) ||
 2207              		.loc 1 895 0 discriminator 1
 2208 01ce FB69     		ldr	r3, [r7, #28]
 2209 01d0 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 894:../lwip-1.4.1/src/core/tcp.c ****        ((pcb->state == ESTABLISHED) ||
 2210              		.loc 1 894 0 discriminator 1
 2211 01d2 042B     		cmp	r3, #4
 2212 01d4 03D0     		beq	.L146
 896:../lwip-1.4.1/src/core/tcp.c ****         (pcb->state == CLOSE_WAIT))) {
 2213              		.loc 1 896 0
 2214 01d6 FB69     		ldr	r3, [r7, #28]
 2215 01d8 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 895:../lwip-1.4.1/src/core/tcp.c ****        ((pcb->state == ESTABLISHED) ||
 2216              		.loc 1 895 0
 2217 01da 072B     		cmp	r3, #7
 2218 01dc 45D1     		bne	.L145
 2219              	.L146:
 897:../lwip-1.4.1/src/core/tcp.c ****       if((u32_t)(tcp_ticks - pcb->tmr) >
 2220              		.loc 1 897 0
 2221 01de 0C4B     		ldr	r3, .L167
 2222 01e0 1A68     		ldr	r2, [r3]
 2223 01e2 FB69     		ldr	r3, [r7, #28]
 2224 01e4 5B6A     		ldr	r3, [r3, #36]
 2225 01e6 D21A     		subs	r2, r2, r3
 898:../lwip-1.4.1/src/core/tcp.c ****          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 2226              		.loc 1 898 0
 2227 01e8 FB69     		ldr	r3, [r7, #28]
 2228 01ea D3F89030 		ldr	r3, [r3, #144]
 2229 01ee 03F52423 		add	r3, r3, #671744
 2230 01f2 03F6B843 		addw	r3, r3, #3256
 2231 01f6 0B49     		ldr	r1, .L167+20
 2232 01f8 A1FB0313 		umull	r1, r3, r1, r3
 2233 01fc 5B09     		lsrs	r3, r3, #5
 897:../lwip-1.4.1/src/core/tcp.c ****       if((u32_t)(tcp_ticks - pcb->tmr) >
 2234              		.loc 1 897 0
 2235 01fe 9A42     		cmp	r2, r3
 2236 0200 12D9     		bls	.L147
 899:../lwip-1.4.1/src/core/tcp.c ****       {
 900:../lwip-1.4.1/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"
 901:../lwip-1.4.1/src/core/tcp.c ****                                 ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
 902:../lwip-1.4.1/src/core/tcp.c ****                                 ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
 903:../lwip-1.4.1/src/core/tcp.c ****         
 904:../lwip-1.4.1/src/core/tcp.c ****         ++pcb_remove;
 2237              		.loc 1 904 0
 2238 0202 FB7D     		ldrb	r3, [r7, #23]
 2239 0204 0133     		adds	r3, r3, #1
 2240 0206 FB75     		strb	r3, [r7, #23]
 905:../lwip-1.4.1/src/core/tcp.c ****         ++pcb_reset;
 2241              		.loc 1 905 0
 2242 0208 BB7D     		ldrb	r3, [r7, #22]
 2243 020a 0133     		adds	r3, r3, #1
 2244 020c BB75     		strb	r3, [r7, #22]
 2245 020e 2CE0     		b	.L145
 2246              	.L168:
 2247              		.align	2
 2248              	.L167:
 2249 0210 00000000 		.word	tcp_ticks
 2250 0214 01000000 		.word	tcp_timer_ctr
 2251 0218 00000000 		.word	tcp_active_pcbs
 2252 021c 00000000 		.word	tcp_persist_backoff
 2253 0220 00000000 		.word	tcp_backoff
 2254 0224 D34D6210 		.word	274877907
 2255              	.L147:
 906:../lwip-1.4.1/src/core/tcp.c ****       }
 907:../lwip-1.4.1/src/core/tcp.c ****       else if((u32_t)(tcp_ticks - pcb->tmr) > 
 2256              		.loc 1 907 0
 2257 0228 884B     		ldr	r3, .L169
 2258 022a 1A68     		ldr	r2, [r3]
 2259 022c FB69     		ldr	r3, [r7, #28]
 2260 022e 5B6A     		ldr	r3, [r3, #36]
 2261 0230 D21A     		subs	r2, r2, r3
 908:../lwip-1.4.1/src/core/tcp.c ****               (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 2262              		.loc 1 908 0
 2263 0232 FB69     		ldr	r3, [r7, #28]
 2264 0234 D3F89010 		ldr	r1, [r3, #144]
 2265 0238 FB69     		ldr	r3, [r7, #28]
 2266 023a 93F89630 		ldrb	r3, [r3, #150]	@ zero_extendqisi2
 2267 023e 1846     		mov	r0, r3
 2268 0240 834B     		ldr	r3, .L169+4
 2269 0242 03FB00F3 		mul	r3, r3, r0
 2270 0246 0B44     		add	r3, r3, r1
 909:../lwip-1.4.1/src/core/tcp.c ****               / TCP_SLOW_INTERVAL)
 2271              		.loc 1 909 0
 2272 0248 8249     		ldr	r1, .L169+8
 2273 024a A1FB0313 		umull	r1, r3, r1, r3
 2274 024e 5B09     		lsrs	r3, r3, #5
 907:../lwip-1.4.1/src/core/tcp.c ****               (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 2275              		.loc 1 907 0
 2276 0250 9A42     		cmp	r2, r3
 2277 0252 0AD9     		bls	.L145
 910:../lwip-1.4.1/src/core/tcp.c ****       {
 911:../lwip-1.4.1/src/core/tcp.c ****         tcp_keepalive(pcb);
 2278              		.loc 1 911 0
 2279 0254 F869     		ldr	r0, [r7, #28]
 2280 0256 FFF7FEFF 		bl	tcp_keepalive
 912:../lwip-1.4.1/src/core/tcp.c ****         pcb->keep_cnt_sent++;
 2281              		.loc 1 912 0
 2282 025a FB69     		ldr	r3, [r7, #28]
 2283 025c 93F89630 		ldrb	r3, [r3, #150]	@ zero_extendqisi2
 2284 0260 0133     		adds	r3, r3, #1
 2285 0262 DAB2     		uxtb	r2, r3
 2286 0264 FB69     		ldr	r3, [r7, #28]
 2287 0266 83F89620 		strb	r2, [r3, #150]
 2288              	.L145:
 913:../lwip-1.4.1/src/core/tcp.c ****       }
 914:../lwip-1.4.1/src/core/tcp.c ****     }
 915:../lwip-1.4.1/src/core/tcp.c **** 
 916:../lwip-1.4.1/src/core/tcp.c ****     /* If this PCB has queued out of sequence data, but has been
 917:../lwip-1.4.1/src/core/tcp.c ****        inactive for too long, will drop the data (it will eventually
 918:../lwip-1.4.1/src/core/tcp.c ****        be retransmitted). */
 919:../lwip-1.4.1/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ
 920:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->ooseq != NULL &&
 2289              		.loc 1 920 0
 2290 026a FB69     		ldr	r3, [r7, #28]
 2291 026c 5B6F     		ldr	r3, [r3, #116]
 2292 026e 002B     		cmp	r3, #0
 2293 0270 16D0     		beq	.L148
 921:../lwip-1.4.1/src/core/tcp.c ****         (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 2294              		.loc 1 921 0 discriminator 1
 2295 0272 764B     		ldr	r3, .L169
 2296 0274 1A68     		ldr	r2, [r3]
 2297 0276 FB69     		ldr	r3, [r7, #28]
 2298 0278 5B6A     		ldr	r3, [r3, #36]
 2299 027a D11A     		subs	r1, r2, r3
 2300 027c FB69     		ldr	r3, [r7, #28]
 2301 027e B3F84430 		ldrh	r3, [r3, #68]
 2302 0282 1AB2     		sxth	r2, r3
 2303 0284 1346     		mov	r3, r2
 2304 0286 5B00     		lsls	r3, r3, #1
 2305 0288 1344     		add	r3, r3, r2
 2306 028a 5B00     		lsls	r3, r3, #1
 920:../lwip-1.4.1/src/core/tcp.c ****         (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 2307              		.loc 1 920 0 discriminator 1
 2308 028c 9942     		cmp	r1, r3
 2309 028e 07D3     		bcc	.L148
 922:../lwip-1.4.1/src/core/tcp.c ****       tcp_segs_free(pcb->ooseq);
 2310              		.loc 1 922 0
 2311 0290 FB69     		ldr	r3, [r7, #28]
 2312 0292 5B6F     		ldr	r3, [r3, #116]
 2313 0294 1846     		mov	r0, r3
 2314 0296 FFF7FEFF 		bl	tcp_segs_free
 923:../lwip-1.4.1/src/core/tcp.c ****       pcb->ooseq = NULL;
 2315              		.loc 1 923 0
 2316 029a FB69     		ldr	r3, [r7, #28]
 2317 029c 0022     		movs	r2, #0
 2318 029e 5A67     		str	r2, [r3, #116]
 2319              	.L148:
 924:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
 925:../lwip-1.4.1/src/core/tcp.c ****     }
 926:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
 927:../lwip-1.4.1/src/core/tcp.c **** 
 928:../lwip-1.4.1/src/core/tcp.c ****     /* Check if this PCB has stayed too long in SYN-RCVD */
 929:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->state == SYN_RCVD) {
 2320              		.loc 1 929 0
 2321 02a0 FB69     		ldr	r3, [r7, #28]
 2322 02a2 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 2323 02a4 032B     		cmp	r3, #3
 2324 02a6 09D1     		bne	.L149
 930:../lwip-1.4.1/src/core/tcp.c ****       if ((u32_t)(tcp_ticks - pcb->tmr) >
 2325              		.loc 1 930 0
 2326 02a8 684B     		ldr	r3, .L169
 2327 02aa 1A68     		ldr	r2, [r3]
 2328 02ac FB69     		ldr	r3, [r7, #28]
 2329 02ae 5B6A     		ldr	r3, [r3, #36]
 2330 02b0 D31A     		subs	r3, r2, r3
 2331 02b2 282B     		cmp	r3, #40
 2332 02b4 02D9     		bls	.L149
 931:../lwip-1.4.1/src/core/tcp.c ****           TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
 932:../lwip-1.4.1/src/core/tcp.c ****         ++pcb_remove;
 2333              		.loc 1 932 0
 2334 02b6 FB7D     		ldrb	r3, [r7, #23]
 2335 02b8 0133     		adds	r3, r3, #1
 2336 02ba FB75     		strb	r3, [r7, #23]
 2337              	.L149:
 933:../lwip-1.4.1/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
 934:../lwip-1.4.1/src/core/tcp.c ****       }
 935:../lwip-1.4.1/src/core/tcp.c ****     }
 936:../lwip-1.4.1/src/core/tcp.c **** 
 937:../lwip-1.4.1/src/core/tcp.c ****     /* Check if this PCB has stayed too long in LAST-ACK */
 938:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->state == LAST_ACK) {
 2338              		.loc 1 938 0
 2339 02bc FB69     		ldr	r3, [r7, #28]
 2340 02be 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 2341 02c0 092B     		cmp	r3, #9
 2342 02c2 09D1     		bne	.L150
 939:../lwip-1.4.1/src/core/tcp.c ****       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 2343              		.loc 1 939 0
 2344 02c4 614B     		ldr	r3, .L169
 2345 02c6 1A68     		ldr	r2, [r3]
 2346 02c8 FB69     		ldr	r3, [r7, #28]
 2347 02ca 5B6A     		ldr	r3, [r3, #36]
 2348 02cc D31A     		subs	r3, r2, r3
 2349 02ce F02B     		cmp	r3, #240
 2350 02d0 02D9     		bls	.L150
 940:../lwip-1.4.1/src/core/tcp.c ****         ++pcb_remove;
 2351              		.loc 1 940 0
 2352 02d2 FB7D     		ldrb	r3, [r7, #23]
 2353 02d4 0133     		adds	r3, r3, #1
 2354 02d6 FB75     		strb	r3, [r7, #23]
 2355              	.L150:
 941:../lwip-1.4.1/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
 942:../lwip-1.4.1/src/core/tcp.c ****       }
 943:../lwip-1.4.1/src/core/tcp.c ****     }
 944:../lwip-1.4.1/src/core/tcp.c **** 
 945:../lwip-1.4.1/src/core/tcp.c ****     /* If the PCB should be removed, do it. */
 946:../lwip-1.4.1/src/core/tcp.c ****     if (pcb_remove) {
 2356              		.loc 1 946 0
 2357 02d8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2358 02da 002B     		cmp	r3, #0
 2359 02dc 43D0     		beq	.L151
 2360              	.LBB4:
 947:../lwip-1.4.1/src/core/tcp.c ****       struct tcp_pcb *pcb2;
 948:../lwip-1.4.1/src/core/tcp.c ****       tcp_err_fn err_fn;
 949:../lwip-1.4.1/src/core/tcp.c ****       void *err_arg;
 950:../lwip-1.4.1/src/core/tcp.c ****       tcp_pcb_purge(pcb);
 2361              		.loc 1 950 0
 2362 02de F869     		ldr	r0, [r7, #28]
 2363 02e0 FFF7FEFF 		bl	tcp_pcb_purge
 951:../lwip-1.4.1/src/core/tcp.c ****       /* Remove PCB from tcp_active_pcbs list. */
 952:../lwip-1.4.1/src/core/tcp.c ****       if (prev != NULL) {
 2364              		.loc 1 952 0
 2365 02e4 BB69     		ldr	r3, [r7, #24]
 2366 02e6 002B     		cmp	r3, #0
 2367 02e8 04D0     		beq	.L152
 953:../lwip-1.4.1/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 954:../lwip-1.4.1/src/core/tcp.c ****         prev->next = pcb->next;
 2368              		.loc 1 954 0
 2369 02ea FB69     		ldr	r3, [r7, #28]
 2370 02ec DA68     		ldr	r2, [r3, #12]
 2371 02ee BB69     		ldr	r3, [r7, #24]
 2372 02f0 DA60     		str	r2, [r3, #12]
 2373 02f2 03E0     		b	.L153
 2374              	.L152:
 955:../lwip-1.4.1/src/core/tcp.c ****       } else {
 956:../lwip-1.4.1/src/core/tcp.c ****         /* This PCB was the first. */
 957:../lwip-1.4.1/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 958:../lwip-1.4.1/src/core/tcp.c ****         tcp_active_pcbs = pcb->next;
 2375              		.loc 1 958 0
 2376 02f4 FB69     		ldr	r3, [r7, #28]
 2377 02f6 DB68     		ldr	r3, [r3, #12]
 2378 02f8 574A     		ldr	r2, .L169+12
 2379 02fa 1360     		str	r3, [r2]
 2380              	.L153:
 959:../lwip-1.4.1/src/core/tcp.c ****       }
 960:../lwip-1.4.1/src/core/tcp.c **** 
 961:../lwip-1.4.1/src/core/tcp.c ****       if (pcb_reset) {
 2381              		.loc 1 961 0
 2382 02fc BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 2383 02fe 002B     		cmp	r3, #0
 2384 0300 10D0     		beq	.L154
 962:../lwip-1.4.1/src/core/tcp.c ****         tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 2385              		.loc 1 962 0
 2386 0302 FB69     		ldr	r3, [r7, #28]
 2387 0304 186D     		ldr	r0, [r3, #80]
 2388 0306 FB69     		ldr	r3, [r7, #28]
 2389 0308 996A     		ldr	r1, [r3, #40]
 2390 030a FD69     		ldr	r5, [r7, #28]
 2391 030c FB69     		ldr	r3, [r7, #28]
 2392 030e 1C1D     		adds	r4, r3, #4
 2393 0310 FB69     		ldr	r3, [r7, #28]
 2394 0312 5A8B     		ldrh	r2, [r3, #26]
 2395 0314 FB69     		ldr	r3, [r7, #28]
 2396 0316 9B8B     		ldrh	r3, [r3, #28]
 2397 0318 0092     		str	r2, [sp]
 2398 031a 0193     		str	r3, [sp, #4]
 2399 031c 2A46     		mov	r2, r5
 2400 031e 2346     		mov	r3, r4
 2401 0320 FFF7FEFF 		bl	tcp_rst
 2402              	.L154:
 963:../lwip-1.4.1/src/core/tcp.c ****           pcb->local_port, pcb->remote_port);
 964:../lwip-1.4.1/src/core/tcp.c ****       }
 965:../lwip-1.4.1/src/core/tcp.c **** 
 966:../lwip-1.4.1/src/core/tcp.c ****       err_fn = pcb->errf;
 2403              		.loc 1 966 0
 2404 0324 FB69     		ldr	r3, [r7, #28]
 2405 0326 D3F88C30 		ldr	r3, [r3, #140]
 2406 032a FB60     		str	r3, [r7, #12]
 967:../lwip-1.4.1/src/core/tcp.c ****       err_arg = pcb->callback_arg;
 2407              		.loc 1 967 0
 2408 032c FB69     		ldr	r3, [r7, #28]
 2409 032e 1B69     		ldr	r3, [r3, #16]
 2410 0330 BB60     		str	r3, [r7, #8]
 968:../lwip-1.4.1/src/core/tcp.c ****       pcb2 = pcb;
 2411              		.loc 1 968 0
 2412 0332 FB69     		ldr	r3, [r7, #28]
 2413 0334 7B60     		str	r3, [r7, #4]
 969:../lwip-1.4.1/src/core/tcp.c ****       pcb = pcb->next;
 2414              		.loc 1 969 0
 2415 0336 FB69     		ldr	r3, [r7, #28]
 2416 0338 DB68     		ldr	r3, [r3, #12]
 2417 033a FB61     		str	r3, [r7, #28]
 970:../lwip-1.4.1/src/core/tcp.c ****       memp_free(MEMP_TCP_PCB, pcb2);
 2418              		.loc 1 970 0
 2419 033c 0220     		movs	r0, #2
 2420 033e 7968     		ldr	r1, [r7, #4]
 2421 0340 FFF7FEFF 		bl	memp_free
 971:../lwip-1.4.1/src/core/tcp.c **** 
 972:../lwip-1.4.1/src/core/tcp.c ****       tcp_active_pcbs_changed = 0;
 2422              		.loc 1 972 0
 2423 0344 454B     		ldr	r3, .L169+16
 2424 0346 0022     		movs	r2, #0
 2425 0348 1A70     		strb	r2, [r3]
 973:../lwip-1.4.1/src/core/tcp.c ****       TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 2426              		.loc 1 973 0
 2427 034a FB68     		ldr	r3, [r7, #12]
 2428 034c 002B     		cmp	r3, #0
 2429 034e 04D0     		beq	.L155
 2430              		.loc 1 973 0 is_stmt 0 discriminator 1
 2431 0350 FB68     		ldr	r3, [r7, #12]
 2432 0352 B868     		ldr	r0, [r7, #8]
 2433 0354 6FF00901 		mvn	r1, #9
 2434 0358 9847     		blx	r3
 2435              	.L155:
 974:../lwip-1.4.1/src/core/tcp.c ****       if (tcp_active_pcbs_changed) {
 2436              		.loc 1 974 0 is_stmt 1
 2437 035a 404B     		ldr	r3, .L169+16
 2438 035c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2439 035e 002B     		cmp	r3, #0
 2440 0360 00D0     		beq	.L156
 975:../lwip-1.4.1/src/core/tcp.c ****         goto tcp_slowtmr_start;
 2441              		.loc 1 975 0
 2442 0362 5DE6     		b	.L132
 2443              	.L156:
 2444              	.LBE4:
 2445 0364 35E0     		b	.L133
 2446              	.L151:
 976:../lwip-1.4.1/src/core/tcp.c ****       }
 977:../lwip-1.4.1/src/core/tcp.c ****     } else {
 978:../lwip-1.4.1/src/core/tcp.c ****       /* get the 'next' element now and work with 'prev' below (in case of abort) */
 979:../lwip-1.4.1/src/core/tcp.c ****       prev = pcb;
 2447              		.loc 1 979 0
 2448 0366 FB69     		ldr	r3, [r7, #28]
 2449 0368 BB61     		str	r3, [r7, #24]
 980:../lwip-1.4.1/src/core/tcp.c ****       pcb = pcb->next;
 2450              		.loc 1 980 0
 2451 036a FB69     		ldr	r3, [r7, #28]
 2452 036c DB68     		ldr	r3, [r3, #12]
 2453 036e FB61     		str	r3, [r7, #28]
 981:../lwip-1.4.1/src/core/tcp.c **** 
 982:../lwip-1.4.1/src/core/tcp.c ****       /* We check if we should poll the connection. */
 983:../lwip-1.4.1/src/core/tcp.c ****       ++prev->polltmr;
 2454              		.loc 1 983 0
 2455 0370 BB69     		ldr	r3, [r7, #24]
 2456 0372 DB7F     		ldrb	r3, [r3, #31]	@ zero_extendqisi2
 2457 0374 0133     		adds	r3, r3, #1
 2458 0376 DAB2     		uxtb	r2, r3
 2459 0378 BB69     		ldr	r3, [r7, #24]
 2460 037a DA77     		strb	r2, [r3, #31]
 984:../lwip-1.4.1/src/core/tcp.c ****       if (prev->polltmr >= prev->pollinterval) {
 2461              		.loc 1 984 0
 2462 037c BB69     		ldr	r3, [r7, #24]
 2463 037e DA7F     		ldrb	r2, [r3, #31]	@ zero_extendqisi2
 2464 0380 BB69     		ldr	r3, [r7, #24]
 2465 0382 93F82030 		ldrb	r3, [r3, #32]	@ zero_extendqisi2
 2466 0386 9A42     		cmp	r2, r3
 2467 0388 23D3     		bcc	.L133
 985:../lwip-1.4.1/src/core/tcp.c ****         prev->polltmr = 0;
 2468              		.loc 1 985 0
 2469 038a BB69     		ldr	r3, [r7, #24]
 2470 038c 0022     		movs	r2, #0
 2471 038e DA77     		strb	r2, [r3, #31]
 986:../lwip-1.4.1/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
 987:../lwip-1.4.1/src/core/tcp.c ****         tcp_active_pcbs_changed = 0;
 2472              		.loc 1 987 0
 2473 0390 324B     		ldr	r3, .L169+16
 2474 0392 0022     		movs	r2, #0
 2475 0394 1A70     		strb	r2, [r3]
 988:../lwip-1.4.1/src/core/tcp.c ****         TCP_EVENT_POLL(prev, err);
 2476              		.loc 1 988 0
 2477 0396 BB69     		ldr	r3, [r7, #24]
 2478 0398 D3F88830 		ldr	r3, [r3, #136]
 2479 039c 002B     		cmp	r3, #0
 2480 039e 0AD0     		beq	.L157
 2481              		.loc 1 988 0 is_stmt 0 discriminator 1
 2482 03a0 BB69     		ldr	r3, [r7, #24]
 2483 03a2 D3F88830 		ldr	r3, [r3, #136]
 2484 03a6 BA69     		ldr	r2, [r7, #24]
 2485 03a8 1269     		ldr	r2, [r2, #16]
 2486 03aa 1046     		mov	r0, r2
 2487 03ac B969     		ldr	r1, [r7, #24]
 2488 03ae 9847     		blx	r3
 2489 03b0 0346     		mov	r3, r0
 2490 03b2 7B75     		strb	r3, [r7, #21]
 2491 03b4 01E0     		b	.L158
 2492              	.L157:
 2493              		.loc 1 988 0 discriminator 2
 2494 03b6 0023     		movs	r3, #0
 2495 03b8 7B75     		strb	r3, [r7, #21]
 2496              	.L158:
 989:../lwip-1.4.1/src/core/tcp.c ****         if (tcp_active_pcbs_changed) {
 2497              		.loc 1 989 0 is_stmt 1
 2498 03ba 284B     		ldr	r3, .L169+16
 2499 03bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2500 03be 002B     		cmp	r3, #0
 2501 03c0 00D0     		beq	.L159
 990:../lwip-1.4.1/src/core/tcp.c ****           goto tcp_slowtmr_start;
 2502              		.loc 1 990 0
 2503 03c2 2DE6     		b	.L132
 2504              	.L159:
 991:../lwip-1.4.1/src/core/tcp.c ****         }
 992:../lwip-1.4.1/src/core/tcp.c ****         /* if err == ERR_ABRT, 'prev' is already deallocated */
 993:../lwip-1.4.1/src/core/tcp.c ****         if (err == ERR_OK) {
 2505              		.loc 1 993 0
 2506 03c4 97F91530 		ldrsb	r3, [r7, #21]
 2507 03c8 002B     		cmp	r3, #0
 2508 03ca 02D1     		bne	.L133
 994:../lwip-1.4.1/src/core/tcp.c ****           tcp_output(prev);
 2509              		.loc 1 994 0
 2510 03cc B869     		ldr	r0, [r7, #24]
 2511 03ce FFF7FEFF 		bl	tcp_output
 2512              	.L133:
 807:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
 2513              		.loc 1 807 0
 2514 03d2 FB69     		ldr	r3, [r7, #28]
 2515 03d4 002B     		cmp	r3, #0
 2516 03d6 7FF429AE 		bne	.L160
 995:../lwip-1.4.1/src/core/tcp.c ****         }
 996:../lwip-1.4.1/src/core/tcp.c ****       }
 997:../lwip-1.4.1/src/core/tcp.c ****     }
 998:../lwip-1.4.1/src/core/tcp.c ****   }
 999:../lwip-1.4.1/src/core/tcp.c **** 
1000:../lwip-1.4.1/src/core/tcp.c ****   
1001:../lwip-1.4.1/src/core/tcp.c ****   /* Steps through all of the TIME-WAIT PCBs. */
1002:../lwip-1.4.1/src/core/tcp.c ****   prev = NULL;
 2517              		.loc 1 1002 0
 2518 03da 0023     		movs	r3, #0
 2519 03dc BB61     		str	r3, [r7, #24]
1003:../lwip-1.4.1/src/core/tcp.c ****   pcb = tcp_tw_pcbs;
 2520              		.loc 1 1003 0
 2521 03de 204B     		ldr	r3, .L169+20
 2522 03e0 1B68     		ldr	r3, [r3]
 2523 03e2 FB61     		str	r3, [r7, #28]
1004:../lwip-1.4.1/src/core/tcp.c ****   while (pcb != NULL) {
 2524              		.loc 1 1004 0
 2525 03e4 2CE0     		b	.L161
 2526              	.L166:
1005:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
1006:../lwip-1.4.1/src/core/tcp.c ****     pcb_remove = 0;
 2527              		.loc 1 1006 0
 2528 03e6 0023     		movs	r3, #0
 2529 03e8 FB75     		strb	r3, [r7, #23]
1007:../lwip-1.4.1/src/core/tcp.c **** 
1008:../lwip-1.4.1/src/core/tcp.c ****     /* Check if this PCB has stayed long enough in TIME-WAIT */
1009:../lwip-1.4.1/src/core/tcp.c ****     if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 2530              		.loc 1 1009 0
 2531 03ea 184B     		ldr	r3, .L169
 2532 03ec 1A68     		ldr	r2, [r3]
 2533 03ee FB69     		ldr	r3, [r7, #28]
 2534 03f0 5B6A     		ldr	r3, [r3, #36]
 2535 03f2 D31A     		subs	r3, r2, r3
 2536 03f4 F02B     		cmp	r3, #240
 2537 03f6 02D9     		bls	.L162
1010:../lwip-1.4.1/src/core/tcp.c ****       ++pcb_remove;
 2538              		.loc 1 1010 0
 2539 03f8 FB7D     		ldrb	r3, [r7, #23]
 2540 03fa 0133     		adds	r3, r3, #1
 2541 03fc FB75     		strb	r3, [r7, #23]
 2542              	.L162:
1011:../lwip-1.4.1/src/core/tcp.c ****     }
1012:../lwip-1.4.1/src/core/tcp.c ****     
1013:../lwip-1.4.1/src/core/tcp.c **** 
1014:../lwip-1.4.1/src/core/tcp.c **** 
1015:../lwip-1.4.1/src/core/tcp.c ****     /* If the PCB should be removed, do it. */
1016:../lwip-1.4.1/src/core/tcp.c ****     if (pcb_remove) {
 2543              		.loc 1 1016 0
 2544 03fe FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2545 0400 002B     		cmp	r3, #0
 2546 0402 18D0     		beq	.L163
 2547              	.LBB5:
1017:../lwip-1.4.1/src/core/tcp.c ****       struct tcp_pcb *pcb2;
1018:../lwip-1.4.1/src/core/tcp.c ****       tcp_pcb_purge(pcb);
 2548              		.loc 1 1018 0
 2549 0404 F869     		ldr	r0, [r7, #28]
 2550 0406 FFF7FEFF 		bl	tcp_pcb_purge
1019:../lwip-1.4.1/src/core/tcp.c ****       /* Remove PCB from tcp_tw_pcbs list. */
1020:../lwip-1.4.1/src/core/tcp.c ****       if (prev != NULL) {
 2551              		.loc 1 1020 0
 2552 040a BB69     		ldr	r3, [r7, #24]
 2553 040c 002B     		cmp	r3, #0
 2554 040e 04D0     		beq	.L164
1021:../lwip-1.4.1/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
1022:../lwip-1.4.1/src/core/tcp.c ****         prev->next = pcb->next;
 2555              		.loc 1 1022 0
 2556 0410 FB69     		ldr	r3, [r7, #28]
 2557 0412 DA68     		ldr	r2, [r3, #12]
 2558 0414 BB69     		ldr	r3, [r7, #24]
 2559 0416 DA60     		str	r2, [r3, #12]
 2560 0418 03E0     		b	.L165
 2561              	.L164:
1023:../lwip-1.4.1/src/core/tcp.c ****       } else {
1024:../lwip-1.4.1/src/core/tcp.c ****         /* This PCB was the first. */
1025:../lwip-1.4.1/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
1026:../lwip-1.4.1/src/core/tcp.c ****         tcp_tw_pcbs = pcb->next;
 2562              		.loc 1 1026 0
 2563 041a FB69     		ldr	r3, [r7, #28]
 2564 041c DB68     		ldr	r3, [r3, #12]
 2565 041e 104A     		ldr	r2, .L169+20
 2566 0420 1360     		str	r3, [r2]
 2567              	.L165:
1027:../lwip-1.4.1/src/core/tcp.c ****       }
1028:../lwip-1.4.1/src/core/tcp.c ****       pcb2 = pcb;
 2568              		.loc 1 1028 0
 2569 0422 FB69     		ldr	r3, [r7, #28]
 2570 0424 3B60     		str	r3, [r7]
1029:../lwip-1.4.1/src/core/tcp.c ****       pcb = pcb->next;
 2571              		.loc 1 1029 0
 2572 0426 FB69     		ldr	r3, [r7, #28]
 2573 0428 DB68     		ldr	r3, [r3, #12]
 2574 042a FB61     		str	r3, [r7, #28]
1030:../lwip-1.4.1/src/core/tcp.c ****       memp_free(MEMP_TCP_PCB, pcb2);
 2575              		.loc 1 1030 0
 2576 042c 0220     		movs	r0, #2
 2577 042e 3968     		ldr	r1, [r7]
 2578 0430 FFF7FEFF 		bl	memp_free
 2579              	.LBE5:
 2580 0434 04E0     		b	.L161
 2581              	.L163:
1031:../lwip-1.4.1/src/core/tcp.c ****     } else {
1032:../lwip-1.4.1/src/core/tcp.c ****       prev = pcb;
 2582              		.loc 1 1032 0
 2583 0436 FB69     		ldr	r3, [r7, #28]
 2584 0438 BB61     		str	r3, [r7, #24]
1033:../lwip-1.4.1/src/core/tcp.c ****       pcb = pcb->next;
 2585              		.loc 1 1033 0
 2586 043a FB69     		ldr	r3, [r7, #28]
 2587 043c DB68     		ldr	r3, [r3, #12]
 2588 043e FB61     		str	r3, [r7, #28]
 2589              	.L161:
1004:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 2590              		.loc 1 1004 0
 2591 0440 FB69     		ldr	r3, [r7, #28]
 2592 0442 002B     		cmp	r3, #0
 2593 0444 CFD1     		bne	.L166
1034:../lwip-1.4.1/src/core/tcp.c ****     }
1035:../lwip-1.4.1/src/core/tcp.c ****   }
1036:../lwip-1.4.1/src/core/tcp.c **** }
 2594              		.loc 1 1036 0
 2595 0446 2037     		adds	r7, r7, #32
 2596              		.cfi_def_cfa_offset 16
 2597 0448 BD46     		mov	sp, r7
 2598              		.cfi_def_cfa_register 13
 2599              		@ sp needed
 2600 044a B0BD     		pop	{r4, r5, r7, pc}
 2601              	.L170:
 2602              		.align	2
 2603              	.L169:
 2604 044c 00000000 		.word	tcp_ticks
 2605 0450 F8240100 		.word	75000
 2606 0454 D34D6210 		.word	274877907
 2607 0458 00000000 		.word	tcp_active_pcbs
 2608 045c 00000000 		.word	tcp_active_pcbs_changed
 2609 0460 00000000 		.word	tcp_tw_pcbs
 2610              		.cfi_endproc
 2611              	.LFE14:
 2613              		.section	.text.tcp_fasttmr,"ax",%progbits
 2614              		.align	2
 2615              		.global	tcp_fasttmr
 2616              		.thumb
 2617              		.thumb_func
 2619              	tcp_fasttmr:
 2620              	.LFB15:
1037:../lwip-1.4.1/src/core/tcp.c **** 
1038:../lwip-1.4.1/src/core/tcp.c **** /**
1039:../lwip-1.4.1/src/core/tcp.c ****  * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously
1040:../lwip-1.4.1/src/core/tcp.c ****  * "refused" by upper layer (application) and sends delayed ACKs.
1041:../lwip-1.4.1/src/core/tcp.c ****  *
1042:../lwip-1.4.1/src/core/tcp.c ****  * Automatically called from tcp_tmr().
1043:../lwip-1.4.1/src/core/tcp.c ****  */
1044:../lwip-1.4.1/src/core/tcp.c **** void
1045:../lwip-1.4.1/src/core/tcp.c **** tcp_fasttmr(void)
1046:../lwip-1.4.1/src/core/tcp.c **** {
 2621              		.loc 1 1046 0
 2622              		.cfi_startproc
 2623              		@ args = 0, pretend = 0, frame = 8
 2624              		@ frame_needed = 1, uses_anonymous_args = 0
 2625 0000 80B5     		push	{r7, lr}
 2626              		.cfi_def_cfa_offset 8
 2627              		.cfi_offset 7, -8
 2628              		.cfi_offset 14, -4
 2629 0002 82B0     		sub	sp, sp, #8
 2630              		.cfi_def_cfa_offset 16
 2631 0004 00AF     		add	r7, sp, #0
 2632              		.cfi_def_cfa_register 7
1047:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb *pcb;
1048:../lwip-1.4.1/src/core/tcp.c **** 
1049:../lwip-1.4.1/src/core/tcp.c ****   ++tcp_timer_ctr;
 2633              		.loc 1 1049 0
 2634 0006 234B     		ldr	r3, .L177
 2635 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2636 000a 0133     		adds	r3, r3, #1
 2637 000c DAB2     		uxtb	r2, r3
 2638 000e 214B     		ldr	r3, .L177
 2639 0010 1A70     		strb	r2, [r3]
 2640              	.L172:
1050:../lwip-1.4.1/src/core/tcp.c **** 
1051:../lwip-1.4.1/src/core/tcp.c **** tcp_fasttmr_start:
1052:../lwip-1.4.1/src/core/tcp.c ****   pcb = tcp_active_pcbs;
 2641              		.loc 1 1052 0
 2642 0012 214B     		ldr	r3, .L177+4
 2643 0014 1B68     		ldr	r3, [r3]
 2644 0016 7B60     		str	r3, [r7, #4]
1053:../lwip-1.4.1/src/core/tcp.c **** 
1054:../lwip-1.4.1/src/core/tcp.c ****   while(pcb != NULL) {
 2645              		.loc 1 1054 0
 2646 0018 36E0     		b	.L173
 2647              	.L176:
1055:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->last_timer != tcp_timer_ctr) {
 2648              		.loc 1 1055 0
 2649 001a 7B68     		ldr	r3, [r7, #4]
 2650 001c 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 2651 0020 1C4B     		ldr	r3, .L177
 2652 0022 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2653 0024 9A42     		cmp	r2, r3
 2654 0026 2FD0     		beq	.L173
 2655              	.LBB6:
1056:../lwip-1.4.1/src/core/tcp.c ****       struct tcp_pcb *next;
1057:../lwip-1.4.1/src/core/tcp.c ****       pcb->last_timer = tcp_timer_ctr;
 2656              		.loc 1 1057 0
 2657 0028 1A4B     		ldr	r3, .L177
 2658 002a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2659 002c 7B68     		ldr	r3, [r7, #4]
 2660 002e 83F82120 		strb	r2, [r3, #33]
1058:../lwip-1.4.1/src/core/tcp.c ****       /* send delayed ACKs */
1059:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->flags & TF_ACK_DELAY) {
 2661              		.loc 1 1059 0
 2662 0032 7B68     		ldr	r3, [r7, #4]
 2663 0034 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 2664 0036 03F00103 		and	r3, r3, #1
 2665 003a 002B     		cmp	r3, #0
 2666 003c 10D0     		beq	.L174
1060:../lwip-1.4.1/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
1061:../lwip-1.4.1/src/core/tcp.c ****         tcp_ack_now(pcb);
 2667              		.loc 1 1061 0
 2668 003e 7B68     		ldr	r3, [r7, #4]
 2669 0040 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 2670 0042 43F00203 		orr	r3, r3, #2
 2671 0046 DAB2     		uxtb	r2, r3
 2672 0048 7B68     		ldr	r3, [r7, #4]
 2673 004a 9A77     		strb	r2, [r3, #30]
1062:../lwip-1.4.1/src/core/tcp.c ****         tcp_output(pcb);
 2674              		.loc 1 1062 0
 2675 004c 7868     		ldr	r0, [r7, #4]
 2676 004e FFF7FEFF 		bl	tcp_output
1063:../lwip-1.4.1/src/core/tcp.c ****         pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 2677              		.loc 1 1063 0
 2678 0052 7B68     		ldr	r3, [r7, #4]
 2679 0054 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 2680 0056 23F00303 		bic	r3, r3, #3
 2681 005a DAB2     		uxtb	r2, r3
 2682 005c 7B68     		ldr	r3, [r7, #4]
 2683 005e 9A77     		strb	r2, [r3, #30]
 2684              	.L174:
1064:../lwip-1.4.1/src/core/tcp.c ****       }
1065:../lwip-1.4.1/src/core/tcp.c **** 
1066:../lwip-1.4.1/src/core/tcp.c ****       next = pcb->next;
 2685              		.loc 1 1066 0
 2686 0060 7B68     		ldr	r3, [r7, #4]
 2687 0062 DB68     		ldr	r3, [r3, #12]
 2688 0064 3B60     		str	r3, [r7]
1067:../lwip-1.4.1/src/core/tcp.c **** 
1068:../lwip-1.4.1/src/core/tcp.c ****       /* If there is data which was previously "refused" by upper layer */
1069:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->refused_data != NULL) {
 2689              		.loc 1 1069 0
 2690 0066 7B68     		ldr	r3, [r7, #4]
 2691 0068 9B6F     		ldr	r3, [r3, #120]
 2692 006a 002B     		cmp	r3, #0
 2693 006c 0AD0     		beq	.L175
1070:../lwip-1.4.1/src/core/tcp.c ****         tcp_active_pcbs_changed = 0;
 2694              		.loc 1 1070 0
 2695 006e 0B4B     		ldr	r3, .L177+8
 2696 0070 0022     		movs	r2, #0
 2697 0072 1A70     		strb	r2, [r3]
1071:../lwip-1.4.1/src/core/tcp.c ****         tcp_process_refused_data(pcb);
 2698              		.loc 1 1071 0
 2699 0074 7868     		ldr	r0, [r7, #4]
 2700 0076 FFF7FEFF 		bl	tcp_process_refused_data
1072:../lwip-1.4.1/src/core/tcp.c ****         if (tcp_active_pcbs_changed) {
 2701              		.loc 1 1072 0
 2702 007a 084B     		ldr	r3, .L177+8
 2703 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2704 007e 002B     		cmp	r3, #0
 2705 0080 00D0     		beq	.L175
1073:../lwip-1.4.1/src/core/tcp.c ****           /* application callback has changed the pcb list: restart the loop */
1074:../lwip-1.4.1/src/core/tcp.c ****           goto tcp_fasttmr_start;
 2706              		.loc 1 1074 0
 2707 0082 C6E7     		b	.L172
 2708              	.L175:
1075:../lwip-1.4.1/src/core/tcp.c ****         }
1076:../lwip-1.4.1/src/core/tcp.c ****       }
1077:../lwip-1.4.1/src/core/tcp.c ****       pcb = next;
 2709              		.loc 1 1077 0
 2710 0084 3B68     		ldr	r3, [r7]
 2711 0086 7B60     		str	r3, [r7, #4]
 2712              	.L173:
 2713              	.LBE6:
1054:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->last_timer != tcp_timer_ctr) {
 2714              		.loc 1 1054 0
 2715 0088 7B68     		ldr	r3, [r7, #4]
 2716 008a 002B     		cmp	r3, #0
 2717 008c C5D1     		bne	.L176
1078:../lwip-1.4.1/src/core/tcp.c ****     }
1079:../lwip-1.4.1/src/core/tcp.c ****   }
1080:../lwip-1.4.1/src/core/tcp.c **** }
 2718              		.loc 1 1080 0
 2719 008e 0837     		adds	r7, r7, #8
 2720              		.cfi_def_cfa_offset 8
 2721 0090 BD46     		mov	sp, r7
 2722              		.cfi_def_cfa_register 13
 2723              		@ sp needed
 2724 0092 80BD     		pop	{r7, pc}
 2725              	.L178:
 2726              		.align	2
 2727              	.L177:
 2728 0094 01000000 		.word	tcp_timer_ctr
 2729 0098 00000000 		.word	tcp_active_pcbs
 2730 009c 00000000 		.word	tcp_active_pcbs_changed
 2731              		.cfi_endproc
 2732              	.LFE15:
 2734              		.section	.text.tcp_process_refused_data,"ax",%progbits
 2735              		.align	2
 2736              		.global	tcp_process_refused_data
 2737              		.thumb
 2738              		.thumb_func
 2740              	tcp_process_refused_data:
 2741              	.LFB16:
1081:../lwip-1.4.1/src/core/tcp.c **** 
1082:../lwip-1.4.1/src/core/tcp.c **** /** Pass pcb->refused_data to the recv callback */
1083:../lwip-1.4.1/src/core/tcp.c **** err_t
1084:../lwip-1.4.1/src/core/tcp.c **** tcp_process_refused_data(struct tcp_pcb *pcb)
1085:../lwip-1.4.1/src/core/tcp.c **** {
 2742              		.loc 1 1085 0
 2743              		.cfi_startproc
 2744              		@ args = 0, pretend = 0, frame = 16
 2745              		@ frame_needed = 1, uses_anonymous_args = 0
 2746 0000 90B5     		push	{r4, r7, lr}
 2747              		.cfi_def_cfa_offset 12
 2748              		.cfi_offset 4, -12
 2749              		.cfi_offset 7, -8
 2750              		.cfi_offset 14, -4
 2751 0002 85B0     		sub	sp, sp, #20
 2752              		.cfi_def_cfa_offset 32
 2753 0004 00AF     		add	r7, sp, #0
 2754              		.cfi_def_cfa_register 7
 2755 0006 7860     		str	r0, [r7, #4]
1086:../lwip-1.4.1/src/core/tcp.c ****   err_t err;
1087:../lwip-1.4.1/src/core/tcp.c ****   u8_t refused_flags = pcb->refused_data->flags;
 2756              		.loc 1 1087 0
 2757 0008 7B68     		ldr	r3, [r7, #4]
 2758 000a 9B6F     		ldr	r3, [r3, #120]
 2759 000c 5B7B     		ldrb	r3, [r3, #13]
 2760 000e BB73     		strb	r3, [r7, #14]
1088:../lwip-1.4.1/src/core/tcp.c ****   /* set pcb->refused_data to NULL in case the callback frees it and then
1089:../lwip-1.4.1/src/core/tcp.c ****      closes the pcb */
1090:../lwip-1.4.1/src/core/tcp.c ****   struct pbuf *refused_data = pcb->refused_data;
 2761              		.loc 1 1090 0
 2762 0010 7B68     		ldr	r3, [r7, #4]
 2763 0012 9B6F     		ldr	r3, [r3, #120]
 2764 0014 BB60     		str	r3, [r7, #8]
1091:../lwip-1.4.1/src/core/tcp.c ****   pcb->refused_data = NULL;
 2765              		.loc 1 1091 0
 2766 0016 7B68     		ldr	r3, [r7, #4]
 2767 0018 0022     		movs	r2, #0
 2768 001a 9A67     		str	r2, [r3, #120]
1092:../lwip-1.4.1/src/core/tcp.c ****   /* Notify again application with data previously received. */
1093:../lwip-1.4.1/src/core/tcp.c ****   LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
1094:../lwip-1.4.1/src/core/tcp.c ****   TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 2769              		.loc 1 1094 0
 2770 001c 7B68     		ldr	r3, [r7, #4]
 2771 001e D3F88030 		ldr	r3, [r3, #128]
 2772 0022 002B     		cmp	r3, #0
 2773 0024 0CD0     		beq	.L180
 2774              		.loc 1 1094 0 is_stmt 0 discriminator 1
 2775 0026 7B68     		ldr	r3, [r7, #4]
 2776 0028 D3F88040 		ldr	r4, [r3, #128]
 2777 002c 7B68     		ldr	r3, [r7, #4]
 2778 002e 1B69     		ldr	r3, [r3, #16]
 2779 0030 1846     		mov	r0, r3
 2780 0032 7968     		ldr	r1, [r7, #4]
 2781 0034 BA68     		ldr	r2, [r7, #8]
 2782 0036 0023     		movs	r3, #0
 2783 0038 A047     		blx	r4
 2784 003a 0346     		mov	r3, r0
 2785 003c FB73     		strb	r3, [r7, #15]
 2786 003e 07E0     		b	.L181
 2787              	.L180:
 2788              		.loc 1 1094 0 discriminator 2
 2789 0040 0020     		movs	r0, #0
 2790 0042 7968     		ldr	r1, [r7, #4]
 2791 0044 BA68     		ldr	r2, [r7, #8]
 2792 0046 0023     		movs	r3, #0
 2793 0048 FFF7FEFF 		bl	tcp_recv_null
 2794 004c 0346     		mov	r3, r0
 2795 004e FB73     		strb	r3, [r7, #15]
 2796              	.L181:
1095:../lwip-1.4.1/src/core/tcp.c ****   if (err == ERR_OK) {
 2797              		.loc 1 1095 0 is_stmt 1
 2798 0050 97F90F30 		ldrsb	r3, [r7, #15]
 2799 0054 002B     		cmp	r3, #0
 2800 0056 2BD1     		bne	.L182
1096:../lwip-1.4.1/src/core/tcp.c ****     /* did refused_data include a FIN? */
1097:../lwip-1.4.1/src/core/tcp.c ****     if (refused_flags & PBUF_FLAG_TCP_FIN) {
 2801              		.loc 1 1097 0
 2802 0058 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 2803 005a 03F02003 		and	r3, r3, #32
 2804 005e 002B     		cmp	r3, #0
 2805 0060 30D0     		beq	.L183
1098:../lwip-1.4.1/src/core/tcp.c ****       /* correct rcv_wnd as the application won't call tcp_recved()
1099:../lwip-1.4.1/src/core/tcp.c ****          for the FIN's seqno */
1100:../lwip-1.4.1/src/core/tcp.c ****       if (pcb->rcv_wnd != TCP_WND) {
 2806              		.loc 1 1100 0
 2807 0062 7B68     		ldr	r3, [r7, #4]
 2808 0064 9B8D     		ldrh	r3, [r3, #44]
 2809 0066 40F66832 		movw	r2, #2920
 2810 006a 9342     		cmp	r3, r2
 2811 006c 05D0     		beq	.L184
1101:../lwip-1.4.1/src/core/tcp.c ****         pcb->rcv_wnd++;
 2812              		.loc 1 1101 0
 2813 006e 7B68     		ldr	r3, [r7, #4]
 2814 0070 9B8D     		ldrh	r3, [r3, #44]
 2815 0072 0133     		adds	r3, r3, #1
 2816 0074 9AB2     		uxth	r2, r3
 2817 0076 7B68     		ldr	r3, [r7, #4]
 2818 0078 9A85     		strh	r2, [r3, #44]	@ movhi
 2819              	.L184:
1102:../lwip-1.4.1/src/core/tcp.c ****       }
1103:../lwip-1.4.1/src/core/tcp.c ****       TCP_EVENT_CLOSED(pcb, err);
 2820              		.loc 1 1103 0
 2821 007a 7B68     		ldr	r3, [r7, #4]
 2822 007c D3F88030 		ldr	r3, [r3, #128]
 2823 0080 002B     		cmp	r3, #0
 2824 0082 0CD0     		beq	.L185
 2825              		.loc 1 1103 0 is_stmt 0 discriminator 1
 2826 0084 7B68     		ldr	r3, [r7, #4]
 2827 0086 D3F88040 		ldr	r4, [r3, #128]
 2828 008a 7B68     		ldr	r3, [r7, #4]
 2829 008c 1B69     		ldr	r3, [r3, #16]
 2830 008e 1846     		mov	r0, r3
 2831 0090 7968     		ldr	r1, [r7, #4]
 2832 0092 0022     		movs	r2, #0
 2833 0094 0023     		movs	r3, #0
 2834 0096 A047     		blx	r4
 2835 0098 0346     		mov	r3, r0
 2836 009a FB73     		strb	r3, [r7, #15]
 2837 009c 01E0     		b	.L186
 2838              	.L185:
 2839              		.loc 1 1103 0 discriminator 2
 2840 009e 0023     		movs	r3, #0
 2841 00a0 FB73     		strb	r3, [r7, #15]
 2842              	.L186:
1104:../lwip-1.4.1/src/core/tcp.c ****       if (err == ERR_ABRT) {
 2843              		.loc 1 1104 0 is_stmt 1
 2844 00a2 97F90F30 		ldrsb	r3, [r7, #15]
 2845 00a6 13F10A0F 		cmn	r3, #10
 2846 00aa 0BD1     		bne	.L183
1105:../lwip-1.4.1/src/core/tcp.c ****         return ERR_ABRT;
 2847              		.loc 1 1105 0
 2848 00ac F623     		movs	r3, #246
 2849 00ae 0AE0     		b	.L187
 2850              	.L182:
1106:../lwip-1.4.1/src/core/tcp.c ****       }
1107:../lwip-1.4.1/src/core/tcp.c ****     }
1108:../lwip-1.4.1/src/core/tcp.c ****   } else if (err == ERR_ABRT) {
 2851              		.loc 1 1108 0
 2852 00b0 97F90F30 		ldrsb	r3, [r7, #15]
 2853 00b4 13F10A0F 		cmn	r3, #10
 2854 00b8 01D1     		bne	.L188
1109:../lwip-1.4.1/src/core/tcp.c ****     /* if err == ERR_ABRT, 'pcb' is already deallocated */
1110:../lwip-1.4.1/src/core/tcp.c ****     /* Drop incoming packets because pcb is "full" (only if the incoming
1111:../lwip-1.4.1/src/core/tcp.c ****        segment contains data). */
1112:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
1113:../lwip-1.4.1/src/core/tcp.c ****     return ERR_ABRT;
 2855              		.loc 1 1113 0
 2856 00ba F623     		movs	r3, #246
 2857 00bc 03E0     		b	.L187
 2858              	.L188:
1114:../lwip-1.4.1/src/core/tcp.c ****   } else {
1115:../lwip-1.4.1/src/core/tcp.c ****     /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
1116:../lwip-1.4.1/src/core/tcp.c ****     pcb->refused_data = refused_data;
 2859              		.loc 1 1116 0
 2860 00be 7B68     		ldr	r3, [r7, #4]
 2861 00c0 BA68     		ldr	r2, [r7, #8]
 2862 00c2 9A67     		str	r2, [r3, #120]
 2863              	.L183:
1117:../lwip-1.4.1/src/core/tcp.c ****   }
1118:../lwip-1.4.1/src/core/tcp.c ****   return ERR_OK;
 2864              		.loc 1 1118 0
 2865 00c4 0023     		movs	r3, #0
 2866              	.L187:
 2867 00c6 5BB2     		sxtb	r3, r3
1119:../lwip-1.4.1/src/core/tcp.c **** }
 2868              		.loc 1 1119 0
 2869 00c8 1846     		mov	r0, r3
 2870 00ca 1437     		adds	r7, r7, #20
 2871              		.cfi_def_cfa_offset 12
 2872 00cc BD46     		mov	sp, r7
 2873              		.cfi_def_cfa_register 13
 2874              		@ sp needed
 2875 00ce 90BD     		pop	{r4, r7, pc}
 2876              		.cfi_endproc
 2877              	.LFE16:
 2879              		.section	.text.tcp_segs_free,"ax",%progbits
 2880              		.align	2
 2881              		.global	tcp_segs_free
 2882              		.thumb
 2883              		.thumb_func
 2885              	tcp_segs_free:
 2886              	.LFB17:
1120:../lwip-1.4.1/src/core/tcp.c **** 
1121:../lwip-1.4.1/src/core/tcp.c **** /**
1122:../lwip-1.4.1/src/core/tcp.c ****  * Deallocates a list of TCP segments (tcp_seg structures).
1123:../lwip-1.4.1/src/core/tcp.c ****  *
1124:../lwip-1.4.1/src/core/tcp.c ****  * @param seg tcp_seg list of TCP segments to free
1125:../lwip-1.4.1/src/core/tcp.c ****  */
1126:../lwip-1.4.1/src/core/tcp.c **** void
1127:../lwip-1.4.1/src/core/tcp.c **** tcp_segs_free(struct tcp_seg *seg)
1128:../lwip-1.4.1/src/core/tcp.c **** {
 2887              		.loc 1 1128 0
 2888              		.cfi_startproc
 2889              		@ args = 0, pretend = 0, frame = 16
 2890              		@ frame_needed = 1, uses_anonymous_args = 0
 2891 0000 80B5     		push	{r7, lr}
 2892              		.cfi_def_cfa_offset 8
 2893              		.cfi_offset 7, -8
 2894              		.cfi_offset 14, -4
 2895 0002 84B0     		sub	sp, sp, #16
 2896              		.cfi_def_cfa_offset 24
 2897 0004 00AF     		add	r7, sp, #0
 2898              		.cfi_def_cfa_register 7
 2899 0006 7860     		str	r0, [r7, #4]
1129:../lwip-1.4.1/src/core/tcp.c ****   while (seg != NULL) {
 2900              		.loc 1 1129 0
 2901 0008 07E0     		b	.L190
 2902              	.L191:
 2903              	.LBB7:
1130:../lwip-1.4.1/src/core/tcp.c ****     struct tcp_seg *next = seg->next;
 2904              		.loc 1 1130 0
 2905 000a 7B68     		ldr	r3, [r7, #4]
 2906 000c 1B68     		ldr	r3, [r3]
 2907 000e FB60     		str	r3, [r7, #12]
1131:../lwip-1.4.1/src/core/tcp.c ****     tcp_seg_free(seg);
 2908              		.loc 1 1131 0
 2909 0010 7868     		ldr	r0, [r7, #4]
 2910 0012 FFF7FEFF 		bl	tcp_seg_free
1132:../lwip-1.4.1/src/core/tcp.c ****     seg = next;
 2911              		.loc 1 1132 0
 2912 0016 FB68     		ldr	r3, [r7, #12]
 2913 0018 7B60     		str	r3, [r7, #4]
 2914              	.L190:
 2915              	.LBE7:
1129:../lwip-1.4.1/src/core/tcp.c ****     struct tcp_seg *next = seg->next;
 2916              		.loc 1 1129 0
 2917 001a 7B68     		ldr	r3, [r7, #4]
 2918 001c 002B     		cmp	r3, #0
 2919 001e F4D1     		bne	.L191
1133:../lwip-1.4.1/src/core/tcp.c ****   }
1134:../lwip-1.4.1/src/core/tcp.c **** }
 2920              		.loc 1 1134 0
 2921 0020 1037     		adds	r7, r7, #16
 2922              		.cfi_def_cfa_offset 8
 2923 0022 BD46     		mov	sp, r7
 2924              		.cfi_def_cfa_register 13
 2925              		@ sp needed
 2926 0024 80BD     		pop	{r7, pc}
 2927              		.cfi_endproc
 2928              	.LFE17:
 2930 0026 00BF     		.section	.text.tcp_seg_free,"ax",%progbits
 2931              		.align	2
 2932              		.global	tcp_seg_free
 2933              		.thumb
 2934              		.thumb_func
 2936              	tcp_seg_free:
 2937              	.LFB18:
1135:../lwip-1.4.1/src/core/tcp.c **** 
1136:../lwip-1.4.1/src/core/tcp.c **** /**
1137:../lwip-1.4.1/src/core/tcp.c ****  * Frees a TCP segment (tcp_seg structure).
1138:../lwip-1.4.1/src/core/tcp.c ****  *
1139:../lwip-1.4.1/src/core/tcp.c ****  * @param seg single tcp_seg to free
1140:../lwip-1.4.1/src/core/tcp.c ****  */
1141:../lwip-1.4.1/src/core/tcp.c **** void
1142:../lwip-1.4.1/src/core/tcp.c **** tcp_seg_free(struct tcp_seg *seg)
1143:../lwip-1.4.1/src/core/tcp.c **** {
 2938              		.loc 1 1143 0
 2939              		.cfi_startproc
 2940              		@ args = 0, pretend = 0, frame = 8
 2941              		@ frame_needed = 1, uses_anonymous_args = 0
 2942 0000 80B5     		push	{r7, lr}
 2943              		.cfi_def_cfa_offset 8
 2944              		.cfi_offset 7, -8
 2945              		.cfi_offset 14, -4
 2946 0002 82B0     		sub	sp, sp, #8
 2947              		.cfi_def_cfa_offset 16
 2948 0004 00AF     		add	r7, sp, #0
 2949              		.cfi_def_cfa_register 7
 2950 0006 7860     		str	r0, [r7, #4]
1144:../lwip-1.4.1/src/core/tcp.c ****   if (seg != NULL) {
 2951              		.loc 1 1144 0
 2952 0008 7B68     		ldr	r3, [r7, #4]
 2953 000a 002B     		cmp	r3, #0
 2954 000c 0CD0     		beq	.L192
1145:../lwip-1.4.1/src/core/tcp.c ****     if (seg->p != NULL) {
 2955              		.loc 1 1145 0
 2956 000e 7B68     		ldr	r3, [r7, #4]
 2957 0010 5B68     		ldr	r3, [r3, #4]
 2958 0012 002B     		cmp	r3, #0
 2959 0014 04D0     		beq	.L194
1146:../lwip-1.4.1/src/core/tcp.c ****       pbuf_free(seg->p);
 2960              		.loc 1 1146 0
 2961 0016 7B68     		ldr	r3, [r7, #4]
 2962 0018 5B68     		ldr	r3, [r3, #4]
 2963 001a 1846     		mov	r0, r3
 2964 001c FFF7FEFF 		bl	pbuf_free
 2965              	.L194:
1147:../lwip-1.4.1/src/core/tcp.c **** #if TCP_DEBUG
1148:../lwip-1.4.1/src/core/tcp.c ****       seg->p = NULL;
1149:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_DEBUG */
1150:../lwip-1.4.1/src/core/tcp.c ****     }
1151:../lwip-1.4.1/src/core/tcp.c ****     memp_free(MEMP_TCP_SEG, seg);
 2966              		.loc 1 1151 0
 2967 0020 0420     		movs	r0, #4
 2968 0022 7968     		ldr	r1, [r7, #4]
 2969 0024 FFF7FEFF 		bl	memp_free
 2970              	.L192:
1152:../lwip-1.4.1/src/core/tcp.c ****   }
1153:../lwip-1.4.1/src/core/tcp.c **** }
 2971              		.loc 1 1153 0
 2972 0028 0837     		adds	r7, r7, #8
 2973              		.cfi_def_cfa_offset 8
 2974 002a BD46     		mov	sp, r7
 2975              		.cfi_def_cfa_register 13
 2976              		@ sp needed
 2977 002c 80BD     		pop	{r7, pc}
 2978              		.cfi_endproc
 2979              	.LFE18:
 2981 002e 00BF     		.section	.text.tcp_setprio,"ax",%progbits
 2982              		.align	2
 2983              		.global	tcp_setprio
 2984              		.thumb
 2985              		.thumb_func
 2987              	tcp_setprio:
 2988              	.LFB19:
1154:../lwip-1.4.1/src/core/tcp.c **** 
1155:../lwip-1.4.1/src/core/tcp.c **** /**
1156:../lwip-1.4.1/src/core/tcp.c ****  * Sets the priority of a connection.
1157:../lwip-1.4.1/src/core/tcp.c ****  *
1158:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb the tcp_pcb to manipulate
1159:../lwip-1.4.1/src/core/tcp.c ****  * @param prio new priority
1160:../lwip-1.4.1/src/core/tcp.c ****  */
1161:../lwip-1.4.1/src/core/tcp.c **** void
1162:../lwip-1.4.1/src/core/tcp.c **** tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
1163:../lwip-1.4.1/src/core/tcp.c **** {
 2989              		.loc 1 1163 0
 2990              		.cfi_startproc
 2991              		@ args = 0, pretend = 0, frame = 8
 2992              		@ frame_needed = 1, uses_anonymous_args = 0
 2993              		@ link register save eliminated.
 2994 0000 80B4     		push	{r7}
 2995              		.cfi_def_cfa_offset 4
 2996              		.cfi_offset 7, -4
 2997 0002 83B0     		sub	sp, sp, #12
 2998              		.cfi_def_cfa_offset 16
 2999 0004 00AF     		add	r7, sp, #0
 3000              		.cfi_def_cfa_register 7
 3001 0006 7860     		str	r0, [r7, #4]
 3002 0008 0B46     		mov	r3, r1
 3003 000a FB70     		strb	r3, [r7, #3]
1164:../lwip-1.4.1/src/core/tcp.c ****   pcb->prio = prio;
 3004              		.loc 1 1164 0
 3005 000c 7B68     		ldr	r3, [r7, #4]
 3006 000e FA78     		ldrb	r2, [r7, #3]
 3007 0010 5A76     		strb	r2, [r3, #25]
1165:../lwip-1.4.1/src/core/tcp.c **** }
 3008              		.loc 1 1165 0
 3009 0012 0C37     		adds	r7, r7, #12
 3010              		.cfi_def_cfa_offset 4
 3011 0014 BD46     		mov	sp, r7
 3012              		.cfi_def_cfa_register 13
 3013              		@ sp needed
 3014 0016 5DF8047B 		ldr	r7, [sp], #4
 3015              		.cfi_restore 7
 3016              		.cfi_def_cfa_offset 0
 3017 001a 7047     		bx	lr
 3018              		.cfi_endproc
 3019              	.LFE19:
 3021              		.section	.text.tcp_seg_copy,"ax",%progbits
 3022              		.align	2
 3023              		.global	tcp_seg_copy
 3024              		.thumb
 3025              		.thumb_func
 3027              	tcp_seg_copy:
 3028              	.LFB20:
1166:../lwip-1.4.1/src/core/tcp.c **** 
1167:../lwip-1.4.1/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ
1168:../lwip-1.4.1/src/core/tcp.c **** /**
1169:../lwip-1.4.1/src/core/tcp.c ****  * Returns a copy of the given TCP segment.
1170:../lwip-1.4.1/src/core/tcp.c ****  * The pbuf and data are not copied, only the pointers
1171:../lwip-1.4.1/src/core/tcp.c ****  *
1172:../lwip-1.4.1/src/core/tcp.c ****  * @param seg the old tcp_seg
1173:../lwip-1.4.1/src/core/tcp.c ****  * @return a copy of seg
1174:../lwip-1.4.1/src/core/tcp.c ****  */ 
1175:../lwip-1.4.1/src/core/tcp.c **** struct tcp_seg *
1176:../lwip-1.4.1/src/core/tcp.c **** tcp_seg_copy(struct tcp_seg *seg)
1177:../lwip-1.4.1/src/core/tcp.c **** {
 3029              		.loc 1 1177 0
 3030              		.cfi_startproc
 3031              		@ args = 0, pretend = 0, frame = 16
 3032              		@ frame_needed = 1, uses_anonymous_args = 0
 3033 0000 80B5     		push	{r7, lr}
 3034              		.cfi_def_cfa_offset 8
 3035              		.cfi_offset 7, -8
 3036              		.cfi_offset 14, -4
 3037 0002 84B0     		sub	sp, sp, #16
 3038              		.cfi_def_cfa_offset 24
 3039 0004 00AF     		add	r7, sp, #0
 3040              		.cfi_def_cfa_register 7
 3041 0006 7860     		str	r0, [r7, #4]
1178:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_seg *cseg;
1179:../lwip-1.4.1/src/core/tcp.c **** 
1180:../lwip-1.4.1/src/core/tcp.c ****   cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 3042              		.loc 1 1180 0
 3043 0008 0420     		movs	r0, #4
 3044 000a FFF7FEFF 		bl	memp_malloc
 3045 000e F860     		str	r0, [r7, #12]
1181:../lwip-1.4.1/src/core/tcp.c ****   if (cseg == NULL) {
 3046              		.loc 1 1181 0
 3047 0010 FB68     		ldr	r3, [r7, #12]
 3048 0012 002B     		cmp	r3, #0
 3049 0014 01D1     		bne	.L197
1182:../lwip-1.4.1/src/core/tcp.c ****     return NULL;
 3050              		.loc 1 1182 0
 3051 0016 0023     		movs	r3, #0
 3052 0018 0AE0     		b	.L198
 3053              	.L197:
1183:../lwip-1.4.1/src/core/tcp.c ****   }
1184:../lwip-1.4.1/src/core/tcp.c ****   SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 3054              		.loc 1 1184 0
 3055 001a F868     		ldr	r0, [r7, #12]
 3056 001c 7968     		ldr	r1, [r7, #4]
 3057 001e 1422     		movs	r2, #20
 3058 0020 FFF7FEFF 		bl	memcpy
1185:../lwip-1.4.1/src/core/tcp.c ****   pbuf_ref(cseg->p);
 3059              		.loc 1 1185 0
 3060 0024 FB68     		ldr	r3, [r7, #12]
 3061 0026 5B68     		ldr	r3, [r3, #4]
 3062 0028 1846     		mov	r0, r3
 3063 002a FFF7FEFF 		bl	pbuf_ref
1186:../lwip-1.4.1/src/core/tcp.c ****   return cseg;
 3064              		.loc 1 1186 0
 3065 002e FB68     		ldr	r3, [r7, #12]
 3066              	.L198:
1187:../lwip-1.4.1/src/core/tcp.c **** }
 3067              		.loc 1 1187 0
 3068 0030 1846     		mov	r0, r3
 3069 0032 1037     		adds	r7, r7, #16
 3070              		.cfi_def_cfa_offset 8
 3071 0034 BD46     		mov	sp, r7
 3072              		.cfi_def_cfa_register 13
 3073              		@ sp needed
 3074 0036 80BD     		pop	{r7, pc}
 3075              		.cfi_endproc
 3076              	.LFE20:
 3078              		.section	.text.tcp_recv_null,"ax",%progbits
 3079              		.align	2
 3080              		.global	tcp_recv_null
 3081              		.thumb
 3082              		.thumb_func
 3084              	tcp_recv_null:
 3085              	.LFB21:
1188:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
1189:../lwip-1.4.1/src/core/tcp.c **** 
1190:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
1191:../lwip-1.4.1/src/core/tcp.c **** /**
1192:../lwip-1.4.1/src/core/tcp.c ****  * Default receive callback that is called if the user didn't register
1193:../lwip-1.4.1/src/core/tcp.c ****  * a recv callback for the pcb.
1194:../lwip-1.4.1/src/core/tcp.c ****  */
1195:../lwip-1.4.1/src/core/tcp.c **** err_t
1196:../lwip-1.4.1/src/core/tcp.c **** tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
1197:../lwip-1.4.1/src/core/tcp.c **** {
 3086              		.loc 1 1197 0
 3087              		.cfi_startproc
 3088              		@ args = 0, pretend = 0, frame = 16
 3089              		@ frame_needed = 1, uses_anonymous_args = 0
 3090 0000 80B5     		push	{r7, lr}
 3091              		.cfi_def_cfa_offset 8
 3092              		.cfi_offset 7, -8
 3093              		.cfi_offset 14, -4
 3094 0002 84B0     		sub	sp, sp, #16
 3095              		.cfi_def_cfa_offset 24
 3096 0004 00AF     		add	r7, sp, #0
 3097              		.cfi_def_cfa_register 7
 3098 0006 F860     		str	r0, [r7, #12]
 3099 0008 B960     		str	r1, [r7, #8]
 3100 000a 7A60     		str	r2, [r7, #4]
 3101 000c FB70     		strb	r3, [r7, #3]
1198:../lwip-1.4.1/src/core/tcp.c ****   LWIP_UNUSED_ARG(arg);
1199:../lwip-1.4.1/src/core/tcp.c ****   if (p != NULL) {
 3102              		.loc 1 1199 0
 3103 000e 7B68     		ldr	r3, [r7, #4]
 3104 0010 002B     		cmp	r3, #0
 3105 0012 09D0     		beq	.L200
1200:../lwip-1.4.1/src/core/tcp.c ****     tcp_recved(pcb, p->tot_len);
 3106              		.loc 1 1200 0
 3107 0014 7B68     		ldr	r3, [r7, #4]
 3108 0016 1B89     		ldrh	r3, [r3, #8]
 3109 0018 B868     		ldr	r0, [r7, #8]
 3110 001a 1946     		mov	r1, r3
 3111 001c FFF7FEFF 		bl	tcp_recved
1201:../lwip-1.4.1/src/core/tcp.c ****     pbuf_free(p);
 3112              		.loc 1 1201 0
 3113 0020 7868     		ldr	r0, [r7, #4]
 3114 0022 FFF7FEFF 		bl	pbuf_free
 3115 0026 08E0     		b	.L201
 3116              	.L200:
1202:../lwip-1.4.1/src/core/tcp.c ****   } else if (err == ERR_OK) {
 3117              		.loc 1 1202 0
 3118 0028 97F90330 		ldrsb	r3, [r7, #3]
 3119 002c 002B     		cmp	r3, #0
 3120 002e 04D1     		bne	.L201
1203:../lwip-1.4.1/src/core/tcp.c ****     return tcp_close(pcb);
 3121              		.loc 1 1203 0
 3122 0030 B868     		ldr	r0, [r7, #8]
 3123 0032 FFF7FEFF 		bl	tcp_close
 3124 0036 0346     		mov	r3, r0
 3125 0038 00E0     		b	.L202
 3126              	.L201:
1204:../lwip-1.4.1/src/core/tcp.c ****   }
1205:../lwip-1.4.1/src/core/tcp.c ****   return ERR_OK;
 3127              		.loc 1 1205 0
 3128 003a 0023     		movs	r3, #0
 3129              	.L202:
 3130 003c 5BB2     		sxtb	r3, r3
1206:../lwip-1.4.1/src/core/tcp.c **** }
 3131              		.loc 1 1206 0
 3132 003e 1846     		mov	r0, r3
 3133 0040 1037     		adds	r7, r7, #16
 3134              		.cfi_def_cfa_offset 8
 3135 0042 BD46     		mov	sp, r7
 3136              		.cfi_def_cfa_register 13
 3137              		@ sp needed
 3138 0044 80BD     		pop	{r7, pc}
 3139              		.cfi_endproc
 3140              	.LFE21:
 3142 0046 00BF     		.section	.text.tcp_kill_prio,"ax",%progbits
 3143              		.align	2
 3144              		.thumb
 3145              		.thumb_func
 3147              	tcp_kill_prio:
 3148              	.LFB22:
1207:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
1208:../lwip-1.4.1/src/core/tcp.c **** 
1209:../lwip-1.4.1/src/core/tcp.c **** /**
1210:../lwip-1.4.1/src/core/tcp.c ****  * Kills the oldest active connection that has the same or lower priority than
1211:../lwip-1.4.1/src/core/tcp.c ****  * 'prio'.
1212:../lwip-1.4.1/src/core/tcp.c ****  *
1213:../lwip-1.4.1/src/core/tcp.c ****  * @param prio minimum priority
1214:../lwip-1.4.1/src/core/tcp.c ****  */
1215:../lwip-1.4.1/src/core/tcp.c **** static void
1216:../lwip-1.4.1/src/core/tcp.c **** tcp_kill_prio(u8_t prio)
1217:../lwip-1.4.1/src/core/tcp.c **** {
 3149              		.loc 1 1217 0
 3150              		.cfi_startproc
 3151              		@ args = 0, pretend = 0, frame = 24
 3152              		@ frame_needed = 1, uses_anonymous_args = 0
 3153 0000 80B5     		push	{r7, lr}
 3154              		.cfi_def_cfa_offset 8
 3155              		.cfi_offset 7, -8
 3156              		.cfi_offset 14, -4
 3157 0002 86B0     		sub	sp, sp, #24
 3158              		.cfi_def_cfa_offset 32
 3159 0004 00AF     		add	r7, sp, #0
 3160              		.cfi_def_cfa_register 7
 3161 0006 0346     		mov	r3, r0
 3162 0008 FB71     		strb	r3, [r7, #7]
1218:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb *pcb, *inactive;
1219:../lwip-1.4.1/src/core/tcp.c ****   u32_t inactivity;
1220:../lwip-1.4.1/src/core/tcp.c ****   u8_t mprio;
1221:../lwip-1.4.1/src/core/tcp.c **** 
1222:../lwip-1.4.1/src/core/tcp.c **** 
1223:../lwip-1.4.1/src/core/tcp.c ****   mprio = TCP_PRIO_MAX;
 3163              		.loc 1 1223 0
 3164 000a 7F23     		movs	r3, #127
 3165 000c FB72     		strb	r3, [r7, #11]
1224:../lwip-1.4.1/src/core/tcp.c ****   
1225:../lwip-1.4.1/src/core/tcp.c ****   /* We kill the oldest active connection that has lower priority than prio. */
1226:../lwip-1.4.1/src/core/tcp.c ****   inactivity = 0;
 3166              		.loc 1 1226 0
 3167 000e 0023     		movs	r3, #0
 3168 0010 FB60     		str	r3, [r7, #12]
1227:../lwip-1.4.1/src/core/tcp.c ****   inactive = NULL;
 3169              		.loc 1 1227 0
 3170 0012 0023     		movs	r3, #0
 3171 0014 3B61     		str	r3, [r7, #16]
1228:../lwip-1.4.1/src/core/tcp.c ****   for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 3172              		.loc 1 1228 0
 3173 0016 184B     		ldr	r3, .L208
 3174 0018 1B68     		ldr	r3, [r3]
 3175 001a 7B61     		str	r3, [r7, #20]
 3176 001c 1FE0     		b	.L204
 3177              	.L206:
1229:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->prio <= prio &&
 3178              		.loc 1 1229 0
 3179 001e 7B69     		ldr	r3, [r7, #20]
 3180 0020 5B7E     		ldrb	r3, [r3, #25]	@ zero_extendqisi2
 3181 0022 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 3182 0024 9A42     		cmp	r2, r3
 3183 0026 17D3     		bcc	.L205
1230:../lwip-1.4.1/src/core/tcp.c ****        pcb->prio <= mprio &&
 3184              		.loc 1 1230 0 discriminator 1
 3185 0028 7B69     		ldr	r3, [r7, #20]
 3186 002a 5B7E     		ldrb	r3, [r3, #25]	@ zero_extendqisi2
1229:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->prio <= prio &&
 3187              		.loc 1 1229 0 discriminator 1
 3188 002c FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 3189 002e 9A42     		cmp	r2, r3
 3190 0030 12D3     		bcc	.L205
1231:../lwip-1.4.1/src/core/tcp.c ****        (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 3191              		.loc 1 1231 0
 3192 0032 124B     		ldr	r3, .L208+4
 3193 0034 1A68     		ldr	r2, [r3]
 3194 0036 7B69     		ldr	r3, [r7, #20]
 3195 0038 5B6A     		ldr	r3, [r3, #36]
 3196 003a D21A     		subs	r2, r2, r3
1230:../lwip-1.4.1/src/core/tcp.c ****        pcb->prio <= mprio &&
 3197              		.loc 1 1230 0
 3198 003c FB68     		ldr	r3, [r7, #12]
 3199 003e 9A42     		cmp	r2, r3
 3200 0040 0AD3     		bcc	.L205
1232:../lwip-1.4.1/src/core/tcp.c ****       inactivity = tcp_ticks - pcb->tmr;
 3201              		.loc 1 1232 0
 3202 0042 0E4B     		ldr	r3, .L208+4
 3203 0044 1A68     		ldr	r2, [r3]
 3204 0046 7B69     		ldr	r3, [r7, #20]
 3205 0048 5B6A     		ldr	r3, [r3, #36]
 3206 004a D31A     		subs	r3, r2, r3
 3207 004c FB60     		str	r3, [r7, #12]
1233:../lwip-1.4.1/src/core/tcp.c ****       inactive = pcb;
 3208              		.loc 1 1233 0
 3209 004e 7B69     		ldr	r3, [r7, #20]
 3210 0050 3B61     		str	r3, [r7, #16]
1234:../lwip-1.4.1/src/core/tcp.c ****       mprio = pcb->prio;
 3211              		.loc 1 1234 0
 3212 0052 7B69     		ldr	r3, [r7, #20]
 3213 0054 5B7E     		ldrb	r3, [r3, #25]
 3214 0056 FB72     		strb	r3, [r7, #11]
 3215              	.L205:
1228:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->prio <= prio &&
 3216              		.loc 1 1228 0 discriminator 2
 3217 0058 7B69     		ldr	r3, [r7, #20]
 3218 005a DB68     		ldr	r3, [r3, #12]
 3219 005c 7B61     		str	r3, [r7, #20]
 3220              	.L204:
1228:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->prio <= prio &&
 3221              		.loc 1 1228 0 is_stmt 0 discriminator 1
 3222 005e 7B69     		ldr	r3, [r7, #20]
 3223 0060 002B     		cmp	r3, #0
 3224 0062 DCD1     		bne	.L206
1235:../lwip-1.4.1/src/core/tcp.c ****     }
1236:../lwip-1.4.1/src/core/tcp.c ****   }
1237:../lwip-1.4.1/src/core/tcp.c ****   if (inactive != NULL) {
 3225              		.loc 1 1237 0 is_stmt 1
 3226 0064 3B69     		ldr	r3, [r7, #16]
 3227 0066 002B     		cmp	r3, #0
 3228 0068 02D0     		beq	.L203
1238:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
1239:../lwip-1.4.1/src/core/tcp.c ****            (void *)inactive, inactivity));
1240:../lwip-1.4.1/src/core/tcp.c ****     tcp_abort(inactive);
 3229              		.loc 1 1240 0
 3230 006a 3869     		ldr	r0, [r7, #16]
 3231 006c FFF7FEFF 		bl	tcp_abort
 3232              	.L203:
1241:../lwip-1.4.1/src/core/tcp.c ****   }
1242:../lwip-1.4.1/src/core/tcp.c **** }
 3233              		.loc 1 1242 0
 3234 0070 1837     		adds	r7, r7, #24
 3235              		.cfi_def_cfa_offset 8
 3236 0072 BD46     		mov	sp, r7
 3237              		.cfi_def_cfa_register 13
 3238              		@ sp needed
 3239 0074 80BD     		pop	{r7, pc}
 3240              	.L209:
 3241 0076 00BF     		.align	2
 3242              	.L208:
 3243 0078 00000000 		.word	tcp_active_pcbs
 3244 007c 00000000 		.word	tcp_ticks
 3245              		.cfi_endproc
 3246              	.LFE22:
 3248              		.section	.text.tcp_kill_timewait,"ax",%progbits
 3249              		.align	2
 3250              		.thumb
 3251              		.thumb_func
 3253              	tcp_kill_timewait:
 3254              	.LFB23:
1243:../lwip-1.4.1/src/core/tcp.c **** 
1244:../lwip-1.4.1/src/core/tcp.c **** /**
1245:../lwip-1.4.1/src/core/tcp.c ****  * Kills the oldest connection that is in TIME_WAIT state.
1246:../lwip-1.4.1/src/core/tcp.c ****  * Called from tcp_alloc() if no more connections are available.
1247:../lwip-1.4.1/src/core/tcp.c ****  */
1248:../lwip-1.4.1/src/core/tcp.c **** static void
1249:../lwip-1.4.1/src/core/tcp.c **** tcp_kill_timewait(void)
1250:../lwip-1.4.1/src/core/tcp.c **** {
 3255              		.loc 1 1250 0
 3256              		.cfi_startproc
 3257              		@ args = 0, pretend = 0, frame = 16
 3258              		@ frame_needed = 1, uses_anonymous_args = 0
 3259 0000 80B5     		push	{r7, lr}
 3260              		.cfi_def_cfa_offset 8
 3261              		.cfi_offset 7, -8
 3262              		.cfi_offset 14, -4
 3263 0002 84B0     		sub	sp, sp, #16
 3264              		.cfi_def_cfa_offset 24
 3265 0004 00AF     		add	r7, sp, #0
 3266              		.cfi_def_cfa_register 7
1251:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb *pcb, *inactive;
1252:../lwip-1.4.1/src/core/tcp.c ****   u32_t inactivity;
1253:../lwip-1.4.1/src/core/tcp.c **** 
1254:../lwip-1.4.1/src/core/tcp.c ****   inactivity = 0;
 3267              		.loc 1 1254 0
 3268 0006 0023     		movs	r3, #0
 3269 0008 7B60     		str	r3, [r7, #4]
1255:../lwip-1.4.1/src/core/tcp.c ****   inactive = NULL;
 3270              		.loc 1 1255 0
 3271 000a 0023     		movs	r3, #0
 3272 000c BB60     		str	r3, [r7, #8]
1256:../lwip-1.4.1/src/core/tcp.c ****   /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
1257:../lwip-1.4.1/src/core/tcp.c ****   for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 3273              		.loc 1 1257 0
 3274 000e 114B     		ldr	r3, .L215
 3275 0010 1B68     		ldr	r3, [r3]
 3276 0012 FB60     		str	r3, [r7, #12]
 3277 0014 12E0     		b	.L211
 3278              	.L213:
1258:../lwip-1.4.1/src/core/tcp.c ****     if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 3279              		.loc 1 1258 0
 3280 0016 104B     		ldr	r3, .L215+4
 3281 0018 1A68     		ldr	r2, [r3]
 3282 001a FB68     		ldr	r3, [r7, #12]
 3283 001c 5B6A     		ldr	r3, [r3, #36]
 3284 001e D21A     		subs	r2, r2, r3
 3285 0020 7B68     		ldr	r3, [r7, #4]
 3286 0022 9A42     		cmp	r2, r3
 3287 0024 07D3     		bcc	.L212
1259:../lwip-1.4.1/src/core/tcp.c ****       inactivity = tcp_ticks - pcb->tmr;
 3288              		.loc 1 1259 0
 3289 0026 0C4B     		ldr	r3, .L215+4
 3290 0028 1A68     		ldr	r2, [r3]
 3291 002a FB68     		ldr	r3, [r7, #12]
 3292 002c 5B6A     		ldr	r3, [r3, #36]
 3293 002e D31A     		subs	r3, r2, r3
 3294 0030 7B60     		str	r3, [r7, #4]
1260:../lwip-1.4.1/src/core/tcp.c ****       inactive = pcb;
 3295              		.loc 1 1260 0
 3296 0032 FB68     		ldr	r3, [r7, #12]
 3297 0034 BB60     		str	r3, [r7, #8]
 3298              	.L212:
1257:../lwip-1.4.1/src/core/tcp.c ****     if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 3299              		.loc 1 1257 0 discriminator 2
 3300 0036 FB68     		ldr	r3, [r7, #12]
 3301 0038 DB68     		ldr	r3, [r3, #12]
 3302 003a FB60     		str	r3, [r7, #12]
 3303              	.L211:
1257:../lwip-1.4.1/src/core/tcp.c ****     if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 3304              		.loc 1 1257 0 is_stmt 0 discriminator 1
 3305 003c FB68     		ldr	r3, [r7, #12]
 3306 003e 002B     		cmp	r3, #0
 3307 0040 E9D1     		bne	.L213
1261:../lwip-1.4.1/src/core/tcp.c ****     }
1262:../lwip-1.4.1/src/core/tcp.c ****   }
1263:../lwip-1.4.1/src/core/tcp.c ****   if (inactive != NULL) {
 3308              		.loc 1 1263 0 is_stmt 1
 3309 0042 BB68     		ldr	r3, [r7, #8]
 3310 0044 002B     		cmp	r3, #0
 3311 0046 02D0     		beq	.L210
1264:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
1265:../lwip-1.4.1/src/core/tcp.c ****            (void *)inactive, inactivity));
1266:../lwip-1.4.1/src/core/tcp.c ****     tcp_abort(inactive);
 3312              		.loc 1 1266 0
 3313 0048 B868     		ldr	r0, [r7, #8]
 3314 004a FFF7FEFF 		bl	tcp_abort
 3315              	.L210:
1267:../lwip-1.4.1/src/core/tcp.c ****   }
1268:../lwip-1.4.1/src/core/tcp.c **** }
 3316              		.loc 1 1268 0
 3317 004e 1037     		adds	r7, r7, #16
 3318              		.cfi_def_cfa_offset 8
 3319 0050 BD46     		mov	sp, r7
 3320              		.cfi_def_cfa_register 13
 3321              		@ sp needed
 3322 0052 80BD     		pop	{r7, pc}
 3323              	.L216:
 3324              		.align	2
 3325              	.L215:
 3326 0054 00000000 		.word	tcp_tw_pcbs
 3327 0058 00000000 		.word	tcp_ticks
 3328              		.cfi_endproc
 3329              	.LFE23:
 3331              		.section	.text.tcp_alloc,"ax",%progbits
 3332              		.align	2
 3333              		.global	tcp_alloc
 3334              		.thumb
 3335              		.thumb_func
 3337              	tcp_alloc:
 3338              	.LFB24:
1269:../lwip-1.4.1/src/core/tcp.c **** 
1270:../lwip-1.4.1/src/core/tcp.c **** /**
1271:../lwip-1.4.1/src/core/tcp.c ****  * Allocate a new tcp_pcb structure.
1272:../lwip-1.4.1/src/core/tcp.c ****  *
1273:../lwip-1.4.1/src/core/tcp.c ****  * @param prio priority for the new pcb
1274:../lwip-1.4.1/src/core/tcp.c ****  * @return a new tcp_pcb that initially is in state CLOSED
1275:../lwip-1.4.1/src/core/tcp.c ****  */
1276:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb *
1277:../lwip-1.4.1/src/core/tcp.c **** tcp_alloc(u8_t prio)
1278:../lwip-1.4.1/src/core/tcp.c **** {
 3339              		.loc 1 1278 0
 3340              		.cfi_startproc
 3341              		@ args = 0, pretend = 0, frame = 16
 3342              		@ frame_needed = 1, uses_anonymous_args = 0
 3343 0000 80B5     		push	{r7, lr}
 3344              		.cfi_def_cfa_offset 8
 3345              		.cfi_offset 7, -8
 3346              		.cfi_offset 14, -4
 3347 0002 84B0     		sub	sp, sp, #16
 3348              		.cfi_def_cfa_offset 24
 3349 0004 00AF     		add	r7, sp, #0
 3350              		.cfi_def_cfa_register 7
 3351 0006 0346     		mov	r3, r0
 3352 0008 FB71     		strb	r3, [r7, #7]
1279:../lwip-1.4.1/src/core/tcp.c ****   struct tcp_pcb *pcb;
1280:../lwip-1.4.1/src/core/tcp.c ****   u32_t iss;
1281:../lwip-1.4.1/src/core/tcp.c ****   
1282:../lwip-1.4.1/src/core/tcp.c ****   pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 3353              		.loc 1 1282 0
 3354 000a 0220     		movs	r0, #2
 3355 000c FFF7FEFF 		bl	memp_malloc
 3356 0010 F860     		str	r0, [r7, #12]
1283:../lwip-1.4.1/src/core/tcp.c ****   if (pcb == NULL) {
 3357              		.loc 1 1283 0
 3358 0012 FB68     		ldr	r3, [r7, #12]
 3359 0014 002B     		cmp	r3, #0
 3360 0016 24D1     		bne	.L218
1284:../lwip-1.4.1/src/core/tcp.c ****     /* Try killing oldest connection in TIME-WAIT. */
1285:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
1286:../lwip-1.4.1/src/core/tcp.c ****     tcp_kill_timewait();
 3361              		.loc 1 1286 0
 3362 0018 FFF7FEFF 		bl	tcp_kill_timewait
1287:../lwip-1.4.1/src/core/tcp.c ****     /* Try to allocate a tcp_pcb again. */
1288:../lwip-1.4.1/src/core/tcp.c ****     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 3363              		.loc 1 1288 0
 3364 001c 0220     		movs	r0, #2
 3365 001e FFF7FEFF 		bl	memp_malloc
 3366 0022 F860     		str	r0, [r7, #12]
1289:../lwip-1.4.1/src/core/tcp.c ****     if (pcb == NULL) {
 3367              		.loc 1 1289 0
 3368 0024 FB68     		ldr	r3, [r7, #12]
 3369 0026 002B     		cmp	r3, #0
 3370 0028 11D1     		bne	.L219
1290:../lwip-1.4.1/src/core/tcp.c ****       /* Try killing active connections with lower priority than the new one. */
1291:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
1292:../lwip-1.4.1/src/core/tcp.c ****       tcp_kill_prio(prio);
 3371              		.loc 1 1292 0
 3372 002a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3373 002c 1846     		mov	r0, r3
 3374 002e FFF7FEFF 		bl	tcp_kill_prio
1293:../lwip-1.4.1/src/core/tcp.c ****       /* Try to allocate a tcp_pcb again. */
1294:../lwip-1.4.1/src/core/tcp.c ****       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 3375              		.loc 1 1294 0
 3376 0032 0220     		movs	r0, #2
 3377 0034 FFF7FEFF 		bl	memp_malloc
 3378 0038 F860     		str	r0, [r7, #12]
1295:../lwip-1.4.1/src/core/tcp.c ****       if (pcb != NULL) {
 3379              		.loc 1 1295 0
 3380 003a FB68     		ldr	r3, [r7, #12]
 3381 003c 002B     		cmp	r3, #0
 3382 003e 06D0     		beq	.L219
1296:../lwip-1.4.1/src/core/tcp.c ****         /* adjust err stats: memp_malloc failed twice before */
1297:../lwip-1.4.1/src/core/tcp.c ****         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 3383              		.loc 1 1297 0
 3384 0040 3B4B     		ldr	r3, .L222
 3385 0042 D3F89831 		ldr	r3, [r3, #408]
 3386 0046 013B     		subs	r3, r3, #1
 3387 0048 394A     		ldr	r2, .L222
 3388 004a C2F89831 		str	r3, [r2, #408]
 3389              	.L219:
1298:../lwip-1.4.1/src/core/tcp.c ****       }
1299:../lwip-1.4.1/src/core/tcp.c ****     }
1300:../lwip-1.4.1/src/core/tcp.c ****     if (pcb != NULL) {
 3390              		.loc 1 1300 0
 3391 004e FB68     		ldr	r3, [r7, #12]
 3392 0050 002B     		cmp	r3, #0
 3393 0052 06D0     		beq	.L218
1301:../lwip-1.4.1/src/core/tcp.c ****       /* adjust err stats: timewait PCB was freed above */
1302:../lwip-1.4.1/src/core/tcp.c ****       MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 3394              		.loc 1 1302 0
 3395 0054 364B     		ldr	r3, .L222
 3396 0056 D3F89831 		ldr	r3, [r3, #408]
 3397 005a 013B     		subs	r3, r3, #1
 3398 005c 344A     		ldr	r2, .L222
 3399 005e C2F89831 		str	r3, [r2, #408]
 3400              	.L218:
1303:../lwip-1.4.1/src/core/tcp.c ****     }
1304:../lwip-1.4.1/src/core/tcp.c ****   }
1305:../lwip-1.4.1/src/core/tcp.c ****   if (pcb != NULL) {
 3401              		.loc 1 1305 0
 3402 0062 FB68     		ldr	r3, [r7, #12]
 3403 0064 002B     		cmp	r3, #0
 3404 0066 5DD0     		beq	.L220
1306:../lwip-1.4.1/src/core/tcp.c ****     memset(pcb, 0, sizeof(struct tcp_pcb));
 3405              		.loc 1 1306 0
 3406 0068 F868     		ldr	r0, [r7, #12]
 3407 006a 0021     		movs	r1, #0
 3408 006c 9822     		movs	r2, #152
 3409 006e FFF7FEFF 		bl	memset
1307:../lwip-1.4.1/src/core/tcp.c ****     pcb->prio = prio;
 3410              		.loc 1 1307 0
 3411 0072 FB68     		ldr	r3, [r7, #12]
 3412 0074 FA79     		ldrb	r2, [r7, #7]
 3413 0076 5A76     		strb	r2, [r3, #25]
1308:../lwip-1.4.1/src/core/tcp.c ****     pcb->snd_buf = TCP_SND_BUF;
 3414              		.loc 1 1308 0
 3415 0078 FB68     		ldr	r3, [r7, #12]
 3416 007a 40F66832 		movw	r2, #2920
 3417 007e A3F86620 		strh	r2, [r3, #102]	@ movhi
1309:../lwip-1.4.1/src/core/tcp.c ****     pcb->snd_queuelen = 0;
 3418              		.loc 1 1309 0
 3419 0082 FB68     		ldr	r3, [r7, #12]
 3420 0084 0022     		movs	r2, #0
 3421 0086 A3F86820 		strh	r2, [r3, #104]	@ movhi
1310:../lwip-1.4.1/src/core/tcp.c ****     pcb->rcv_wnd = TCP_WND;
 3422              		.loc 1 1310 0
 3423 008a FB68     		ldr	r3, [r7, #12]
 3424 008c 40F66832 		movw	r2, #2920
 3425 0090 9A85     		strh	r2, [r3, #44]	@ movhi
1311:../lwip-1.4.1/src/core/tcp.c ****     pcb->rcv_ann_wnd = TCP_WND;
 3426              		.loc 1 1311 0
 3427 0092 FB68     		ldr	r3, [r7, #12]
 3428 0094 40F66832 		movw	r2, #2920
 3429 0098 DA85     		strh	r2, [r3, #46]	@ movhi
1312:../lwip-1.4.1/src/core/tcp.c ****     pcb->tos = 0;
 3430              		.loc 1 1312 0
 3431 009a FB68     		ldr	r3, [r7, #12]
 3432 009c 0022     		movs	r2, #0
 3433 009e 5A72     		strb	r2, [r3, #9]
1313:../lwip-1.4.1/src/core/tcp.c ****     pcb->ttl = TCP_TTL;
 3434              		.loc 1 1313 0
 3435 00a0 FB68     		ldr	r3, [r7, #12]
 3436 00a2 FF22     		movs	r2, #255
 3437 00a4 9A72     		strb	r2, [r3, #10]
1314:../lwip-1.4.1/src/core/tcp.c ****     /* As initial send MSS, we use TCP_MSS but limit it to 536.
1315:../lwip-1.4.1/src/core/tcp.c ****        The send MSS is updated when an MSS option is received. */
1316:../lwip-1.4.1/src/core/tcp.c ****     pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 3438              		.loc 1 1316 0
 3439 00a6 FB68     		ldr	r3, [r7, #12]
 3440 00a8 4FF40672 		mov	r2, #536
 3441 00ac DA86     		strh	r2, [r3, #54]	@ movhi
1317:../lwip-1.4.1/src/core/tcp.c ****     pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 3442              		.loc 1 1317 0
 3443 00ae FB68     		ldr	r3, [r7, #12]
 3444 00b0 0622     		movs	r2, #6
 3445 00b2 A3F84420 		strh	r2, [r3, #68]	@ movhi
1318:../lwip-1.4.1/src/core/tcp.c ****     pcb->sa = 0;
 3446              		.loc 1 1318 0
 3447 00b6 FB68     		ldr	r3, [r7, #12]
 3448 00b8 0022     		movs	r2, #0
 3449 00ba A3F84020 		strh	r2, [r3, #64]	@ movhi
1319:../lwip-1.4.1/src/core/tcp.c ****     pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 3450              		.loc 1 1319 0
 3451 00be FB68     		ldr	r3, [r7, #12]
 3452 00c0 0622     		movs	r2, #6
 3453 00c2 A3F84220 		strh	r2, [r3, #66]	@ movhi
1320:../lwip-1.4.1/src/core/tcp.c ****     pcb->rtime = -1;
 3454              		.loc 1 1320 0
 3455 00c6 FB68     		ldr	r3, [r7, #12]
 3456 00c8 4FF6FF72 		movw	r2, #65535
 3457 00cc 9A86     		strh	r2, [r3, #52]	@ movhi
1321:../lwip-1.4.1/src/core/tcp.c ****     pcb->cwnd = 1;
 3458              		.loc 1 1321 0
 3459 00ce FB68     		ldr	r3, [r7, #12]
 3460 00d0 0122     		movs	r2, #1
 3461 00d2 A3F84C20 		strh	r2, [r3, #76]	@ movhi
1322:../lwip-1.4.1/src/core/tcp.c ****     iss = tcp_next_iss();
 3462              		.loc 1 1322 0
 3463 00d6 FFF7FEFF 		bl	tcp_next_iss
 3464 00da B860     		str	r0, [r7, #8]
1323:../lwip-1.4.1/src/core/tcp.c ****     pcb->snd_wl2 = iss;
 3465              		.loc 1 1323 0
 3466 00dc FB68     		ldr	r3, [r7, #12]
 3467 00de BA68     		ldr	r2, [r7, #8]
 3468 00e0 9A65     		str	r2, [r3, #88]
1324:../lwip-1.4.1/src/core/tcp.c ****     pcb->snd_nxt = iss;
 3469              		.loc 1 1324 0
 3470 00e2 FB68     		ldr	r3, [r7, #12]
 3471 00e4 BA68     		ldr	r2, [r7, #8]
 3472 00e6 1A65     		str	r2, [r3, #80]
1325:../lwip-1.4.1/src/core/tcp.c ****     pcb->lastack = iss;
 3473              		.loc 1 1325 0
 3474 00e8 FB68     		ldr	r3, [r7, #12]
 3475 00ea BA68     		ldr	r2, [r7, #8]
 3476 00ec 9A64     		str	r2, [r3, #72]
1326:../lwip-1.4.1/src/core/tcp.c ****     pcb->snd_lbb = iss;   
 3477              		.loc 1 1326 0
 3478 00ee FB68     		ldr	r3, [r7, #12]
 3479 00f0 BA68     		ldr	r2, [r7, #8]
 3480 00f2 DA65     		str	r2, [r3, #92]
1327:../lwip-1.4.1/src/core/tcp.c ****     pcb->tmr = tcp_ticks;
 3481              		.loc 1 1327 0
 3482 00f4 0F4B     		ldr	r3, .L222+4
 3483 00f6 1A68     		ldr	r2, [r3]
 3484 00f8 FB68     		ldr	r3, [r7, #12]
 3485 00fa 5A62     		str	r2, [r3, #36]
1328:../lwip-1.4.1/src/core/tcp.c ****     pcb->last_timer = tcp_timer_ctr;
 3486              		.loc 1 1328 0
 3487 00fc 0E4B     		ldr	r3, .L222+8
 3488 00fe 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3489 0100 FB68     		ldr	r3, [r7, #12]
 3490 0102 83F82120 		strb	r2, [r3, #33]
1329:../lwip-1.4.1/src/core/tcp.c **** 
1330:../lwip-1.4.1/src/core/tcp.c ****     pcb->polltmr = 0;
 3491              		.loc 1 1330 0
 3492 0106 FB68     		ldr	r3, [r7, #12]
 3493 0108 0022     		movs	r2, #0
 3494 010a DA77     		strb	r2, [r3, #31]
1331:../lwip-1.4.1/src/core/tcp.c **** 
1332:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
1333:../lwip-1.4.1/src/core/tcp.c ****     pcb->recv = tcp_recv_null;
 3495              		.loc 1 1333 0
 3496 010c FB68     		ldr	r3, [r7, #12]
 3497 010e 0B4A     		ldr	r2, .L222+12
 3498 0110 C3F88020 		str	r2, [r3, #128]
1334:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */  
1335:../lwip-1.4.1/src/core/tcp.c ****     
1336:../lwip-1.4.1/src/core/tcp.c ****     /* Init KEEPALIVE timer */
1337:../lwip-1.4.1/src/core/tcp.c ****     pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 3499              		.loc 1 1337 0
 3500 0114 FB68     		ldr	r3, [r7, #12]
 3501 0116 0A4A     		ldr	r2, .L222+16
 3502 0118 C3F89020 		str	r2, [r3, #144]
1338:../lwip-1.4.1/src/core/tcp.c ****     
1339:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_TCP_KEEPALIVE
1340:../lwip-1.4.1/src/core/tcp.c ****     pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
1341:../lwip-1.4.1/src/core/tcp.c ****     pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
1342:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_TCP_KEEPALIVE */
1343:../lwip-1.4.1/src/core/tcp.c **** 
1344:../lwip-1.4.1/src/core/tcp.c ****     pcb->keep_cnt_sent = 0;
 3503              		.loc 1 1344 0
 3504 011c FB68     		ldr	r3, [r7, #12]
 3505 011e 0022     		movs	r2, #0
 3506 0120 83F89620 		strb	r2, [r3, #150]
 3507              	.L220:
1345:../lwip-1.4.1/src/core/tcp.c ****   }
1346:../lwip-1.4.1/src/core/tcp.c ****   return pcb;
 3508              		.loc 1 1346 0
 3509 0124 FB68     		ldr	r3, [r7, #12]
1347:../lwip-1.4.1/src/core/tcp.c **** }
 3510              		.loc 1 1347 0
 3511 0126 1846     		mov	r0, r3
 3512 0128 1037     		adds	r7, r7, #16
 3513              		.cfi_def_cfa_offset 8
 3514 012a BD46     		mov	sp, r7
 3515              		.cfi_def_cfa_register 13
 3516              		@ sp needed
 3517 012c 80BD     		pop	{r7, pc}
 3518              	.L223:
 3519 012e 00BF     		.align	2
 3520              	.L222:
 3521 0130 00000000 		.word	lwip_stats
 3522 0134 00000000 		.word	tcp_ticks
 3523 0138 01000000 		.word	tcp_timer_ctr
 3524 013c 00000000 		.word	tcp_recv_null
 3525 0140 00DD6D00 		.word	7200000
 3526              		.cfi_endproc
 3527              	.LFE24:
 3529              		.section	.text.tcp_new,"ax",%progbits
 3530              		.align	2
 3531              		.global	tcp_new
 3532              		.thumb
 3533              		.thumb_func
 3535              	tcp_new:
 3536              	.LFB25:
1348:../lwip-1.4.1/src/core/tcp.c **** 
1349:../lwip-1.4.1/src/core/tcp.c **** /**
1350:../lwip-1.4.1/src/core/tcp.c ****  * Creates a new TCP protocol control block but doesn't place it on
1351:../lwip-1.4.1/src/core/tcp.c ****  * any of the TCP PCB lists.
1352:../lwip-1.4.1/src/core/tcp.c ****  * The pcb is not put on any list until binding using tcp_bind().
1353:../lwip-1.4.1/src/core/tcp.c ****  *
1354:../lwip-1.4.1/src/core/tcp.c ****  * @internal: Maybe there should be a idle TCP PCB list where these
1355:../lwip-1.4.1/src/core/tcp.c ****  * PCBs are put on. Port reservation using tcp_bind() is implemented but
1356:../lwip-1.4.1/src/core/tcp.c ****  * allocated pcbs that are not bound can't be killed automatically if wanting
1357:../lwip-1.4.1/src/core/tcp.c ****  * to allocate a pcb with higher prio (@see tcp_kill_prio())
1358:../lwip-1.4.1/src/core/tcp.c ****  *
1359:../lwip-1.4.1/src/core/tcp.c ****  * @return a new tcp_pcb that initially is in state CLOSED
1360:../lwip-1.4.1/src/core/tcp.c ****  */
1361:../lwip-1.4.1/src/core/tcp.c **** struct tcp_pcb *
1362:../lwip-1.4.1/src/core/tcp.c **** tcp_new(void)
1363:../lwip-1.4.1/src/core/tcp.c **** {
 3537              		.loc 1 1363 0
 3538              		.cfi_startproc
 3539              		@ args = 0, pretend = 0, frame = 0
 3540              		@ frame_needed = 1, uses_anonymous_args = 0
 3541 0000 80B5     		push	{r7, lr}
 3542              		.cfi_def_cfa_offset 8
 3543              		.cfi_offset 7, -8
 3544              		.cfi_offset 14, -4
 3545 0002 00AF     		add	r7, sp, #0
 3546              		.cfi_def_cfa_register 7
1364:../lwip-1.4.1/src/core/tcp.c ****   return tcp_alloc(TCP_PRIO_NORMAL);
 3547              		.loc 1 1364 0
 3548 0004 4020     		movs	r0, #64
 3549 0006 FFF7FEFF 		bl	tcp_alloc
 3550 000a 0346     		mov	r3, r0
1365:../lwip-1.4.1/src/core/tcp.c **** }
 3551              		.loc 1 1365 0
 3552 000c 1846     		mov	r0, r3
 3553 000e 80BD     		pop	{r7, pc}
 3554              		.cfi_endproc
 3555              	.LFE25:
 3557              		.section	.text.tcp_arg,"ax",%progbits
 3558              		.align	2
 3559              		.global	tcp_arg
 3560              		.thumb
 3561              		.thumb_func
 3563              	tcp_arg:
 3564              	.LFB26:
1366:../lwip-1.4.1/src/core/tcp.c **** 
1367:../lwip-1.4.1/src/core/tcp.c **** /**
1368:../lwip-1.4.1/src/core/tcp.c ****  * Used to specify the argument that should be passed callback
1369:../lwip-1.4.1/src/core/tcp.c ****  * functions.
1370:../lwip-1.4.1/src/core/tcp.c ****  *
1371:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb tcp_pcb to set the callback argument
1372:../lwip-1.4.1/src/core/tcp.c ****  * @param arg void pointer argument to pass to callback functions
1373:../lwip-1.4.1/src/core/tcp.c ****  */ 
1374:../lwip-1.4.1/src/core/tcp.c **** void
1375:../lwip-1.4.1/src/core/tcp.c **** tcp_arg(struct tcp_pcb *pcb, void *arg)
1376:../lwip-1.4.1/src/core/tcp.c **** {
 3565              		.loc 1 1376 0
 3566              		.cfi_startproc
 3567              		@ args = 0, pretend = 0, frame = 8
 3568              		@ frame_needed = 1, uses_anonymous_args = 0
 3569              		@ link register save eliminated.
 3570 0000 80B4     		push	{r7}
 3571              		.cfi_def_cfa_offset 4
 3572              		.cfi_offset 7, -4
 3573 0002 83B0     		sub	sp, sp, #12
 3574              		.cfi_def_cfa_offset 16
 3575 0004 00AF     		add	r7, sp, #0
 3576              		.cfi_def_cfa_register 7
 3577 0006 7860     		str	r0, [r7, #4]
 3578 0008 3960     		str	r1, [r7]
1377:../lwip-1.4.1/src/core/tcp.c ****   /* This function is allowed to be called for both listen pcbs and
1378:../lwip-1.4.1/src/core/tcp.c ****      connection pcbs. */
1379:../lwip-1.4.1/src/core/tcp.c ****   pcb->callback_arg = arg;
 3579              		.loc 1 1379 0
 3580 000a 7B68     		ldr	r3, [r7, #4]
 3581 000c 3A68     		ldr	r2, [r7]
 3582 000e 1A61     		str	r2, [r3, #16]
1380:../lwip-1.4.1/src/core/tcp.c **** }
 3583              		.loc 1 1380 0
 3584 0010 0C37     		adds	r7, r7, #12
 3585              		.cfi_def_cfa_offset 4
 3586 0012 BD46     		mov	sp, r7
 3587              		.cfi_def_cfa_register 13
 3588              		@ sp needed
 3589 0014 5DF8047B 		ldr	r7, [sp], #4
 3590              		.cfi_restore 7
 3591              		.cfi_def_cfa_offset 0
 3592 0018 7047     		bx	lr
 3593              		.cfi_endproc
 3594              	.LFE26:
 3596 001a 00BF     		.section	.text.tcp_recv,"ax",%progbits
 3597              		.align	2
 3598              		.global	tcp_recv
 3599              		.thumb
 3600              		.thumb_func
 3602              	tcp_recv:
 3603              	.LFB27:
1381:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
1382:../lwip-1.4.1/src/core/tcp.c **** 
1383:../lwip-1.4.1/src/core/tcp.c **** /**
1384:../lwip-1.4.1/src/core/tcp.c ****  * Used to specify the function that should be called when a TCP
1385:../lwip-1.4.1/src/core/tcp.c ****  * connection receives data.
1386:../lwip-1.4.1/src/core/tcp.c ****  *
1387:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb tcp_pcb to set the recv callback
1388:../lwip-1.4.1/src/core/tcp.c ****  * @param recv callback function to call for this pcb when data is received
1389:../lwip-1.4.1/src/core/tcp.c ****  */ 
1390:../lwip-1.4.1/src/core/tcp.c **** void
1391:../lwip-1.4.1/src/core/tcp.c **** tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
1392:../lwip-1.4.1/src/core/tcp.c **** {
 3604              		.loc 1 1392 0
 3605              		.cfi_startproc
 3606              		@ args = 0, pretend = 0, frame = 8
 3607              		@ frame_needed = 1, uses_anonymous_args = 0
 3608              		@ link register save eliminated.
 3609 0000 80B4     		push	{r7}
 3610              		.cfi_def_cfa_offset 4
 3611              		.cfi_offset 7, -4
 3612 0002 83B0     		sub	sp, sp, #12
 3613              		.cfi_def_cfa_offset 16
 3614 0004 00AF     		add	r7, sp, #0
 3615              		.cfi_def_cfa_register 7
 3616 0006 7860     		str	r0, [r7, #4]
 3617 0008 3960     		str	r1, [r7]
1393:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
1394:../lwip-1.4.1/src/core/tcp.c ****   pcb->recv = recv;
 3618              		.loc 1 1394 0
 3619 000a 7B68     		ldr	r3, [r7, #4]
 3620 000c 3A68     		ldr	r2, [r7]
 3621 000e C3F88020 		str	r2, [r3, #128]
1395:../lwip-1.4.1/src/core/tcp.c **** }
 3622              		.loc 1 1395 0
 3623 0012 0C37     		adds	r7, r7, #12
 3624              		.cfi_def_cfa_offset 4
 3625 0014 BD46     		mov	sp, r7
 3626              		.cfi_def_cfa_register 13
 3627              		@ sp needed
 3628 0016 5DF8047B 		ldr	r7, [sp], #4
 3629              		.cfi_restore 7
 3630              		.cfi_def_cfa_offset 0
 3631 001a 7047     		bx	lr
 3632              		.cfi_endproc
 3633              	.LFE27:
 3635              		.section	.text.tcp_sent,"ax",%progbits
 3636              		.align	2
 3637              		.global	tcp_sent
 3638              		.thumb
 3639              		.thumb_func
 3641              	tcp_sent:
 3642              	.LFB28:
1396:../lwip-1.4.1/src/core/tcp.c **** 
1397:../lwip-1.4.1/src/core/tcp.c **** /**
1398:../lwip-1.4.1/src/core/tcp.c ****  * Used to specify the function that should be called when TCP data
1399:../lwip-1.4.1/src/core/tcp.c ****  * has been successfully delivered to the remote host.
1400:../lwip-1.4.1/src/core/tcp.c ****  *
1401:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb tcp_pcb to set the sent callback
1402:../lwip-1.4.1/src/core/tcp.c ****  * @param sent callback function to call for this pcb when data is successfully sent
1403:../lwip-1.4.1/src/core/tcp.c ****  */ 
1404:../lwip-1.4.1/src/core/tcp.c **** void
1405:../lwip-1.4.1/src/core/tcp.c **** tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
1406:../lwip-1.4.1/src/core/tcp.c **** {
 3643              		.loc 1 1406 0
 3644              		.cfi_startproc
 3645              		@ args = 0, pretend = 0, frame = 8
 3646              		@ frame_needed = 1, uses_anonymous_args = 0
 3647              		@ link register save eliminated.
 3648 0000 80B4     		push	{r7}
 3649              		.cfi_def_cfa_offset 4
 3650              		.cfi_offset 7, -4
 3651 0002 83B0     		sub	sp, sp, #12
 3652              		.cfi_def_cfa_offset 16
 3653 0004 00AF     		add	r7, sp, #0
 3654              		.cfi_def_cfa_register 7
 3655 0006 7860     		str	r0, [r7, #4]
 3656 0008 3960     		str	r1, [r7]
1407:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
1408:../lwip-1.4.1/src/core/tcp.c ****   pcb->sent = sent;
 3657              		.loc 1 1408 0
 3658 000a 7B68     		ldr	r3, [r7, #4]
 3659 000c 3A68     		ldr	r2, [r7]
 3660 000e DA67     		str	r2, [r3, #124]
1409:../lwip-1.4.1/src/core/tcp.c **** }
 3661              		.loc 1 1409 0
 3662 0010 0C37     		adds	r7, r7, #12
 3663              		.cfi_def_cfa_offset 4
 3664 0012 BD46     		mov	sp, r7
 3665              		.cfi_def_cfa_register 13
 3666              		@ sp needed
 3667 0014 5DF8047B 		ldr	r7, [sp], #4
 3668              		.cfi_restore 7
 3669              		.cfi_def_cfa_offset 0
 3670 0018 7047     		bx	lr
 3671              		.cfi_endproc
 3672              	.LFE28:
 3674 001a 00BF     		.section	.text.tcp_err,"ax",%progbits
 3675              		.align	2
 3676              		.global	tcp_err
 3677              		.thumb
 3678              		.thumb_func
 3680              	tcp_err:
 3681              	.LFB29:
1410:../lwip-1.4.1/src/core/tcp.c **** 
1411:../lwip-1.4.1/src/core/tcp.c **** /**
1412:../lwip-1.4.1/src/core/tcp.c ****  * Used to specify the function that should be called when a fatal error
1413:../lwip-1.4.1/src/core/tcp.c ****  * has occured on the connection.
1414:../lwip-1.4.1/src/core/tcp.c ****  *
1415:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb tcp_pcb to set the err callback
1416:../lwip-1.4.1/src/core/tcp.c ****  * @param err callback function to call for this pcb when a fatal error
1417:../lwip-1.4.1/src/core/tcp.c ****  *        has occured on the connection
1418:../lwip-1.4.1/src/core/tcp.c ****  */ 
1419:../lwip-1.4.1/src/core/tcp.c **** void
1420:../lwip-1.4.1/src/core/tcp.c **** tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
1421:../lwip-1.4.1/src/core/tcp.c **** {
 3682              		.loc 1 1421 0
 3683              		.cfi_startproc
 3684              		@ args = 0, pretend = 0, frame = 8
 3685              		@ frame_needed = 1, uses_anonymous_args = 0
 3686              		@ link register save eliminated.
 3687 0000 80B4     		push	{r7}
 3688              		.cfi_def_cfa_offset 4
 3689              		.cfi_offset 7, -4
 3690 0002 83B0     		sub	sp, sp, #12
 3691              		.cfi_def_cfa_offset 16
 3692 0004 00AF     		add	r7, sp, #0
 3693              		.cfi_def_cfa_register 7
 3694 0006 7860     		str	r0, [r7, #4]
 3695 0008 3960     		str	r1, [r7]
1422:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
1423:../lwip-1.4.1/src/core/tcp.c ****   pcb->errf = err;
 3696              		.loc 1 1423 0
 3697 000a 7B68     		ldr	r3, [r7, #4]
 3698 000c 3A68     		ldr	r2, [r7]
 3699 000e C3F88C20 		str	r2, [r3, #140]
1424:../lwip-1.4.1/src/core/tcp.c **** }
 3700              		.loc 1 1424 0
 3701 0012 0C37     		adds	r7, r7, #12
 3702              		.cfi_def_cfa_offset 4
 3703 0014 BD46     		mov	sp, r7
 3704              		.cfi_def_cfa_register 13
 3705              		@ sp needed
 3706 0016 5DF8047B 		ldr	r7, [sp], #4
 3707              		.cfi_restore 7
 3708              		.cfi_def_cfa_offset 0
 3709 001a 7047     		bx	lr
 3710              		.cfi_endproc
 3711              	.LFE29:
 3713              		.section	.text.tcp_accept,"ax",%progbits
 3714              		.align	2
 3715              		.global	tcp_accept
 3716              		.thumb
 3717              		.thumb_func
 3719              	tcp_accept:
 3720              	.LFB30:
1425:../lwip-1.4.1/src/core/tcp.c **** 
1426:../lwip-1.4.1/src/core/tcp.c **** /**
1427:../lwip-1.4.1/src/core/tcp.c ****  * Used for specifying the function that should be called when a
1428:../lwip-1.4.1/src/core/tcp.c ****  * LISTENing connection has been connected to another host.
1429:../lwip-1.4.1/src/core/tcp.c ****  *
1430:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb tcp_pcb to set the accept callback
1431:../lwip-1.4.1/src/core/tcp.c ****  * @param accept callback function to call for this pcb when LISTENing
1432:../lwip-1.4.1/src/core/tcp.c ****  *        connection has been connected to another host
1433:../lwip-1.4.1/src/core/tcp.c ****  */ 
1434:../lwip-1.4.1/src/core/tcp.c **** void
1435:../lwip-1.4.1/src/core/tcp.c **** tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
1436:../lwip-1.4.1/src/core/tcp.c **** {
 3721              		.loc 1 1436 0
 3722              		.cfi_startproc
 3723              		@ args = 0, pretend = 0, frame = 8
 3724              		@ frame_needed = 1, uses_anonymous_args = 0
 3725              		@ link register save eliminated.
 3726 0000 80B4     		push	{r7}
 3727              		.cfi_def_cfa_offset 4
 3728              		.cfi_offset 7, -4
 3729 0002 83B0     		sub	sp, sp, #12
 3730              		.cfi_def_cfa_offset 16
 3731 0004 00AF     		add	r7, sp, #0
 3732              		.cfi_def_cfa_register 7
 3733 0006 7860     		str	r0, [r7, #4]
 3734 0008 3960     		str	r1, [r7]
1437:../lwip-1.4.1/src/core/tcp.c ****   /* This function is allowed to be called for both listen pcbs and
1438:../lwip-1.4.1/src/core/tcp.c ****      connection pcbs. */
1439:../lwip-1.4.1/src/core/tcp.c ****   pcb->accept = accept;
 3735              		.loc 1 1439 0
 3736 000a 7B68     		ldr	r3, [r7, #4]
 3737 000c 3A68     		ldr	r2, [r7]
 3738 000e 5A61     		str	r2, [r3, #20]
1440:../lwip-1.4.1/src/core/tcp.c **** }
 3739              		.loc 1 1440 0
 3740 0010 0C37     		adds	r7, r7, #12
 3741              		.cfi_def_cfa_offset 4
 3742 0012 BD46     		mov	sp, r7
 3743              		.cfi_def_cfa_register 13
 3744              		@ sp needed
 3745 0014 5DF8047B 		ldr	r7, [sp], #4
 3746              		.cfi_restore 7
 3747              		.cfi_def_cfa_offset 0
 3748 0018 7047     		bx	lr
 3749              		.cfi_endproc
 3750              	.LFE30:
 3752 001a 00BF     		.section	.text.tcp_poll,"ax",%progbits
 3753              		.align	2
 3754              		.global	tcp_poll
 3755              		.thumb
 3756              		.thumb_func
 3758              	tcp_poll:
 3759              	.LFB31:
1441:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
1442:../lwip-1.4.1/src/core/tcp.c **** 
1443:../lwip-1.4.1/src/core/tcp.c **** 
1444:../lwip-1.4.1/src/core/tcp.c **** /**
1445:../lwip-1.4.1/src/core/tcp.c ****  * Used to specify the function that should be called periodically
1446:../lwip-1.4.1/src/core/tcp.c ****  * from TCP. The interval is specified in terms of the TCP coarse
1447:../lwip-1.4.1/src/core/tcp.c ****  * timer interval, which is called twice a second.
1448:../lwip-1.4.1/src/core/tcp.c ****  *
1449:../lwip-1.4.1/src/core/tcp.c ****  */ 
1450:../lwip-1.4.1/src/core/tcp.c **** void
1451:../lwip-1.4.1/src/core/tcp.c **** tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
1452:../lwip-1.4.1/src/core/tcp.c **** {
 3760              		.loc 1 1452 0
 3761              		.cfi_startproc
 3762              		@ args = 0, pretend = 0, frame = 16
 3763              		@ frame_needed = 1, uses_anonymous_args = 0
 3764              		@ link register save eliminated.
 3765 0000 80B4     		push	{r7}
 3766              		.cfi_def_cfa_offset 4
 3767              		.cfi_offset 7, -4
 3768 0002 85B0     		sub	sp, sp, #20
 3769              		.cfi_def_cfa_offset 24
 3770 0004 00AF     		add	r7, sp, #0
 3771              		.cfi_def_cfa_register 7
 3772 0006 F860     		str	r0, [r7, #12]
 3773 0008 B960     		str	r1, [r7, #8]
 3774 000a 1346     		mov	r3, r2
 3775 000c FB71     		strb	r3, [r7, #7]
1453:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
1454:../lwip-1.4.1/src/core/tcp.c **** #if LWIP_CALLBACK_API
1455:../lwip-1.4.1/src/core/tcp.c ****   pcb->poll = poll;
 3776              		.loc 1 1455 0
 3777 000e FB68     		ldr	r3, [r7, #12]
 3778 0010 BA68     		ldr	r2, [r7, #8]
 3779 0012 C3F88820 		str	r2, [r3, #136]
1456:../lwip-1.4.1/src/core/tcp.c **** #else /* LWIP_CALLBACK_API */  
1457:../lwip-1.4.1/src/core/tcp.c ****   LWIP_UNUSED_ARG(poll);
1458:../lwip-1.4.1/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */  
1459:../lwip-1.4.1/src/core/tcp.c ****   pcb->pollinterval = interval;
 3780              		.loc 1 1459 0
 3781 0016 FB68     		ldr	r3, [r7, #12]
 3782 0018 FA79     		ldrb	r2, [r7, #7]
 3783 001a 83F82020 		strb	r2, [r3, #32]
1460:../lwip-1.4.1/src/core/tcp.c **** }
 3784              		.loc 1 1460 0
 3785 001e 1437     		adds	r7, r7, #20
 3786              		.cfi_def_cfa_offset 4
 3787 0020 BD46     		mov	sp, r7
 3788              		.cfi_def_cfa_register 13
 3789              		@ sp needed
 3790 0022 5DF8047B 		ldr	r7, [sp], #4
 3791              		.cfi_restore 7
 3792              		.cfi_def_cfa_offset 0
 3793 0026 7047     		bx	lr
 3794              		.cfi_endproc
 3795              	.LFE31:
 3797              		.section	.text.tcp_pcb_purge,"ax",%progbits
 3798              		.align	2
 3799              		.global	tcp_pcb_purge
 3800              		.thumb
 3801              		.thumb_func
 3803              	tcp_pcb_purge:
 3804              	.LFB32:
1461:../lwip-1.4.1/src/core/tcp.c **** 
1462:../lwip-1.4.1/src/core/tcp.c **** /**
1463:../lwip-1.4.1/src/core/tcp.c ****  * Purges a TCP PCB. Removes any buffered data and frees the buffer memory
1464:../lwip-1.4.1/src/core/tcp.c ****  * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
1465:../lwip-1.4.1/src/core/tcp.c ****  *
1466:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
1467:../lwip-1.4.1/src/core/tcp.c ****  */
1468:../lwip-1.4.1/src/core/tcp.c **** void
1469:../lwip-1.4.1/src/core/tcp.c **** tcp_pcb_purge(struct tcp_pcb *pcb)
1470:../lwip-1.4.1/src/core/tcp.c **** {
 3805              		.loc 1 1470 0
 3806              		.cfi_startproc
 3807              		@ args = 0, pretend = 0, frame = 16
 3808              		@ frame_needed = 1, uses_anonymous_args = 0
 3809 0000 80B5     		push	{r7, lr}
 3810              		.cfi_def_cfa_offset 8
 3811              		.cfi_offset 7, -8
 3812              		.cfi_offset 14, -4
 3813 0002 84B0     		sub	sp, sp, #16
 3814              		.cfi_def_cfa_offset 24
 3815 0004 00AF     		add	r7, sp, #0
 3816              		.cfi_def_cfa_register 7
 3817 0006 7860     		str	r0, [r7, #4]
1471:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state != CLOSED &&
 3818              		.loc 1 1471 0
 3819 0008 7B68     		ldr	r3, [r7, #4]
 3820 000a 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 3821 000c 002B     		cmp	r3, #0
 3822 000e 5CD0     		beq	.L232
1472:../lwip-1.4.1/src/core/tcp.c ****      pcb->state != TIME_WAIT &&
 3823              		.loc 1 1472 0 discriminator 1
 3824 0010 7B68     		ldr	r3, [r7, #4]
 3825 0012 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
1471:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state != CLOSED &&
 3826              		.loc 1 1471 0 discriminator 1
 3827 0014 0A2B     		cmp	r3, #10
 3828 0016 58D0     		beq	.L232
1473:../lwip-1.4.1/src/core/tcp.c ****      pcb->state != LISTEN) {
 3829              		.loc 1 1473 0
 3830 0018 7B68     		ldr	r3, [r7, #4]
 3831 001a 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
1472:../lwip-1.4.1/src/core/tcp.c ****      pcb->state != TIME_WAIT &&
 3832              		.loc 1 1472 0
 3833 001c 012B     		cmp	r3, #1
 3834 001e 54D0     		beq	.L232
1474:../lwip-1.4.1/src/core/tcp.c **** 
1475:../lwip-1.4.1/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
1476:../lwip-1.4.1/src/core/tcp.c **** 
1477:../lwip-1.4.1/src/core/tcp.c **** #if TCP_LISTEN_BACKLOG
1478:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->state == SYN_RCVD) {
 3835              		.loc 1 1478 0
 3836 0020 7B68     		ldr	r3, [r7, #4]
 3837 0022 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 3838 0024 032B     		cmp	r3, #3
 3839 0026 23D1     		bne	.L234
 3840              	.LBB8:
1479:../lwip-1.4.1/src/core/tcp.c ****       /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
1480:../lwip-1.4.1/src/core/tcp.c ****       struct tcp_pcb_listen *lpcb;
1481:../lwip-1.4.1/src/core/tcp.c ****       LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
1482:../lwip-1.4.1/src/core/tcp.c ****         tcp_listen_pcbs.listen_pcbs != NULL);
1483:../lwip-1.4.1/src/core/tcp.c ****       for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 3841              		.loc 1 1483 0
 3842 0028 294B     		ldr	r3, .L240
 3843 002a 1B68     		ldr	r3, [r3]
 3844 002c FB60     		str	r3, [r7, #12]
 3845 002e 1CE0     		b	.L235
 3846              	.L238:
1484:../lwip-1.4.1/src/core/tcp.c ****         if ((lpcb->local_port == pcb->local_port) &&
 3847              		.loc 1 1484 0
 3848 0030 FB68     		ldr	r3, [r7, #12]
 3849 0032 5A8B     		ldrh	r2, [r3, #26]
 3850 0034 7B68     		ldr	r3, [r7, #4]
 3851 0036 5B8B     		ldrh	r3, [r3, #26]
 3852 0038 9A42     		cmp	r2, r3
 3853 003a 13D1     		bne	.L236
1485:../lwip-1.4.1/src/core/tcp.c ****             (ip_addr_isany(&lpcb->local_ip) ||
 3854              		.loc 1 1485 0 discriminator 1
 3855 003c FB68     		ldr	r3, [r7, #12]
1484:../lwip-1.4.1/src/core/tcp.c ****         if ((lpcb->local_port == pcb->local_port) &&
 3856              		.loc 1 1484 0 discriminator 1
 3857 003e 002B     		cmp	r3, #0
 3858 0040 09D0     		beq	.L237
 3859              		.loc 1 1485 0
 3860 0042 FB68     		ldr	r3, [r7, #12]
 3861 0044 1B68     		ldr	r3, [r3]
 3862 0046 002B     		cmp	r3, #0
 3863 0048 05D0     		beq	.L237
1486:../lwip-1.4.1/src/core/tcp.c ****              ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
 3864              		.loc 1 1486 0 discriminator 1
 3865 004a 7B68     		ldr	r3, [r7, #4]
 3866 004c 1A68     		ldr	r2, [r3]
 3867 004e FB68     		ldr	r3, [r7, #12]
 3868 0050 1B68     		ldr	r3, [r3]
1485:../lwip-1.4.1/src/core/tcp.c ****             (ip_addr_isany(&lpcb->local_ip) ||
 3869              		.loc 1 1485 0 discriminator 1
 3870 0052 9A42     		cmp	r2, r3
 3871 0054 06D1     		bne	.L236
 3872              	.L237:
1487:../lwip-1.4.1/src/core/tcp.c ****             /* port and address of the listen pcb match the timed-out pcb */
1488:../lwip-1.4.1/src/core/tcp.c ****             LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
1489:../lwip-1.4.1/src/core/tcp.c ****               lpcb->accepts_pending > 0);
1490:../lwip-1.4.1/src/core/tcp.c ****             lpcb->accepts_pending--;
 3873              		.loc 1 1490 0
 3874 0056 FB68     		ldr	r3, [r7, #12]
 3875 0058 5B7F     		ldrb	r3, [r3, #29]	@ zero_extendqisi2
 3876 005a 013B     		subs	r3, r3, #1
 3877 005c DAB2     		uxtb	r2, r3
 3878 005e FB68     		ldr	r3, [r7, #12]
 3879 0060 5A77     		strb	r2, [r3, #29]
1491:../lwip-1.4.1/src/core/tcp.c ****             break;
 3880              		.loc 1 1491 0
 3881 0062 05E0     		b	.L234
 3882              	.L236:
1483:../lwip-1.4.1/src/core/tcp.c ****         if ((lpcb->local_port == pcb->local_port) &&
 3883              		.loc 1 1483 0 discriminator 2
 3884 0064 FB68     		ldr	r3, [r7, #12]
 3885 0066 DB68     		ldr	r3, [r3, #12]
 3886 0068 FB60     		str	r3, [r7, #12]
 3887              	.L235:
1483:../lwip-1.4.1/src/core/tcp.c ****         if ((lpcb->local_port == pcb->local_port) &&
 3888              		.loc 1 1483 0 is_stmt 0 discriminator 1
 3889 006a FB68     		ldr	r3, [r7, #12]
 3890 006c 002B     		cmp	r3, #0
 3891 006e DFD1     		bne	.L238
 3892              	.L234:
 3893              	.LBE8:
1492:../lwip-1.4.1/src/core/tcp.c ****           }
1493:../lwip-1.4.1/src/core/tcp.c ****       }
1494:../lwip-1.4.1/src/core/tcp.c ****     }
1495:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_LISTEN_BACKLOG */
1496:../lwip-1.4.1/src/core/tcp.c **** 
1497:../lwip-1.4.1/src/core/tcp.c **** 
1498:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->refused_data != NULL) {
 3894              		.loc 1 1498 0 is_stmt 1
 3895 0070 7B68     		ldr	r3, [r7, #4]
 3896 0072 9B6F     		ldr	r3, [r3, #120]
 3897 0074 002B     		cmp	r3, #0
 3898 0076 07D0     		beq	.L239
1499:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
1500:../lwip-1.4.1/src/core/tcp.c ****       pbuf_free(pcb->refused_data);
 3899              		.loc 1 1500 0
 3900 0078 7B68     		ldr	r3, [r7, #4]
 3901 007a 9B6F     		ldr	r3, [r3, #120]
 3902 007c 1846     		mov	r0, r3
 3903 007e FFF7FEFF 		bl	pbuf_free
1501:../lwip-1.4.1/src/core/tcp.c ****       pcb->refused_data = NULL;
 3904              		.loc 1 1501 0
 3905 0082 7B68     		ldr	r3, [r7, #4]
 3906 0084 0022     		movs	r2, #0
 3907 0086 9A67     		str	r2, [r3, #120]
 3908              	.L239:
1502:../lwip-1.4.1/src/core/tcp.c ****     }
1503:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->unsent != NULL) {
1504:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
1505:../lwip-1.4.1/src/core/tcp.c ****     }
1506:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->unacked != NULL) {
1507:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
1508:../lwip-1.4.1/src/core/tcp.c ****     }
1509:../lwip-1.4.1/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ
1510:../lwip-1.4.1/src/core/tcp.c ****     if (pcb->ooseq != NULL) {
1511:../lwip-1.4.1/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
1512:../lwip-1.4.1/src/core/tcp.c ****     }
1513:../lwip-1.4.1/src/core/tcp.c ****     tcp_segs_free(pcb->ooseq);
 3909              		.loc 1 1513 0
 3910 0088 7B68     		ldr	r3, [r7, #4]
 3911 008a 5B6F     		ldr	r3, [r3, #116]
 3912 008c 1846     		mov	r0, r3
 3913 008e FFF7FEFF 		bl	tcp_segs_free
1514:../lwip-1.4.1/src/core/tcp.c ****     pcb->ooseq = NULL;
 3914              		.loc 1 1514 0
 3915 0092 7B68     		ldr	r3, [r7, #4]
 3916 0094 0022     		movs	r2, #0
 3917 0096 5A67     		str	r2, [r3, #116]
1515:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
1516:../lwip-1.4.1/src/core/tcp.c **** 
1517:../lwip-1.4.1/src/core/tcp.c ****     /* Stop the retransmission timer as it will expect data on unacked
1518:../lwip-1.4.1/src/core/tcp.c ****        queue if it fires */
1519:../lwip-1.4.1/src/core/tcp.c ****     pcb->rtime = -1;
 3918              		.loc 1 1519 0
 3919 0098 7B68     		ldr	r3, [r7, #4]
 3920 009a 4FF6FF72 		movw	r2, #65535
 3921 009e 9A86     		strh	r2, [r3, #52]	@ movhi
1520:../lwip-1.4.1/src/core/tcp.c **** 
1521:../lwip-1.4.1/src/core/tcp.c ****     tcp_segs_free(pcb->unsent);
 3922              		.loc 1 1521 0
 3923 00a0 7B68     		ldr	r3, [r7, #4]
 3924 00a2 DB6E     		ldr	r3, [r3, #108]
 3925 00a4 1846     		mov	r0, r3
 3926 00a6 FFF7FEFF 		bl	tcp_segs_free
1522:../lwip-1.4.1/src/core/tcp.c ****     tcp_segs_free(pcb->unacked);
 3927              		.loc 1 1522 0
 3928 00aa 7B68     		ldr	r3, [r7, #4]
 3929 00ac 1B6F     		ldr	r3, [r3, #112]
 3930 00ae 1846     		mov	r0, r3
 3931 00b0 FFF7FEFF 		bl	tcp_segs_free
1523:../lwip-1.4.1/src/core/tcp.c ****     pcb->unacked = pcb->unsent = NULL;
 3932              		.loc 1 1523 0
 3933 00b4 7B68     		ldr	r3, [r7, #4]
 3934 00b6 0022     		movs	r2, #0
 3935 00b8 DA66     		str	r2, [r3, #108]
 3936 00ba 7B68     		ldr	r3, [r7, #4]
 3937 00bc DA6E     		ldr	r2, [r3, #108]
 3938 00be 7B68     		ldr	r3, [r7, #4]
 3939 00c0 1A67     		str	r2, [r3, #112]
1524:../lwip-1.4.1/src/core/tcp.c **** #if TCP_OVERSIZE
1525:../lwip-1.4.1/src/core/tcp.c ****     pcb->unsent_oversize = 0;
 3940              		.loc 1 1525 0
 3941 00c2 7B68     		ldr	r3, [r7, #4]
 3942 00c4 0022     		movs	r2, #0
 3943 00c6 A3F86A20 		strh	r2, [r3, #106]	@ movhi
 3944              	.L232:
1526:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_OVERSIZE */
1527:../lwip-1.4.1/src/core/tcp.c ****   }
1528:../lwip-1.4.1/src/core/tcp.c **** }
 3945              		.loc 1 1528 0
 3946 00ca 1037     		adds	r7, r7, #16
 3947              		.cfi_def_cfa_offset 8
 3948 00cc BD46     		mov	sp, r7
 3949              		.cfi_def_cfa_register 13
 3950              		@ sp needed
 3951 00ce 80BD     		pop	{r7, pc}
 3952              	.L241:
 3953              		.align	2
 3954              	.L240:
 3955 00d0 00000000 		.word	tcp_listen_pcbs
 3956              		.cfi_endproc
 3957              	.LFE32:
 3959              		.section	.text.tcp_pcb_remove,"ax",%progbits
 3960              		.align	2
 3961              		.global	tcp_pcb_remove
 3962              		.thumb
 3963              		.thumb_func
 3965              	tcp_pcb_remove:
 3966              	.LFB33:
1529:../lwip-1.4.1/src/core/tcp.c **** 
1530:../lwip-1.4.1/src/core/tcp.c **** /**
1531:../lwip-1.4.1/src/core/tcp.c ****  * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.
1532:../lwip-1.4.1/src/core/tcp.c ****  *
1533:../lwip-1.4.1/src/core/tcp.c ****  * @param pcblist PCB list to purge.
1534:../lwip-1.4.1/src/core/tcp.c ****  * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
1535:../lwip-1.4.1/src/core/tcp.c ****  */
1536:../lwip-1.4.1/src/core/tcp.c **** void
1537:../lwip-1.4.1/src/core/tcp.c **** tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
1538:../lwip-1.4.1/src/core/tcp.c **** {
 3967              		.loc 1 1538 0
 3968              		.cfi_startproc
 3969              		@ args = 0, pretend = 0, frame = 8
 3970              		@ frame_needed = 1, uses_anonymous_args = 0
 3971 0000 80B5     		push	{r7, lr}
 3972              		.cfi_def_cfa_offset 8
 3973              		.cfi_offset 7, -8
 3974              		.cfi_offset 14, -4
 3975 0002 82B0     		sub	sp, sp, #8
 3976              		.cfi_def_cfa_offset 16
 3977 0004 00AF     		add	r7, sp, #0
 3978              		.cfi_def_cfa_register 7
 3979 0006 7860     		str	r0, [r7, #4]
 3980 0008 3960     		str	r1, [r7]
1539:../lwip-1.4.1/src/core/tcp.c ****   TCP_RMV(pcblist, pcb);
 3981              		.loc 1 1539 0
 3982 000a 7B68     		ldr	r3, [r7, #4]
 3983 000c 1A68     		ldr	r2, [r3]
 3984 000e 3B68     		ldr	r3, [r7]
 3985 0010 9A42     		cmp	r2, r3
 3986 0012 05D1     		bne	.L243
 3987              		.loc 1 1539 0 is_stmt 0 discriminator 1
 3988 0014 7B68     		ldr	r3, [r7, #4]
 3989 0016 1B68     		ldr	r3, [r3]
 3990 0018 DA68     		ldr	r2, [r3, #12]
 3991 001a 7B68     		ldr	r3, [r7, #4]
 3992 001c 1A60     		str	r2, [r3]
 3993 001e 19E0     		b	.L244
 3994              	.L243:
 3995              		.loc 1 1539 0 discriminator 2
 3996 0020 7B68     		ldr	r3, [r7, #4]
 3997 0022 1B68     		ldr	r3, [r3]
 3998 0024 1F4A     		ldr	r2, .L250
 3999 0026 1360     		str	r3, [r2]
 4000 0028 10E0     		b	.L245
 4001              	.L247:
 4002              		.loc 1 1539 0 discriminator 9
 4003 002a 1E4B     		ldr	r3, .L250
 4004 002c 1B68     		ldr	r3, [r3]
 4005 002e DA68     		ldr	r2, [r3, #12]
 4006 0030 3B68     		ldr	r3, [r7]
 4007 0032 9A42     		cmp	r2, r3
 4008 0034 05D1     		bne	.L246
 4009              		.loc 1 1539 0 discriminator 5
 4010 0036 1B4B     		ldr	r3, .L250
 4011 0038 1B68     		ldr	r3, [r3]
 4012 003a 3A68     		ldr	r2, [r7]
 4013 003c D268     		ldr	r2, [r2, #12]
 4014 003e DA60     		str	r2, [r3, #12]
 4015 0040 08E0     		b	.L244
 4016              	.L246:
 4017              		.loc 1 1539 0 discriminator 6
 4018 0042 184B     		ldr	r3, .L250
 4019 0044 1B68     		ldr	r3, [r3]
 4020 0046 DB68     		ldr	r3, [r3, #12]
 4021 0048 164A     		ldr	r2, .L250
 4022 004a 1360     		str	r3, [r2]
 4023              	.L245:
 4024              		.loc 1 1539 0 discriminator 8
 4025 004c 154B     		ldr	r3, .L250
 4026 004e 1B68     		ldr	r3, [r3]
 4027 0050 002B     		cmp	r3, #0
 4028 0052 EAD1     		bne	.L247
 4029              	.L244:
 4030              		.loc 1 1539 0 discriminator 10
 4031 0054 3B68     		ldr	r3, [r7]
 4032 0056 0022     		movs	r2, #0
 4033 0058 DA60     		str	r2, [r3, #12]
1540:../lwip-1.4.1/src/core/tcp.c **** 
1541:../lwip-1.4.1/src/core/tcp.c ****   tcp_pcb_purge(pcb);
 4034              		.loc 1 1541 0 is_stmt 1 discriminator 10
 4035 005a 3868     		ldr	r0, [r7]
 4036 005c FFF7FEFF 		bl	tcp_pcb_purge
1542:../lwip-1.4.1/src/core/tcp.c ****   
1543:../lwip-1.4.1/src/core/tcp.c ****   /* if there is an outstanding delayed ACKs, send it */
1544:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state != TIME_WAIT &&
 4037              		.loc 1 1544 0 discriminator 10
 4038 0060 3B68     		ldr	r3, [r7]
 4039 0062 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 4040 0064 0A2B     		cmp	r3, #10
 4041 0066 13D0     		beq	.L248
1545:../lwip-1.4.1/src/core/tcp.c ****      pcb->state != LISTEN &&
 4042              		.loc 1 1545 0 discriminator 1
 4043 0068 3B68     		ldr	r3, [r7]
 4044 006a 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
1544:../lwip-1.4.1/src/core/tcp.c ****      pcb->state != LISTEN &&
 4045              		.loc 1 1544 0 discriminator 1
 4046 006c 012B     		cmp	r3, #1
 4047 006e 0FD0     		beq	.L248
1546:../lwip-1.4.1/src/core/tcp.c ****      pcb->flags & TF_ACK_DELAY) {
 4048              		.loc 1 1546 0
 4049 0070 3B68     		ldr	r3, [r7]
 4050 0072 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 4051 0074 03F00103 		and	r3, r3, #1
1545:../lwip-1.4.1/src/core/tcp.c ****      pcb->state != LISTEN &&
 4052              		.loc 1 1545 0
 4053 0078 002B     		cmp	r3, #0
 4054 007a 09D0     		beq	.L248
1547:../lwip-1.4.1/src/core/tcp.c ****     pcb->flags |= TF_ACK_NOW;
 4055              		.loc 1 1547 0
 4056 007c 3B68     		ldr	r3, [r7]
 4057 007e 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 4058 0080 43F00203 		orr	r3, r3, #2
 4059 0084 DAB2     		uxtb	r2, r3
 4060 0086 3B68     		ldr	r3, [r7]
 4061 0088 9A77     		strb	r2, [r3, #30]
1548:../lwip-1.4.1/src/core/tcp.c ****     tcp_output(pcb);
 4062              		.loc 1 1548 0
 4063 008a 3868     		ldr	r0, [r7]
 4064 008c FFF7FEFF 		bl	tcp_output
 4065              	.L248:
1549:../lwip-1.4.1/src/core/tcp.c ****   }
1550:../lwip-1.4.1/src/core/tcp.c **** 
1551:../lwip-1.4.1/src/core/tcp.c ****   if (pcb->state != LISTEN) {
 4066              		.loc 1 1551 0
 4067 0090 3B68     		ldr	r3, [r7]
 4068 0092 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 4069 0094 012B     		cmp	r3, #1
1552:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
1553:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
1554:../lwip-1.4.1/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ
1555:../lwip-1.4.1/src/core/tcp.c ****     LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
1556:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
1557:../lwip-1.4.1/src/core/tcp.c ****   }
1558:../lwip-1.4.1/src/core/tcp.c **** 
1559:../lwip-1.4.1/src/core/tcp.c ****   pcb->state = CLOSED;
 4070              		.loc 1 1559 0
 4071 0096 3B68     		ldr	r3, [r7]
 4072 0098 0022     		movs	r2, #0
 4073 009a 1A76     		strb	r2, [r3, #24]
1560:../lwip-1.4.1/src/core/tcp.c **** 
1561:../lwip-1.4.1/src/core/tcp.c ****   LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
1562:../lwip-1.4.1/src/core/tcp.c **** }
 4074              		.loc 1 1562 0
 4075 009c 0837     		adds	r7, r7, #8
 4076              		.cfi_def_cfa_offset 8
 4077 009e BD46     		mov	sp, r7
 4078              		.cfi_def_cfa_register 13
 4079              		@ sp needed
 4080 00a0 80BD     		pop	{r7, pc}
 4081              	.L251:
 4082 00a2 00BF     		.align	2
 4083              	.L250:
 4084 00a4 00000000 		.word	tcp_tmp_pcb
 4085              		.cfi_endproc
 4086              	.LFE33:
 4088              		.section	.text.tcp_next_iss,"ax",%progbits
 4089              		.align	2
 4090              		.global	tcp_next_iss
 4091              		.thumb
 4092              		.thumb_func
 4094              	tcp_next_iss:
 4095              	.LFB34:
1563:../lwip-1.4.1/src/core/tcp.c **** 
1564:../lwip-1.4.1/src/core/tcp.c **** /**
1565:../lwip-1.4.1/src/core/tcp.c ****  * Calculates a new initial sequence number for new connections.
1566:../lwip-1.4.1/src/core/tcp.c ****  *
1567:../lwip-1.4.1/src/core/tcp.c ****  * @return u32_t pseudo random sequence number
1568:../lwip-1.4.1/src/core/tcp.c ****  */
1569:../lwip-1.4.1/src/core/tcp.c **** u32_t
1570:../lwip-1.4.1/src/core/tcp.c **** tcp_next_iss(void)
1571:../lwip-1.4.1/src/core/tcp.c **** {
 4096              		.loc 1 1571 0
 4097              		.cfi_startproc
 4098              		@ args = 0, pretend = 0, frame = 0
 4099              		@ frame_needed = 1, uses_anonymous_args = 0
 4100              		@ link register save eliminated.
 4101 0000 80B4     		push	{r7}
 4102              		.cfi_def_cfa_offset 4
 4103              		.cfi_offset 7, -4
 4104 0002 00AF     		add	r7, sp, #0
 4105              		.cfi_def_cfa_register 7
1572:../lwip-1.4.1/src/core/tcp.c ****   static u32_t iss = 6510;
1573:../lwip-1.4.1/src/core/tcp.c ****   
1574:../lwip-1.4.1/src/core/tcp.c ****   iss += tcp_ticks;       /* XXX */
 4106              		.loc 1 1574 0
 4107 0004 064B     		ldr	r3, .L254
 4108 0006 1A68     		ldr	r2, [r3]
 4109 0008 064B     		ldr	r3, .L254+4
 4110 000a 1B68     		ldr	r3, [r3]
 4111 000c 1344     		add	r3, r3, r2
 4112 000e 044A     		ldr	r2, .L254
 4113 0010 1360     		str	r3, [r2]
1575:../lwip-1.4.1/src/core/tcp.c ****   return iss;
 4114              		.loc 1 1575 0
 4115 0012 034B     		ldr	r3, .L254
 4116 0014 1B68     		ldr	r3, [r3]
1576:../lwip-1.4.1/src/core/tcp.c **** }
 4117              		.loc 1 1576 0
 4118 0016 1846     		mov	r0, r3
 4119 0018 BD46     		mov	sp, r7
 4120              		.cfi_def_cfa_register 13
 4121              		@ sp needed
 4122 001a 5DF8047B 		ldr	r7, [sp], #4
 4123              		.cfi_restore 7
 4124              		.cfi_def_cfa_offset 0
 4125 001e 7047     		bx	lr
 4126              	.L255:
 4127              		.align	2
 4128              	.L254:
 4129 0020 04000000 		.word	iss.5888
 4130 0024 00000000 		.word	tcp_ticks
 4131              		.cfi_endproc
 4132              	.LFE34:
 4134              		.section	.text.tcp_eff_send_mss,"ax",%progbits
 4135              		.align	2
 4136              		.global	tcp_eff_send_mss
 4137              		.thumb
 4138              		.thumb_func
 4140              	tcp_eff_send_mss:
 4141              	.LFB35:
1577:../lwip-1.4.1/src/core/tcp.c **** 
1578:../lwip-1.4.1/src/core/tcp.c **** #if TCP_CALCULATE_EFF_SEND_MSS
1579:../lwip-1.4.1/src/core/tcp.c **** /**
1580:../lwip-1.4.1/src/core/tcp.c ****  * Calcluates the effective send mss that can be used for a specific IP address
1581:../lwip-1.4.1/src/core/tcp.c ****  * by using ip_route to determin the netif used to send to the address and
1582:../lwip-1.4.1/src/core/tcp.c ****  * calculating the minimum of TCP_MSS and that netif's mtu (if set).
1583:../lwip-1.4.1/src/core/tcp.c ****  */
1584:../lwip-1.4.1/src/core/tcp.c **** u16_t
1585:../lwip-1.4.1/src/core/tcp.c **** tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
1586:../lwip-1.4.1/src/core/tcp.c **** {
 4142              		.loc 1 1586 0
 4143              		.cfi_startproc
 4144              		@ args = 0, pretend = 0, frame = 16
 4145              		@ frame_needed = 1, uses_anonymous_args = 0
 4146 0000 80B5     		push	{r7, lr}
 4147              		.cfi_def_cfa_offset 8
 4148              		.cfi_offset 7, -8
 4149              		.cfi_offset 14, -4
 4150 0002 84B0     		sub	sp, sp, #16
 4151              		.cfi_def_cfa_offset 24
 4152 0004 00AF     		add	r7, sp, #0
 4153              		.cfi_def_cfa_register 7
 4154 0006 0346     		mov	r3, r0
 4155 0008 3960     		str	r1, [r7]
 4156 000a FB80     		strh	r3, [r7, #6]	@ movhi
1587:../lwip-1.4.1/src/core/tcp.c ****   u16_t mss_s;
1588:../lwip-1.4.1/src/core/tcp.c ****   struct netif *outif;
1589:../lwip-1.4.1/src/core/tcp.c **** 
1590:../lwip-1.4.1/src/core/tcp.c ****   outif = ip_route(addr);
 4157              		.loc 1 1590 0
 4158 000c 3868     		ldr	r0, [r7]
 4159 000e FFF7FEFF 		bl	ip_route
 4160 0012 F860     		str	r0, [r7, #12]
1591:../lwip-1.4.1/src/core/tcp.c ****   if ((outif != NULL) && (outif->mtu != 0)) {
 4161              		.loc 1 1591 0
 4162 0014 FB68     		ldr	r3, [r7, #12]
 4163 0016 002B     		cmp	r3, #0
 4164 0018 0DD0     		beq	.L257
 4165              		.loc 1 1591 0 is_stmt 0 discriminator 1
 4166 001a FB68     		ldr	r3, [r7, #12]
 4167 001c 1B8C     		ldrh	r3, [r3, #32]
 4168 001e 002B     		cmp	r3, #0
 4169 0020 09D0     		beq	.L257
1592:../lwip-1.4.1/src/core/tcp.c ****     mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 4170              		.loc 1 1592 0 is_stmt 1
 4171 0022 FB68     		ldr	r3, [r7, #12]
 4172 0024 1B8C     		ldrh	r3, [r3, #32]
 4173 0026 283B     		subs	r3, r3, #40
 4174 0028 7B81     		strh	r3, [r7, #10]	@ movhi
1593:../lwip-1.4.1/src/core/tcp.c ****     /* RFC 1122, chap 4.2.2.6:
1594:../lwip-1.4.1/src/core/tcp.c ****      * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
1595:../lwip-1.4.1/src/core/tcp.c ****      * We correct for TCP options in tcp_write(), and don't support IP options.
1596:../lwip-1.4.1/src/core/tcp.c ****      */
1597:../lwip-1.4.1/src/core/tcp.c ****     sendmss = LWIP_MIN(sendmss, mss_s);
 4175              		.loc 1 1597 0
 4176 002a 7A89     		ldrh	r2, [r7, #10]
 4177 002c FB88     		ldrh	r3, [r7, #6]
 4178 002e 9342     		cmp	r3, r2
 4179 0030 28BF     		it	cs
 4180 0032 1346     		movcs	r3, r2
 4181 0034 FB80     		strh	r3, [r7, #6]	@ movhi
 4182              	.L257:
1598:../lwip-1.4.1/src/core/tcp.c ****   }
1599:../lwip-1.4.1/src/core/tcp.c ****   return sendmss;
 4183              		.loc 1 1599 0
 4184 0036 FB88     		ldrh	r3, [r7, #6]
1600:../lwip-1.4.1/src/core/tcp.c **** }
 4185              		.loc 1 1600 0
 4186 0038 1846     		mov	r0, r3
 4187 003a 1037     		adds	r7, r7, #16
 4188              		.cfi_def_cfa_offset 8
 4189 003c BD46     		mov	sp, r7
 4190              		.cfi_def_cfa_register 13
 4191              		@ sp needed
 4192 003e 80BD     		pop	{r7, pc}
 4193              		.cfi_endproc
 4194              	.LFE35:
 4196              		.section	.text.tcp_debug_state_str,"ax",%progbits
 4197              		.align	2
 4198              		.global	tcp_debug_state_str
 4199              		.thumb
 4200              		.thumb_func
 4202              	tcp_debug_state_str:
 4203              	.LFB36:
1601:../lwip-1.4.1/src/core/tcp.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
1602:../lwip-1.4.1/src/core/tcp.c **** 
1603:../lwip-1.4.1/src/core/tcp.c **** const char*
1604:../lwip-1.4.1/src/core/tcp.c **** tcp_debug_state_str(enum tcp_state s)
1605:../lwip-1.4.1/src/core/tcp.c **** {
 4204              		.loc 1 1605 0
 4205              		.cfi_startproc
 4206              		@ args = 0, pretend = 0, frame = 8
 4207              		@ frame_needed = 1, uses_anonymous_args = 0
 4208              		@ link register save eliminated.
 4209 0000 80B4     		push	{r7}
 4210              		.cfi_def_cfa_offset 4
 4211              		.cfi_offset 7, -4
 4212 0002 83B0     		sub	sp, sp, #12
 4213              		.cfi_def_cfa_offset 16
 4214 0004 00AF     		add	r7, sp, #0
 4215              		.cfi_def_cfa_register 7
 4216 0006 0346     		mov	r3, r0
 4217 0008 FB71     		strb	r3, [r7, #7]
1606:../lwip-1.4.1/src/core/tcp.c ****   return tcp_state_str[s];
 4218              		.loc 1 1606 0
 4219 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4220 000c 044A     		ldr	r2, .L261
 4221 000e 52F82330 		ldr	r3, [r2, r3, lsl #2]
1607:../lwip-1.4.1/src/core/tcp.c **** }
 4222              		.loc 1 1607 0
 4223 0012 1846     		mov	r0, r3
 4224 0014 0C37     		adds	r7, r7, #12
 4225              		.cfi_def_cfa_offset 4
 4226 0016 BD46     		mov	sp, r7
 4227              		.cfi_def_cfa_register 13
 4228              		@ sp needed
 4229 0018 5DF8047B 		ldr	r7, [sp], #4
 4230              		.cfi_restore 7
 4231              		.cfi_def_cfa_offset 0
 4232 001c 7047     		bx	lr
 4233              	.L262:
 4234 001e 00BF     		.align	2
 4235              	.L261:
 4236 0020 00000000 		.word	tcp_state_str
 4237              		.cfi_endproc
 4238              	.LFE36:
 4240              		.data
 4241 0002 0000     		.align	2
 4244              	iss.5888:
 4245 0004 6E190000 		.word	6510
 4246              		.text
 4247              	.Letext0:
 4248              		.file 2 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\port/arch/cc.h"
 4249              		.file 3 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/mem.h"
 4250              		.file 4 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip/
 4251              		.file 5 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/err.h"
 4252              		.file 6 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/pbuf.h
 4253              		.file 7 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/netif.
 4254              		.file 8 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/tcp.h"
 4255              		.file 9 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/tcp_im
 4256              		.file 10 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/stats
 4257              		.file 11 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/memp.
DEFINED SYMBOLS
                            *ABS*:00000000 tcp.c
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:56     .rodata:00000078 tcp_state_str
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:20     .rodata:00000000 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:69     .data:00000000 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:72     .data:00000000 tcp_port
                            *COM*:00000004 tcp_ticks
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:80     .rodata:000000a4 tcp_backoff
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:98     .rodata:000000b4 tcp_persist_backoff
                            *COM*:00000004 tcp_bound_pcbs
                            *COM*:00000004 tcp_listen_pcbs
                            *COM*:00000004 tcp_active_pcbs
                            *COM*:00000004 tcp_tw_pcbs
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:114    .rodata:000000bc tcp_pcb_lists
                            *COM*:00000004 tcp_tmp_pcb
                            *COM*:00000001 tcp_active_pcbs_changed
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:122    .bss:00000000 tcp_timer
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:123    .bss:00000000 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:124    .bss:00000001 tcp_timer_ctr
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:127    .text.tcp_init:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:132    .text.tcp_init:00000000 tcp_init
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:157    .text.tcp_tmr:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:162    .text.tcp_tmr:00000000 tcp_tmr
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2619   .text.tcp_fasttmr:00000000 tcp_fasttmr
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1936   .text.tcp_slowtmr:00000000 tcp_slowtmr
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:196    .text.tcp_tmr:00000028 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:201    .text.tcp_close_shutdown:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:205    .text.tcp_close_shutdown:00000000 tcp_close_shutdown
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3803   .text.tcp_pcb_purge:00000000 tcp_pcb_purge
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:365    .text.tcp_close_shutdown:000000f4 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:373    .text.tcp_close_shutdown:00000114 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3965   .text.tcp_pcb_remove:00000000 tcp_pcb_remove
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:574    .text.tcp_close_shutdown:00000238 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:584    .text.tcp_close:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:589    .text.tcp_close:00000000 tcp_close
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:634    .text.tcp_shutdown:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:639    .text.tcp_shutdown:00000000 tcp_shutdown
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:745    .text.tcp_abandon:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:750    .text.tcp_abandon:00000000 tcp_abandon
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2885   .text.tcp_segs_free:00000000 tcp_segs_free
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:883    .text.tcp_abandon:000000c4 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:890    .text.tcp_abort:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:895    .text.tcp_abort:00000000 tcp_abort
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:925    .text.tcp_bind:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:930    .text.tcp_bind:00000000 tcp_bind
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1533   .text.tcp_new_port:00000000 tcp_new_port
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1088   .text.tcp_bind:000000d4 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1094   .text.tcp_accept_null:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1098   .text.tcp_accept_null:00000000 tcp_accept_null
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1134   .text.tcp_listen_with_backlog:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1139   .text.tcp_listen_with_backlog:00000000 tcp_listen_with_backlog
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1340   .text.tcp_listen_with_backlog:0000011c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1348   .text.tcp_update_rcv_ann_wnd:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1353   .text.tcp_update_rcv_ann_wnd:00000000 tcp_update_rcv_ann_wnd
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1456   .text.tcp_recved:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1461   .text.tcp_recved:00000000 tcp_recved
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1529   .text.tcp_new_port:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1636   .text.tcp_new_port:00000084 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1642   .text.tcp_connect:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1647   .text.tcp_connect:00000000 tcp_connect
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4094   .text.tcp_next_iss:00000000 tcp_next_iss
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4140   .text.tcp_eff_send_mss:00000000 tcp_eff_send_mss
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1923   .text.tcp_connect:000001a8 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:1931   .text.tcp_slowtmr:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2249   .text.tcp_slowtmr:00000210 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2257   .text.tcp_slowtmr:00000228 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2604   .text.tcp_slowtmr:0000044c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2614   .text.tcp_fasttmr:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2740   .text.tcp_process_refused_data:00000000 tcp_process_refused_data
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2728   .text.tcp_fasttmr:00000094 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2735   .text.tcp_process_refused_data:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3084   .text.tcp_recv_null:00000000 tcp_recv_null
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2880   .text.tcp_segs_free:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2936   .text.tcp_seg_free:00000000 tcp_seg_free
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2931   .text.tcp_seg_free:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2982   .text.tcp_setprio:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:2987   .text.tcp_setprio:00000000 tcp_setprio
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3022   .text.tcp_seg_copy:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3027   .text.tcp_seg_copy:00000000 tcp_seg_copy
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3079   .text.tcp_recv_null:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3143   .text.tcp_kill_prio:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3147   .text.tcp_kill_prio:00000000 tcp_kill_prio
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3243   .text.tcp_kill_prio:00000078 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3249   .text.tcp_kill_timewait:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3253   .text.tcp_kill_timewait:00000000 tcp_kill_timewait
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3326   .text.tcp_kill_timewait:00000054 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3332   .text.tcp_alloc:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3337   .text.tcp_alloc:00000000 tcp_alloc
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3521   .text.tcp_alloc:00000130 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3530   .text.tcp_new:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3535   .text.tcp_new:00000000 tcp_new
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3558   .text.tcp_arg:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3563   .text.tcp_arg:00000000 tcp_arg
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3597   .text.tcp_recv:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3602   .text.tcp_recv:00000000 tcp_recv
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3636   .text.tcp_sent:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3641   .text.tcp_sent:00000000 tcp_sent
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3675   .text.tcp_err:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3680   .text.tcp_err:00000000 tcp_err
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3714   .text.tcp_accept:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3719   .text.tcp_accept:00000000 tcp_accept
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3753   .text.tcp_poll:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3758   .text.tcp_poll:00000000 tcp_poll
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3798   .text.tcp_pcb_purge:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3955   .text.tcp_pcb_purge:000000d0 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:3960   .text.tcp_pcb_remove:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4084   .text.tcp_pcb_remove:000000a4 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4089   .text.tcp_next_iss:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4129   .text.tcp_next_iss:00000020 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4244   .data:00000004 iss.5888
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4135   .text.tcp_eff_send_mss:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4197   .text.tcp_debug_state_str:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4202   .text.tcp_debug_state_str:00000000 tcp_debug_state_str
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccUaUK5B.s:4236   .text.tcp_debug_state_str:00000020 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.2d80f1b5ce3c69d13e258577ddf29668
                           .group:00000000 wm4.lwipopts.h.25.76e03deb318fbe54d896a83c1b611e55
                           .group:00000000 wm4.arch.h.33.6fa4aa86d33d1490ae882caef7316405
                           .group:00000000 wm4.cpu.h.33.0ec64ad8cd52614da6479c7936fa3efa
                           .group:00000000 wm4.cc.h.49.217a0c46a6dd8448cb36cccbf00f897f
                           .group:00000000 wm4.arch.h.52.2e97dbd839a1aa815d8c47878a7f8e2b
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.24.b2be5f53932a9c9d07787288b29b6d75
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.82.82b71f3f44c70e3a459d0f66642b05eb
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.68.ff6d7571d3ad75c55f15e26dbaa81e35
                           .group:00000000 wm4.debug.h.45.223028a5c052c9f879ffd43dd519f3f1
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.opt.h.76.0e16bb9c23144e1f631b5b5afa9a69f6
                           .group:00000000 wm4.def.h.33.d4208c3cd3e0fc64e20a8b9f95a681f3
                           .group:00000000 wm4.mem.h.33.ae21028c0b1f3dc3305003fc71edaf5a
                           .group:00000000 wm4.memp.h.34.a409f52ec6d44b5681de26eb10b0c08b
                           .group:00000000 wm4.memp_std.h.15.637bb4287b70e9d70dbd8dd3c6f62f3b
                           .group:00000000 wm4.ip_addr.h.33.906726af218ee6749c0aa25e08c3a1fe
                           .group:00000000 wm4.snmp.h.234.6a4a080df54387bf1e5d35751c02f16a
                           .group:00000000 wm4.err.h.33.909ff4b35439192d64931f0a04fc8fdb
                           .group:00000000 wm4.pbuf.h.45.444f43edbf93d1b2ead9ba1554355b0e
                           .group:00000000 wm4.netif.h.33.f0b62f0135b4c001826f0908df525042
                           .group:00000000 wm4.ip.h.48.c2e3a3e3a9e009c03a30eff6a88b0a33
                           .group:00000000 wm4.icmp.h.33.9c8da59f6edf08fae1a2f37336a6e965
                           .group:00000000 wm4.tcp.h.148.20c69d62fcb119a5d6bfd32bc982e4fb
                           .group:00000000 wm4.tcp_impl.h.33.0ce3dbbff4845a48c2d719f24d1c5713
                           .group:00000000 wm4.stats.h.33.e4d36fe09c96bf9e2f10f7a27b9fa99f

UNDEFINED SYMBOLS
tcp_rst
tcp_timer_needed
memp_free
tcp_send_fin
tcp_output
pbuf_free
memp_malloc
ip_route
tcp_enqueue_flags
tcp_zero_window_probe
tcp_rexmit_rto
tcp_keepalive
memcpy
pbuf_ref
memset
lwip_stats
