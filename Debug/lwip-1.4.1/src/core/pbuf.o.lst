   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"pbuf.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	pbuf_free_ooseq_pending,1,1
  19              		.section	.text.pbuf_free_ooseq,"ax",%progbits
  20              		.align	2
  21              		.global	pbuf_free_ooseq
  22              		.thumb
  23              		.thumb_func
  25              	pbuf_free_ooseq:
  26              	.LFB0:
  27              		.file 1 "../lwip-1.4.1/src/core/pbuf.c"
   1:../lwip-1.4.1/src/core/pbuf.c **** /**
   2:../lwip-1.4.1/src/core/pbuf.c ****  * @file
   3:../lwip-1.4.1/src/core/pbuf.c ****  * Packet buffer management
   4:../lwip-1.4.1/src/core/pbuf.c ****  *
   5:../lwip-1.4.1/src/core/pbuf.c ****  * Packets are built from the pbuf data structure. It supports dynamic
   6:../lwip-1.4.1/src/core/pbuf.c ****  * memory allocation for packet contents or can reference externally
   7:../lwip-1.4.1/src/core/pbuf.c ****  * managed packet contents both in RAM and ROM. Quick allocation for
   8:../lwip-1.4.1/src/core/pbuf.c ****  * incoming packets is provided through pools with fixed sized pbufs.
   9:../lwip-1.4.1/src/core/pbuf.c ****  *
  10:../lwip-1.4.1/src/core/pbuf.c ****  * A packet may span over multiple pbufs, chained as a singly linked
  11:../lwip-1.4.1/src/core/pbuf.c ****  * list. This is called a "pbuf chain".
  12:../lwip-1.4.1/src/core/pbuf.c ****  *
  13:../lwip-1.4.1/src/core/pbuf.c ****  * Multiple packets may be queued, also using this singly linked list.
  14:../lwip-1.4.1/src/core/pbuf.c ****  * This is called a "packet queue".
  15:../lwip-1.4.1/src/core/pbuf.c ****  * 
  16:../lwip-1.4.1/src/core/pbuf.c ****  * So, a packet queue consists of one or more pbuf chains, each of
  17:../lwip-1.4.1/src/core/pbuf.c ****  * which consist of one or more pbufs. CURRENTLY, PACKET QUEUES ARE
  18:../lwip-1.4.1/src/core/pbuf.c ****  * NOT SUPPORTED!!! Use helper structs to queue multiple packets.
  19:../lwip-1.4.1/src/core/pbuf.c ****  * 
  20:../lwip-1.4.1/src/core/pbuf.c ****  * The differences between a pbuf chain and a packet queue are very
  21:../lwip-1.4.1/src/core/pbuf.c ****  * precise but subtle. 
  22:../lwip-1.4.1/src/core/pbuf.c ****  *
  23:../lwip-1.4.1/src/core/pbuf.c ****  * The last pbuf of a packet has a ->tot_len field that equals the
  24:../lwip-1.4.1/src/core/pbuf.c ****  * ->len field. It can be found by traversing the list. If the last
  25:../lwip-1.4.1/src/core/pbuf.c ****  * pbuf of a packet has a ->next field other than NULL, more packets
  26:../lwip-1.4.1/src/core/pbuf.c ****  * are on the queue.
  27:../lwip-1.4.1/src/core/pbuf.c ****  *
  28:../lwip-1.4.1/src/core/pbuf.c ****  * Therefore, looping through a pbuf of a single packet, has an
  29:../lwip-1.4.1/src/core/pbuf.c ****  * loop end condition (tot_len == p->len), NOT (next == NULL).
  30:../lwip-1.4.1/src/core/pbuf.c ****  */
  31:../lwip-1.4.1/src/core/pbuf.c **** 
  32:../lwip-1.4.1/src/core/pbuf.c **** /*
  33:../lwip-1.4.1/src/core/pbuf.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  34:../lwip-1.4.1/src/core/pbuf.c ****  * All rights reserved.
  35:../lwip-1.4.1/src/core/pbuf.c ****  *
  36:../lwip-1.4.1/src/core/pbuf.c ****  * Redistribution and use in source and binary forms, with or without modification,
  37:../lwip-1.4.1/src/core/pbuf.c ****  * are permitted provided that the following conditions are met:
  38:../lwip-1.4.1/src/core/pbuf.c ****  *
  39:../lwip-1.4.1/src/core/pbuf.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  40:../lwip-1.4.1/src/core/pbuf.c ****  *    this list of conditions and the following disclaimer.
  41:../lwip-1.4.1/src/core/pbuf.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  42:../lwip-1.4.1/src/core/pbuf.c ****  *    this list of conditions and the following disclaimer in the documentation
  43:../lwip-1.4.1/src/core/pbuf.c ****  *    and/or other materials provided with the distribution.
  44:../lwip-1.4.1/src/core/pbuf.c ****  * 3. The name of the author may not be used to endorse or promote products
  45:../lwip-1.4.1/src/core/pbuf.c ****  *    derived from this software without specific prior written permission.
  46:../lwip-1.4.1/src/core/pbuf.c ****  *
  47:../lwip-1.4.1/src/core/pbuf.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  48:../lwip-1.4.1/src/core/pbuf.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  49:../lwip-1.4.1/src/core/pbuf.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  50:../lwip-1.4.1/src/core/pbuf.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  51:../lwip-1.4.1/src/core/pbuf.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  52:../lwip-1.4.1/src/core/pbuf.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  53:../lwip-1.4.1/src/core/pbuf.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  54:../lwip-1.4.1/src/core/pbuf.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  55:../lwip-1.4.1/src/core/pbuf.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  56:../lwip-1.4.1/src/core/pbuf.c ****  * OF SUCH DAMAGE.
  57:../lwip-1.4.1/src/core/pbuf.c ****  *
  58:../lwip-1.4.1/src/core/pbuf.c ****  * This file is part of the lwIP TCP/IP stack.
  59:../lwip-1.4.1/src/core/pbuf.c ****  *
  60:../lwip-1.4.1/src/core/pbuf.c ****  * Author: Adam Dunkels <adam@sics.se>
  61:../lwip-1.4.1/src/core/pbuf.c ****  *
  62:../lwip-1.4.1/src/core/pbuf.c ****  */
  63:../lwip-1.4.1/src/core/pbuf.c **** 
  64:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/opt.h"
  65:../lwip-1.4.1/src/core/pbuf.c **** 
  66:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/stats.h"
  67:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/def.h"
  68:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/mem.h"
  69:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/memp.h"
  70:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/pbuf.h"
  71:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/sys.h"
  72:../lwip-1.4.1/src/core/pbuf.c **** #include "arch/perf.h"
  73:../lwip-1.4.1/src/core/pbuf.c **** #if LWIP_TCP && TCP_QUEUE_OOSEQ
  74:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/tcp_impl.h"
  75:../lwip-1.4.1/src/core/pbuf.c **** #endif
  76:../lwip-1.4.1/src/core/pbuf.c **** #if LWIP_CHECKSUM_ON_COPY
  77:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/inet_chksum.h"
  78:../lwip-1.4.1/src/core/pbuf.c **** #endif
  79:../lwip-1.4.1/src/core/pbuf.c **** 
  80:../lwip-1.4.1/src/core/pbuf.c **** #include <string.h>
  81:../lwip-1.4.1/src/core/pbuf.c **** 
  82:../lwip-1.4.1/src/core/pbuf.c **** #define SIZEOF_STRUCT_PBUF        LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf))
  83:../lwip-1.4.1/src/core/pbuf.c **** /* Since the pool is created in memp, PBUF_POOL_BUFSIZE will be automatically
  84:../lwip-1.4.1/src/core/pbuf.c ****    aligned there. Therefore, PBUF_POOL_BUFSIZE_ALIGNED can be used here. */
  85:../lwip-1.4.1/src/core/pbuf.c **** #define PBUF_POOL_BUFSIZE_ALIGNED LWIP_MEM_ALIGN_SIZE(PBUF_POOL_BUFSIZE)
  86:../lwip-1.4.1/src/core/pbuf.c **** 
  87:../lwip-1.4.1/src/core/pbuf.c **** #if !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ
  88:../lwip-1.4.1/src/core/pbuf.c **** #define PBUF_POOL_IS_EMPTY()
  89:../lwip-1.4.1/src/core/pbuf.c **** #else /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
  90:../lwip-1.4.1/src/core/pbuf.c **** 
  91:../lwip-1.4.1/src/core/pbuf.c **** #if !NO_SYS
  92:../lwip-1.4.1/src/core/pbuf.c **** #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  93:../lwip-1.4.1/src/core/pbuf.c **** #include "lwip/tcpip.h"
  94:../lwip-1.4.1/src/core/pbuf.c **** #define PBUF_POOL_FREE_OOSEQ_QUEUE_CALL()  do { \
  95:../lwip-1.4.1/src/core/pbuf.c ****   if(tcpip_callback_with_block(pbuf_free_ooseq_callback, NULL, 0) != ERR_OK) { \
  96:../lwip-1.4.1/src/core/pbuf.c ****       SYS_ARCH_PROTECT(old_level); \
  97:../lwip-1.4.1/src/core/pbuf.c ****       pbuf_free_ooseq_pending = 0; \
  98:../lwip-1.4.1/src/core/pbuf.c ****       SYS_ARCH_UNPROTECT(old_level); \
  99:../lwip-1.4.1/src/core/pbuf.c ****   } } while(0)
 100:../lwip-1.4.1/src/core/pbuf.c **** #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
 101:../lwip-1.4.1/src/core/pbuf.c **** #endif /* !NO_SYS */
 102:../lwip-1.4.1/src/core/pbuf.c **** 
 103:../lwip-1.4.1/src/core/pbuf.c **** volatile u8_t pbuf_free_ooseq_pending;
 104:../lwip-1.4.1/src/core/pbuf.c **** #define PBUF_POOL_IS_EMPTY() pbuf_pool_is_empty()
 105:../lwip-1.4.1/src/core/pbuf.c **** 
 106:../lwip-1.4.1/src/core/pbuf.c **** /**
 107:../lwip-1.4.1/src/core/pbuf.c ****  * Attempt to reclaim some memory from queued out-of-sequence TCP segments
 108:../lwip-1.4.1/src/core/pbuf.c ****  * if we run out of pool pbufs. It's better to give priority to new packets
 109:../lwip-1.4.1/src/core/pbuf.c ****  * if we're running out.
 110:../lwip-1.4.1/src/core/pbuf.c ****  *
 111:../lwip-1.4.1/src/core/pbuf.c ****  * This must be done in the correct thread context therefore this function
 112:../lwip-1.4.1/src/core/pbuf.c ****  * can only be used with NO_SYS=0 and through tcpip_callback.
 113:../lwip-1.4.1/src/core/pbuf.c ****  */
 114:../lwip-1.4.1/src/core/pbuf.c **** #if !NO_SYS
 115:../lwip-1.4.1/src/core/pbuf.c **** static
 116:../lwip-1.4.1/src/core/pbuf.c **** #endif /* !NO_SYS */
 117:../lwip-1.4.1/src/core/pbuf.c **** void
 118:../lwip-1.4.1/src/core/pbuf.c **** pbuf_free_ooseq(void)
 119:../lwip-1.4.1/src/core/pbuf.c **** {
  28              		.loc 1 119 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 82B0     		sub	sp, sp, #8
  37              		.cfi_def_cfa_offset 16
  38 0004 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
 120:../lwip-1.4.1/src/core/pbuf.c ****   struct tcp_pcb* pcb;
 121:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 122:../lwip-1.4.1/src/core/pbuf.c **** 
 123:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_PROTECT(old_level);
 124:../lwip-1.4.1/src/core/pbuf.c ****   pbuf_free_ooseq_pending = 0;
  40              		.loc 1 124 0
  41 0006 0E4B     		ldr	r3, .L6
  42 0008 0022     		movs	r2, #0
  43 000a 1A70     		strb	r2, [r3]
 125:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_UNPROTECT(old_level);
 126:../lwip-1.4.1/src/core/pbuf.c **** 
 127:../lwip-1.4.1/src/core/pbuf.c ****   for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
  44              		.loc 1 127 0
  45 000c 0D4B     		ldr	r3, .L6+4
  46 000e 1B68     		ldr	r3, [r3]
  47 0010 7B60     		str	r3, [r7, #4]
  48 0012 0FE0     		b	.L2
  49              	.L5:
 128:../lwip-1.4.1/src/core/pbuf.c ****     if (NULL != pcb->ooseq) {
  50              		.loc 1 128 0
  51 0014 7B68     		ldr	r3, [r7, #4]
  52 0016 5B6F     		ldr	r3, [r3, #116]
  53 0018 002B     		cmp	r3, #0
  54 001a 08D0     		beq	.L3
 129:../lwip-1.4.1/src/core/pbuf.c ****       /** Free the ooseq pbufs of one PCB only */
 130:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n")
 131:../lwip-1.4.1/src/core/pbuf.c ****       tcp_segs_free(pcb->ooseq);
  55              		.loc 1 131 0
  56 001c 7B68     		ldr	r3, [r7, #4]
  57 001e 5B6F     		ldr	r3, [r3, #116]
  58 0020 1846     		mov	r0, r3
  59 0022 FFF7FEFF 		bl	tcp_segs_free
 132:../lwip-1.4.1/src/core/pbuf.c ****       pcb->ooseq = NULL;
  60              		.loc 1 132 0
  61 0026 7B68     		ldr	r3, [r7, #4]
  62 0028 0022     		movs	r2, #0
  63 002a 5A67     		str	r2, [r3, #116]
 133:../lwip-1.4.1/src/core/pbuf.c ****       return;
  64              		.loc 1 133 0
  65 002c 05E0     		b	.L1
  66              	.L3:
 127:../lwip-1.4.1/src/core/pbuf.c ****     if (NULL != pcb->ooseq) {
  67              		.loc 1 127 0 discriminator 2
  68 002e 7B68     		ldr	r3, [r7, #4]
  69 0030 DB68     		ldr	r3, [r3, #12]
  70 0032 7B60     		str	r3, [r7, #4]
  71              	.L2:
 127:../lwip-1.4.1/src/core/pbuf.c ****     if (NULL != pcb->ooseq) {
  72              		.loc 1 127 0 is_stmt 0 discriminator 1
  73 0034 7B68     		ldr	r3, [r7, #4]
  74 0036 002B     		cmp	r3, #0
  75 0038 ECD1     		bne	.L5
  76              	.L1:
 134:../lwip-1.4.1/src/core/pbuf.c ****     }
 135:../lwip-1.4.1/src/core/pbuf.c ****   }
 136:../lwip-1.4.1/src/core/pbuf.c **** }
  77              		.loc 1 136 0 is_stmt 1
  78 003a 0837     		adds	r7, r7, #8
  79              		.cfi_def_cfa_offset 8
  80 003c BD46     		mov	sp, r7
  81              		.cfi_def_cfa_register 13
  82              		@ sp needed
  83 003e 80BD     		pop	{r7, pc}
  84              	.L7:
  85              		.align	2
  86              	.L6:
  87 0040 00000000 		.word	pbuf_free_ooseq_pending
  88 0044 00000000 		.word	tcp_active_pcbs
  89              		.cfi_endproc
  90              	.LFE0:
  92              		.section	.text.pbuf_pool_is_empty,"ax",%progbits
  93              		.align	2
  94              		.thumb
  95              		.thumb_func
  97              	pbuf_pool_is_empty:
  98              	.LFB1:
 137:../lwip-1.4.1/src/core/pbuf.c **** 
 138:../lwip-1.4.1/src/core/pbuf.c **** #if !NO_SYS
 139:../lwip-1.4.1/src/core/pbuf.c **** /**
 140:../lwip-1.4.1/src/core/pbuf.c ****  * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 141:../lwip-1.4.1/src/core/pbuf.c ****  */
 142:../lwip-1.4.1/src/core/pbuf.c **** static void
 143:../lwip-1.4.1/src/core/pbuf.c **** pbuf_free_ooseq_callback(void *arg)
 144:../lwip-1.4.1/src/core/pbuf.c **** {
 145:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_UNUSED_ARG(arg);
 146:../lwip-1.4.1/src/core/pbuf.c ****   pbuf_free_ooseq();
 147:../lwip-1.4.1/src/core/pbuf.c **** }
 148:../lwip-1.4.1/src/core/pbuf.c **** #endif /* !NO_SYS */
 149:../lwip-1.4.1/src/core/pbuf.c **** 
 150:../lwip-1.4.1/src/core/pbuf.c **** /** Queue a call to pbuf_free_ooseq if not already queued. */
 151:../lwip-1.4.1/src/core/pbuf.c **** static void
 152:../lwip-1.4.1/src/core/pbuf.c **** pbuf_pool_is_empty(void)
 153:../lwip-1.4.1/src/core/pbuf.c **** {
  99              		.loc 1 153 0
 100              		.cfi_startproc
 101              		@ args = 0, pretend = 0, frame = 0
 102              		@ frame_needed = 1, uses_anonymous_args = 0
 103              		@ link register save eliminated.
 104 0000 80B4     		push	{r7}
 105              		.cfi_def_cfa_offset 4
 106              		.cfi_offset 7, -4
 107 0002 00AF     		add	r7, sp, #0
 108              		.cfi_def_cfa_register 7
 154:../lwip-1.4.1/src/core/pbuf.c **** #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
 155:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 156:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_PROTECT(old_level);
 157:../lwip-1.4.1/src/core/pbuf.c ****   pbuf_free_ooseq_pending = 1;
 109              		.loc 1 157 0
 110 0004 034B     		ldr	r3, .L9
 111 0006 0122     		movs	r2, #1
 112 0008 1A70     		strb	r2, [r3]
 158:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_UNPROTECT(old_level);
 159:../lwip-1.4.1/src/core/pbuf.c **** #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
 160:../lwip-1.4.1/src/core/pbuf.c ****   u8_t queued;
 161:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 162:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_PROTECT(old_level);
 163:../lwip-1.4.1/src/core/pbuf.c ****   queued = pbuf_free_ooseq_pending;
 164:../lwip-1.4.1/src/core/pbuf.c ****   pbuf_free_ooseq_pending = 1;
 165:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_UNPROTECT(old_level);
 166:../lwip-1.4.1/src/core/pbuf.c **** 
 167:../lwip-1.4.1/src/core/pbuf.c ****   if(!queued) {
 168:../lwip-1.4.1/src/core/pbuf.c ****     /* queue a call to pbuf_free_ooseq if not already queued */
 169:../lwip-1.4.1/src/core/pbuf.c ****     PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 170:../lwip-1.4.1/src/core/pbuf.c ****   }
 171:../lwip-1.4.1/src/core/pbuf.c **** #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
 172:../lwip-1.4.1/src/core/pbuf.c **** }
 113              		.loc 1 172 0
 114 000a BD46     		mov	sp, r7
 115              		.cfi_def_cfa_register 13
 116              		@ sp needed
 117 000c 5DF8047B 		ldr	r7, [sp], #4
 118              		.cfi_restore 7
 119              		.cfi_def_cfa_offset 0
 120 0010 7047     		bx	lr
 121              	.L10:
 122 0012 00BF     		.align	2
 123              	.L9:
 124 0014 00000000 		.word	pbuf_free_ooseq_pending
 125              		.cfi_endproc
 126              	.LFE1:
 128              		.section	.text.pbuf_alloc,"ax",%progbits
 129              		.align	2
 130              		.global	pbuf_alloc
 131              		.thumb
 132              		.thumb_func
 134              	pbuf_alloc:
 135              	.LFB2:
 173:../lwip-1.4.1/src/core/pbuf.c **** #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
 174:../lwip-1.4.1/src/core/pbuf.c **** 
 175:../lwip-1.4.1/src/core/pbuf.c **** /**
 176:../lwip-1.4.1/src/core/pbuf.c ****  * Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type).
 177:../lwip-1.4.1/src/core/pbuf.c ****  *
 178:../lwip-1.4.1/src/core/pbuf.c ****  * The actual memory allocated for the pbuf is determined by the
 179:../lwip-1.4.1/src/core/pbuf.c ****  * layer at which the pbuf is allocated and the requested size
 180:../lwip-1.4.1/src/core/pbuf.c ****  * (from the size parameter).
 181:../lwip-1.4.1/src/core/pbuf.c ****  *
 182:../lwip-1.4.1/src/core/pbuf.c ****  * @param layer flag to define header size
 183:../lwip-1.4.1/src/core/pbuf.c ****  * @param length size of the pbuf's payload
 184:../lwip-1.4.1/src/core/pbuf.c ****  * @param type this parameter decides how and where the pbuf
 185:../lwip-1.4.1/src/core/pbuf.c ****  * should be allocated as follows:
 186:../lwip-1.4.1/src/core/pbuf.c ****  *
 187:../lwip-1.4.1/src/core/pbuf.c ****  * - PBUF_RAM: buffer memory for pbuf is allocated as one large
 188:../lwip-1.4.1/src/core/pbuf.c ****  *             chunk. This includes protocol headers as well.
 189:../lwip-1.4.1/src/core/pbuf.c ****  * - PBUF_ROM: no buffer memory is allocated for the pbuf, even for
 190:../lwip-1.4.1/src/core/pbuf.c ****  *             protocol headers. Additional headers must be prepended
 191:../lwip-1.4.1/src/core/pbuf.c ****  *             by allocating another pbuf and chain in to the front of
 192:../lwip-1.4.1/src/core/pbuf.c ****  *             the ROM pbuf. It is assumed that the memory used is really
 193:../lwip-1.4.1/src/core/pbuf.c ****  *             similar to ROM in that it is immutable and will not be
 194:../lwip-1.4.1/src/core/pbuf.c ****  *             changed. Memory which is dynamic should generally not
 195:../lwip-1.4.1/src/core/pbuf.c ****  *             be attached to PBUF_ROM pbufs. Use PBUF_REF instead.
 196:../lwip-1.4.1/src/core/pbuf.c ****  * - PBUF_REF: no buffer memory is allocated for the pbuf, even for
 197:../lwip-1.4.1/src/core/pbuf.c ****  *             protocol headers. It is assumed that the pbuf is only
 198:../lwip-1.4.1/src/core/pbuf.c ****  *             being used in a single thread. If the pbuf gets queued,
 199:../lwip-1.4.1/src/core/pbuf.c ****  *             then pbuf_take should be called to copy the buffer.
 200:../lwip-1.4.1/src/core/pbuf.c ****  * - PBUF_POOL: the pbuf is allocated as a pbuf chain, with pbufs from
 201:../lwip-1.4.1/src/core/pbuf.c ****  *              the pbuf pool that is allocated during pbuf_init().
 202:../lwip-1.4.1/src/core/pbuf.c ****  *
 203:../lwip-1.4.1/src/core/pbuf.c ****  * @return the allocated pbuf. If multiple pbufs where allocated, this
 204:../lwip-1.4.1/src/core/pbuf.c ****  * is the first pbuf of a pbuf chain.
 205:../lwip-1.4.1/src/core/pbuf.c ****  */
 206:../lwip-1.4.1/src/core/pbuf.c **** struct pbuf *
 207:../lwip-1.4.1/src/core/pbuf.c **** pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
 208:../lwip-1.4.1/src/core/pbuf.c **** {
 136              		.loc 1 208 0
 137              		.cfi_startproc
 138              		@ args = 0, pretend = 0, frame = 32
 139              		@ frame_needed = 1, uses_anonymous_args = 0
 140 0000 80B5     		push	{r7, lr}
 141              		.cfi_def_cfa_offset 8
 142              		.cfi_offset 7, -8
 143              		.cfi_offset 14, -4
 144 0002 88B0     		sub	sp, sp, #32
 145              		.cfi_def_cfa_offset 40
 146 0004 00AF     		add	r7, sp, #0
 147              		.cfi_def_cfa_register 7
 148 0006 0346     		mov	r3, r0
 149 0008 FB71     		strb	r3, [r7, #7]
 150 000a 0B46     		mov	r3, r1	@ movhi
 151 000c BB80     		strh	r3, [r7, #4]	@ movhi
 152 000e 1346     		mov	r3, r2
 153 0010 BB71     		strb	r3, [r7, #6]
 209:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *p, *q, *r;
 210:../lwip-1.4.1/src/core/pbuf.c ****   u16_t offset;
 211:../lwip-1.4.1/src/core/pbuf.c ****   s32_t rem_len; /* remaining length */
 212:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
 213:../lwip-1.4.1/src/core/pbuf.c **** 
 214:../lwip-1.4.1/src/core/pbuf.c ****   /* determine header offset */
 215:../lwip-1.4.1/src/core/pbuf.c ****   switch (layer) {
 154              		.loc 1 215 0
 155 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 156 0014 032B     		cmp	r3, #3
 157 0016 17D8     		bhi	.L12
 158 0018 01A2     		adr	r2, .L14
 159 001a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 160 001e 00BF     		.p2align 2
 161              	.L14:
 162 0020 31000000 		.word	.L13+1
 163 0024 37000000 		.word	.L15+1
 164 0028 3D000000 		.word	.L16+1
 165 002c 43000000 		.word	.L17+1
 166              		.p2align 1
 167              	.L13:
 216:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_TRANSPORT:
 217:../lwip-1.4.1/src/core/pbuf.c ****     /* add room for transport (often TCP) layer header */
 218:../lwip-1.4.1/src/core/pbuf.c ****     offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 168              		.loc 1 218 0
 169 0030 3623     		movs	r3, #54
 170 0032 FB82     		strh	r3, [r7, #22]	@ movhi
 219:../lwip-1.4.1/src/core/pbuf.c ****     break;
 171              		.loc 1 219 0
 172 0034 0AE0     		b	.L18
 173              	.L15:
 220:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_IP:
 221:../lwip-1.4.1/src/core/pbuf.c ****     /* add room for IP layer header */
 222:../lwip-1.4.1/src/core/pbuf.c ****     offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 174              		.loc 1 222 0
 175 0036 2223     		movs	r3, #34
 176 0038 FB82     		strh	r3, [r7, #22]	@ movhi
 223:../lwip-1.4.1/src/core/pbuf.c ****     break;
 177              		.loc 1 223 0
 178 003a 07E0     		b	.L18
 179              	.L16:
 224:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_LINK:
 225:../lwip-1.4.1/src/core/pbuf.c ****     /* add room for link layer header */
 226:../lwip-1.4.1/src/core/pbuf.c ****     offset = PBUF_LINK_HLEN;
 180              		.loc 1 226 0
 181 003c 0E23     		movs	r3, #14
 182 003e FB82     		strh	r3, [r7, #22]	@ movhi
 227:../lwip-1.4.1/src/core/pbuf.c ****     break;
 183              		.loc 1 227 0
 184 0040 04E0     		b	.L18
 185              	.L17:
 228:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_RAW:
 229:../lwip-1.4.1/src/core/pbuf.c ****     offset = 0;
 186              		.loc 1 229 0
 187 0042 0023     		movs	r3, #0
 188 0044 FB82     		strh	r3, [r7, #22]	@ movhi
 230:../lwip-1.4.1/src/core/pbuf.c ****     break;
 189              		.loc 1 230 0
 190 0046 01E0     		b	.L18
 191              	.L12:
 231:../lwip-1.4.1/src/core/pbuf.c ****   default:
 232:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 233:../lwip-1.4.1/src/core/pbuf.c ****     return NULL;
 192              		.loc 1 233 0
 193 0048 0023     		movs	r3, #0
 194 004a D4E0     		b	.L19
 195              	.L18:
 234:../lwip-1.4.1/src/core/pbuf.c ****   }
 235:../lwip-1.4.1/src/core/pbuf.c **** 
 236:../lwip-1.4.1/src/core/pbuf.c ****   switch (type) {
 196              		.loc 1 236 0
 197 004c BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 198 004e 032B     		cmp	r3, #3
 199 0050 00F2C880 		bhi	.L20
 200 0054 01A2     		adr	r2, .L22
 201 0056 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 202 005a 00BF     		.p2align 2
 203              	.L22:
 204 005c 53010000 		.word	.L21+1
 205 0060 B1010000 		.word	.L23+1
 206 0064 B1010000 		.word	.L23+1
 207 0068 6D000000 		.word	.L24+1
 208              		.p2align 1
 209              	.L24:
 237:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_POOL:
 238:../lwip-1.4.1/src/core/pbuf.c ****     /* allocate head of pbuf chain into p */
 239:../lwip-1.4.1/src/core/pbuf.c ****     p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 210              		.loc 1 239 0
 211 006c 0A20     		movs	r0, #10
 212 006e FFF7FEFF 		bl	memp_malloc
 213 0072 F861     		str	r0, [r7, #28]
 240:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
 241:../lwip-1.4.1/src/core/pbuf.c ****     if (p == NULL) {
 214              		.loc 1 241 0
 215 0074 FB69     		ldr	r3, [r7, #28]
 216 0076 002B     		cmp	r3, #0
 217 0078 03D1     		bne	.L25
 242:../lwip-1.4.1/src/core/pbuf.c ****       PBUF_POOL_IS_EMPTY();
 218              		.loc 1 242 0
 219 007a FFF7FEFF 		bl	pbuf_pool_is_empty
 243:../lwip-1.4.1/src/core/pbuf.c ****       return NULL;
 220              		.loc 1 243 0
 221 007e 0023     		movs	r3, #0
 222 0080 B9E0     		b	.L19
 223              	.L25:
 244:../lwip-1.4.1/src/core/pbuf.c ****     }
 245:../lwip-1.4.1/src/core/pbuf.c ****     p->type = type;
 224              		.loc 1 245 0
 225 0082 FB69     		ldr	r3, [r7, #28]
 226 0084 BA79     		ldrb	r2, [r7, #6]
 227 0086 1A73     		strb	r2, [r3, #12]
 246:../lwip-1.4.1/src/core/pbuf.c ****     p->next = NULL;
 228              		.loc 1 246 0
 229 0088 FB69     		ldr	r3, [r7, #28]
 230 008a 0022     		movs	r2, #0
 231 008c 1A60     		str	r2, [r3]
 247:../lwip-1.4.1/src/core/pbuf.c **** 
 248:../lwip-1.4.1/src/core/pbuf.c ****     /* make the payload pointer point 'offset' bytes into pbuf data memory */
 249:../lwip-1.4.1/src/core/pbuf.c ****     p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 232              		.loc 1 249 0
 233 008e FB8A     		ldrh	r3, [r7, #22]
 234 0090 1033     		adds	r3, r3, #16
 235 0092 FA69     		ldr	r2, [r7, #28]
 236 0094 1344     		add	r3, r3, r2
 237 0096 0333     		adds	r3, r3, #3
 238 0098 23F00303 		bic	r3, r3, #3
 239 009c 1A46     		mov	r2, r3
 240 009e FB69     		ldr	r3, [r7, #28]
 241 00a0 5A60     		str	r2, [r3, #4]
 250:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
 251:../lwip-1.4.1/src/core/pbuf.c ****             ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
 252:../lwip-1.4.1/src/core/pbuf.c ****     /* the total length of the pbuf chain is the requested size */
 253:../lwip-1.4.1/src/core/pbuf.c ****     p->tot_len = length;
 242              		.loc 1 253 0
 243 00a2 FB69     		ldr	r3, [r7, #28]
 244 00a4 BA88     		ldrh	r2, [r7, #4]	@ movhi
 245 00a6 1A81     		strh	r2, [r3, #8]	@ movhi
 254:../lwip-1.4.1/src/core/pbuf.c ****     /* set the length of the first pbuf in the chain */
 255:../lwip-1.4.1/src/core/pbuf.c ****     p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 246              		.loc 1 255 0
 247 00a8 FB8A     		ldrh	r3, [r7, #22]
 248 00aa 0333     		adds	r3, r3, #3
 249 00ac 23F00303 		bic	r3, r3, #3
 250 00b0 C3F5BB63 		rsb	r3, r3, #1496
 251 00b4 0433     		adds	r3, r3, #4
 252 00b6 BA88     		ldrh	r2, [r7, #4]
 253 00b8 9342     		cmp	r3, r2
 254 00ba A8BF     		it	ge
 255 00bc 1346     		movge	r3, r2
 256 00be 9AB2     		uxth	r2, r3
 257 00c0 FB69     		ldr	r3, [r7, #28]
 258 00c2 5A81     		strh	r2, [r3, #10]	@ movhi
 256:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 257:../lwip-1.4.1/src/core/pbuf.c ****                 ((u8_t*)p->payload + p->len <=
 258:../lwip-1.4.1/src/core/pbuf.c ****                  (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
 259:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 260:../lwip-1.4.1/src/core/pbuf.c ****       (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
 261:../lwip-1.4.1/src/core/pbuf.c ****     /* set reference count (needed here in case we fail) */
 262:../lwip-1.4.1/src/core/pbuf.c ****     p->ref = 1;
 259              		.loc 1 262 0
 260 00c4 FB69     		ldr	r3, [r7, #28]
 261 00c6 0122     		movs	r2, #1
 262 00c8 DA81     		strh	r2, [r3, #14]	@ movhi
 263:../lwip-1.4.1/src/core/pbuf.c **** 
 264:../lwip-1.4.1/src/core/pbuf.c ****     /* now allocate the tail of the pbuf chain */
 265:../lwip-1.4.1/src/core/pbuf.c **** 
 266:../lwip-1.4.1/src/core/pbuf.c ****     /* remember first pbuf for linkage in next iteration */
 267:../lwip-1.4.1/src/core/pbuf.c ****     r = p;
 263              		.loc 1 267 0
 264 00ca FB69     		ldr	r3, [r7, #28]
 265 00cc BB61     		str	r3, [r7, #24]
 268:../lwip-1.4.1/src/core/pbuf.c ****     /* remaining length to be allocated */
 269:../lwip-1.4.1/src/core/pbuf.c ****     rem_len = length - p->len;
 266              		.loc 1 269 0
 267 00ce BB88     		ldrh	r3, [r7, #4]
 268 00d0 FA69     		ldr	r2, [r7, #28]
 269 00d2 5289     		ldrh	r2, [r2, #10]
 270 00d4 9B1A     		subs	r3, r3, r2
 271 00d6 3B61     		str	r3, [r7, #16]
 270:../lwip-1.4.1/src/core/pbuf.c ****     /* any remaining pbufs to be allocated? */
 271:../lwip-1.4.1/src/core/pbuf.c ****     while (rem_len > 0) {
 272              		.loc 1 271 0
 273 00d8 37E0     		b	.L26
 274              	.L28:
 272:../lwip-1.4.1/src/core/pbuf.c ****       q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 275              		.loc 1 272 0
 276 00da 0A20     		movs	r0, #10
 277 00dc FFF7FEFF 		bl	memp_malloc
 278 00e0 F860     		str	r0, [r7, #12]
 273:../lwip-1.4.1/src/core/pbuf.c ****       if (q == NULL) {
 279              		.loc 1 273 0
 280 00e2 FB68     		ldr	r3, [r7, #12]
 281 00e4 002B     		cmp	r3, #0
 282 00e6 06D1     		bne	.L27
 274:../lwip-1.4.1/src/core/pbuf.c ****         PBUF_POOL_IS_EMPTY();
 283              		.loc 1 274 0
 284 00e8 FFF7FEFF 		bl	pbuf_pool_is_empty
 275:../lwip-1.4.1/src/core/pbuf.c ****         /* free chain so far allocated */
 276:../lwip-1.4.1/src/core/pbuf.c ****         pbuf_free(p);
 285              		.loc 1 276 0
 286 00ec F869     		ldr	r0, [r7, #28]
 287 00ee FFF7FEFF 		bl	pbuf_free
 277:../lwip-1.4.1/src/core/pbuf.c ****         /* bail out unsuccesfully */
 278:../lwip-1.4.1/src/core/pbuf.c ****         return NULL;
 288              		.loc 1 278 0
 289 00f2 0023     		movs	r3, #0
 290 00f4 7FE0     		b	.L19
 291              	.L27:
 279:../lwip-1.4.1/src/core/pbuf.c ****       }
 280:../lwip-1.4.1/src/core/pbuf.c ****       q->type = type;
 292              		.loc 1 280 0
 293 00f6 FB68     		ldr	r3, [r7, #12]
 294 00f8 BA79     		ldrb	r2, [r7, #6]
 295 00fa 1A73     		strb	r2, [r3, #12]
 281:../lwip-1.4.1/src/core/pbuf.c ****       q->flags = 0;
 296              		.loc 1 281 0
 297 00fc FB68     		ldr	r3, [r7, #12]
 298 00fe 0022     		movs	r2, #0
 299 0100 5A73     		strb	r2, [r3, #13]
 282:../lwip-1.4.1/src/core/pbuf.c ****       q->next = NULL;
 300              		.loc 1 282 0
 301 0102 FB68     		ldr	r3, [r7, #12]
 302 0104 0022     		movs	r2, #0
 303 0106 1A60     		str	r2, [r3]
 283:../lwip-1.4.1/src/core/pbuf.c ****       /* make previous pbuf point to this pbuf */
 284:../lwip-1.4.1/src/core/pbuf.c ****       r->next = q;
 304              		.loc 1 284 0
 305 0108 BB69     		ldr	r3, [r7, #24]
 306 010a FA68     		ldr	r2, [r7, #12]
 307 010c 1A60     		str	r2, [r3]
 285:../lwip-1.4.1/src/core/pbuf.c ****       /* set total length of this pbuf and next in chain */
 286:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 287:../lwip-1.4.1/src/core/pbuf.c ****       q->tot_len = (u16_t)rem_len;
 308              		.loc 1 287 0
 309 010e 3B69     		ldr	r3, [r7, #16]
 310 0110 9AB2     		uxth	r2, r3
 311 0112 FB68     		ldr	r3, [r7, #12]
 312 0114 1A81     		strh	r2, [r3, #8]	@ movhi
 288:../lwip-1.4.1/src/core/pbuf.c ****       /* this pbuf length is pool size, unless smaller sized tail */
 289:../lwip-1.4.1/src/core/pbuf.c ****       q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 313              		.loc 1 289 0
 314 0116 3B69     		ldr	r3, [r7, #16]
 315 0118 9BB2     		uxth	r3, r3
 316 011a 40F2DC52 		movw	r2, #1500
 317 011e 9342     		cmp	r3, r2
 318 0120 28BF     		it	cs
 319 0122 1346     		movcs	r3, r2
 320 0124 9AB2     		uxth	r2, r3
 321 0126 FB68     		ldr	r3, [r7, #12]
 322 0128 5A81     		strh	r2, [r3, #10]	@ movhi
 290:../lwip-1.4.1/src/core/pbuf.c ****       q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 323              		.loc 1 290 0
 324 012a FB68     		ldr	r3, [r7, #12]
 325 012c 03F11002 		add	r2, r3, #16
 326 0130 FB68     		ldr	r3, [r7, #12]
 327 0132 5A60     		str	r2, [r3, #4]
 291:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 292:../lwip-1.4.1/src/core/pbuf.c ****               ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
 293:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 294:../lwip-1.4.1/src/core/pbuf.c ****                   ((u8_t*)p->payload + p->len <=
 295:../lwip-1.4.1/src/core/pbuf.c ****                    (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
 296:../lwip-1.4.1/src/core/pbuf.c ****       q->ref = 1;
 328              		.loc 1 296 0
 329 0134 FB68     		ldr	r3, [r7, #12]
 330 0136 0122     		movs	r2, #1
 331 0138 DA81     		strh	r2, [r3, #14]	@ movhi
 297:../lwip-1.4.1/src/core/pbuf.c ****       /* calculate remaining length to be allocated */
 298:../lwip-1.4.1/src/core/pbuf.c ****       rem_len -= q->len;
 332              		.loc 1 298 0
 333 013a FB68     		ldr	r3, [r7, #12]
 334 013c 5B89     		ldrh	r3, [r3, #10]
 335 013e 1A46     		mov	r2, r3
 336 0140 3B69     		ldr	r3, [r7, #16]
 337 0142 9B1A     		subs	r3, r3, r2
 338 0144 3B61     		str	r3, [r7, #16]
 299:../lwip-1.4.1/src/core/pbuf.c ****       /* remember this pbuf for linkage in next iteration */
 300:../lwip-1.4.1/src/core/pbuf.c ****       r = q;
 339              		.loc 1 300 0
 340 0146 FB68     		ldr	r3, [r7, #12]
 341 0148 BB61     		str	r3, [r7, #24]
 342              	.L26:
 271:../lwip-1.4.1/src/core/pbuf.c ****       q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 343              		.loc 1 271 0
 344 014a 3B69     		ldr	r3, [r7, #16]
 345 014c 002B     		cmp	r3, #0
 346 014e C4DC     		bgt	.L28
 301:../lwip-1.4.1/src/core/pbuf.c ****     }
 302:../lwip-1.4.1/src/core/pbuf.c ****     /* end of chain */
 303:../lwip-1.4.1/src/core/pbuf.c ****     /*r->next = NULL;*/
 304:../lwip-1.4.1/src/core/pbuf.c **** 
 305:../lwip-1.4.1/src/core/pbuf.c ****     break;
 347              		.loc 1 305 0
 348 0150 4AE0     		b	.L29
 349              	.L21:
 306:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_RAM:
 307:../lwip-1.4.1/src/core/pbuf.c ****     /* If pbuf is to be allocated in RAM, allocate memory for it. */
 308:../lwip-1.4.1/src/core/pbuf.c ****     p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_
 350              		.loc 1 308 0
 351 0152 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 352 0154 1333     		adds	r3, r3, #19
 353 0156 9BB2     		uxth	r3, r3
 354 0158 23F00303 		bic	r3, r3, #3
 355 015c 9AB2     		uxth	r2, r3
 356 015e BB88     		ldrh	r3, [r7, #4]	@ movhi
 357 0160 0333     		adds	r3, r3, #3
 358 0162 9BB2     		uxth	r3, r3
 359 0164 23F00303 		bic	r3, r3, #3
 360 0168 9BB2     		uxth	r3, r3
 361 016a 1344     		add	r3, r3, r2
 362 016c 9BB2     		uxth	r3, r3
 363 016e 1846     		mov	r0, r3
 364 0170 FFF7FEFF 		bl	mem_malloc
 365 0174 F861     		str	r0, [r7, #28]
 309:../lwip-1.4.1/src/core/pbuf.c ****     if (p == NULL) {
 366              		.loc 1 309 0
 367 0176 FB69     		ldr	r3, [r7, #28]
 368 0178 002B     		cmp	r3, #0
 369 017a 01D1     		bne	.L30
 310:../lwip-1.4.1/src/core/pbuf.c ****       return NULL;
 370              		.loc 1 310 0
 371 017c 0023     		movs	r3, #0
 372 017e 3AE0     		b	.L19
 373              	.L30:
 311:../lwip-1.4.1/src/core/pbuf.c ****     }
 312:../lwip-1.4.1/src/core/pbuf.c ****     /* Set up internal structure of the pbuf. */
 313:../lwip-1.4.1/src/core/pbuf.c ****     p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 374              		.loc 1 313 0
 375 0180 FB8A     		ldrh	r3, [r7, #22]
 376 0182 1033     		adds	r3, r3, #16
 377 0184 FA69     		ldr	r2, [r7, #28]
 378 0186 1344     		add	r3, r3, r2
 379 0188 0333     		adds	r3, r3, #3
 380 018a 23F00303 		bic	r3, r3, #3
 381 018e 1A46     		mov	r2, r3
 382 0190 FB69     		ldr	r3, [r7, #28]
 383 0192 5A60     		str	r2, [r3, #4]
 314:../lwip-1.4.1/src/core/pbuf.c ****     p->len = p->tot_len = length;
 384              		.loc 1 314 0
 385 0194 FB69     		ldr	r3, [r7, #28]
 386 0196 BA88     		ldrh	r2, [r7, #4]	@ movhi
 387 0198 1A81     		strh	r2, [r3, #8]	@ movhi
 388 019a FB69     		ldr	r3, [r7, #28]
 389 019c 1A89     		ldrh	r2, [r3, #8]
 390 019e FB69     		ldr	r3, [r7, #28]
 391 01a0 5A81     		strh	r2, [r3, #10]	@ movhi
 315:../lwip-1.4.1/src/core/pbuf.c ****     p->next = NULL;
 392              		.loc 1 315 0
 393 01a2 FB69     		ldr	r3, [r7, #28]
 394 01a4 0022     		movs	r2, #0
 395 01a6 1A60     		str	r2, [r3]
 316:../lwip-1.4.1/src/core/pbuf.c ****     p->type = type;
 396              		.loc 1 316 0
 397 01a8 FB69     		ldr	r3, [r7, #28]
 398 01aa BA79     		ldrb	r2, [r7, #6]
 399 01ac 1A73     		strb	r2, [r3, #12]
 317:../lwip-1.4.1/src/core/pbuf.c **** 
 318:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 319:../lwip-1.4.1/src/core/pbuf.c ****            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
 320:../lwip-1.4.1/src/core/pbuf.c ****     break;
 400              		.loc 1 320 0
 401 01ae 1BE0     		b	.L29
 402              	.L23:
 321:../lwip-1.4.1/src/core/pbuf.c ****   /* pbuf references existing (non-volatile static constant) ROM payload? */
 322:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_ROM:
 323:../lwip-1.4.1/src/core/pbuf.c ****   /* pbuf references existing (externally allocated) RAM payload? */
 324:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_REF:
 325:../lwip-1.4.1/src/core/pbuf.c ****     /* only allocate memory for the pbuf structure */
 326:../lwip-1.4.1/src/core/pbuf.c ****     p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 403              		.loc 1 326 0
 404 01b0 0920     		movs	r0, #9
 405 01b2 FFF7FEFF 		bl	memp_malloc
 406 01b6 F861     		str	r0, [r7, #28]
 327:../lwip-1.4.1/src/core/pbuf.c ****     if (p == NULL) {
 407              		.loc 1 327 0
 408 01b8 FB69     		ldr	r3, [r7, #28]
 409 01ba 002B     		cmp	r3, #0
 410 01bc 01D1     		bne	.L31
 328:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 329:../lwip-1.4.1/src/core/pbuf.c ****                   ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
 330:../lwip-1.4.1/src/core/pbuf.c ****                   (type == PBUF_ROM) ? "ROM" : "REF"));
 331:../lwip-1.4.1/src/core/pbuf.c ****       return NULL;
 411              		.loc 1 331 0
 412 01be 0023     		movs	r3, #0
 413 01c0 19E0     		b	.L19
 414              	.L31:
 332:../lwip-1.4.1/src/core/pbuf.c ****     }
 333:../lwip-1.4.1/src/core/pbuf.c ****     /* caller must set this field properly, afterwards */
 334:../lwip-1.4.1/src/core/pbuf.c ****     p->payload = NULL;
 415              		.loc 1 334 0
 416 01c2 FB69     		ldr	r3, [r7, #28]
 417 01c4 0022     		movs	r2, #0
 418 01c6 5A60     		str	r2, [r3, #4]
 335:../lwip-1.4.1/src/core/pbuf.c ****     p->len = p->tot_len = length;
 419              		.loc 1 335 0
 420 01c8 FB69     		ldr	r3, [r7, #28]
 421 01ca BA88     		ldrh	r2, [r7, #4]	@ movhi
 422 01cc 1A81     		strh	r2, [r3, #8]	@ movhi
 423 01ce FB69     		ldr	r3, [r7, #28]
 424 01d0 1A89     		ldrh	r2, [r3, #8]
 425 01d2 FB69     		ldr	r3, [r7, #28]
 426 01d4 5A81     		strh	r2, [r3, #10]	@ movhi
 336:../lwip-1.4.1/src/core/pbuf.c ****     p->next = NULL;
 427              		.loc 1 336 0
 428 01d6 FB69     		ldr	r3, [r7, #28]
 429 01d8 0022     		movs	r2, #0
 430 01da 1A60     		str	r2, [r3]
 337:../lwip-1.4.1/src/core/pbuf.c ****     p->type = type;
 431              		.loc 1 337 0
 432 01dc FB69     		ldr	r3, [r7, #28]
 433 01de BA79     		ldrb	r2, [r7, #6]
 434 01e0 1A73     		strb	r2, [r3, #12]
 338:../lwip-1.4.1/src/core/pbuf.c ****     break;
 435              		.loc 1 338 0
 436 01e2 01E0     		b	.L29
 437              	.L20:
 339:../lwip-1.4.1/src/core/pbuf.c ****   default:
 340:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 341:../lwip-1.4.1/src/core/pbuf.c ****     return NULL;
 438              		.loc 1 341 0
 439 01e4 0023     		movs	r3, #0
 440 01e6 06E0     		b	.L19
 441              	.L29:
 342:../lwip-1.4.1/src/core/pbuf.c ****   }
 343:../lwip-1.4.1/src/core/pbuf.c ****   /* set reference count */
 344:../lwip-1.4.1/src/core/pbuf.c ****   p->ref = 1;
 442              		.loc 1 344 0
 443 01e8 FB69     		ldr	r3, [r7, #28]
 444 01ea 0122     		movs	r2, #1
 445 01ec DA81     		strh	r2, [r3, #14]	@ movhi
 345:../lwip-1.4.1/src/core/pbuf.c ****   /* set flags */
 346:../lwip-1.4.1/src/core/pbuf.c ****   p->flags = 0;
 446              		.loc 1 346 0
 447 01ee FB69     		ldr	r3, [r7, #28]
 448 01f0 0022     		movs	r2, #0
 449 01f2 5A73     		strb	r2, [r3, #13]
 347:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)
 348:../lwip-1.4.1/src/core/pbuf.c ****   return p;
 450              		.loc 1 348 0
 451 01f4 FB69     		ldr	r3, [r7, #28]
 452              	.L19:
 349:../lwip-1.4.1/src/core/pbuf.c **** }
 453              		.loc 1 349 0
 454 01f6 1846     		mov	r0, r3
 455 01f8 2037     		adds	r7, r7, #32
 456              		.cfi_def_cfa_offset 8
 457 01fa BD46     		mov	sp, r7
 458              		.cfi_def_cfa_register 13
 459              		@ sp needed
 460 01fc 80BD     		pop	{r7, pc}
 461              		.cfi_endproc
 462              	.LFE2:
 464 01fe 00BF     		.section	.text.pbuf_alloced_custom,"ax",%progbits
 465              		.align	2
 466              		.global	pbuf_alloced_custom
 467              		.thumb
 468              		.thumb_func
 470              	pbuf_alloced_custom:
 471              	.LFB3:
 350:../lwip-1.4.1/src/core/pbuf.c **** 
 351:../lwip-1.4.1/src/core/pbuf.c **** #if LWIP_SUPPORT_CUSTOM_PBUF
 352:../lwip-1.4.1/src/core/pbuf.c **** /** Initialize a custom pbuf (already allocated).
 353:../lwip-1.4.1/src/core/pbuf.c ****  *
 354:../lwip-1.4.1/src/core/pbuf.c ****  * @param layer flag to define header size
 355:../lwip-1.4.1/src/core/pbuf.c ****  * @param length size of the pbuf's payload
 356:../lwip-1.4.1/src/core/pbuf.c ****  * @param type type of the pbuf (only used to treat the pbuf accordingly, as
 357:../lwip-1.4.1/src/core/pbuf.c ****  *        this function allocates no memory)
 358:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pointer to the custom pbuf to initialize (already allocated)
 359:../lwip-1.4.1/src/core/pbuf.c ****  * @param payload_mem pointer to the buffer that is used for payload and headers,
 360:../lwip-1.4.1/src/core/pbuf.c ****  *        must be at least big enough to hold 'length' plus the header size,
 361:../lwip-1.4.1/src/core/pbuf.c ****  *        may be NULL if set later.
 362:../lwip-1.4.1/src/core/pbuf.c ****  *        ATTENTION: The caller is responsible for correct alignment of this buffer!!
 363:../lwip-1.4.1/src/core/pbuf.c ****  * @param payload_mem_len the size of the 'payload_mem' buffer, must be at least
 364:../lwip-1.4.1/src/core/pbuf.c ****  *        big enough to hold 'length' plus the header size
 365:../lwip-1.4.1/src/core/pbuf.c ****  */
 366:../lwip-1.4.1/src/core/pbuf.c **** struct pbuf*
 367:../lwip-1.4.1/src/core/pbuf.c **** pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
 368:../lwip-1.4.1/src/core/pbuf.c ****                     void *payload_mem, u16_t payload_mem_len)
 369:../lwip-1.4.1/src/core/pbuf.c **** {
 472              		.loc 1 369 0
 473              		.cfi_startproc
 474              		@ args = 8, pretend = 0, frame = 16
 475              		@ frame_needed = 1, uses_anonymous_args = 0
 476              		@ link register save eliminated.
 477 0000 80B4     		push	{r7}
 478              		.cfi_def_cfa_offset 4
 479              		.cfi_offset 7, -4
 480 0002 85B0     		sub	sp, sp, #20
 481              		.cfi_def_cfa_offset 24
 482 0004 00AF     		add	r7, sp, #0
 483              		.cfi_def_cfa_register 7
 484 0006 3B60     		str	r3, [r7]
 485 0008 0346     		mov	r3, r0
 486 000a FB71     		strb	r3, [r7, #7]
 487 000c 0B46     		mov	r3, r1	@ movhi
 488 000e BB80     		strh	r3, [r7, #4]	@ movhi
 489 0010 1346     		mov	r3, r2
 490 0012 BB71     		strb	r3, [r7, #6]
 370:../lwip-1.4.1/src/core/pbuf.c ****   u16_t offset;
 371:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));
 372:../lwip-1.4.1/src/core/pbuf.c **** 
 373:../lwip-1.4.1/src/core/pbuf.c ****   /* determine header offset */
 374:../lwip-1.4.1/src/core/pbuf.c ****   switch (l) {
 491              		.loc 1 374 0
 492 0014 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 493 0016 032B     		cmp	r3, #3
 494 0018 16D8     		bhi	.L33
 495 001a 01A2     		adr	r2, .L35
 496 001c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 497              		.p2align 2
 498              	.L35:
 499 0020 31000000 		.word	.L34+1
 500 0024 37000000 		.word	.L36+1
 501 0028 3D000000 		.word	.L37+1
 502 002c 43000000 		.word	.L38+1
 503              		.p2align 1
 504              	.L34:
 375:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_TRANSPORT:
 376:../lwip-1.4.1/src/core/pbuf.c ****     /* add room for transport (often TCP) layer header */
 377:../lwip-1.4.1/src/core/pbuf.c ****     offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 505              		.loc 1 377 0
 506 0030 3623     		movs	r3, #54
 507 0032 FB81     		strh	r3, [r7, #14]	@ movhi
 378:../lwip-1.4.1/src/core/pbuf.c ****     break;
 508              		.loc 1 378 0
 509 0034 0AE0     		b	.L39
 510              	.L36:
 379:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_IP:
 380:../lwip-1.4.1/src/core/pbuf.c ****     /* add room for IP layer header */
 381:../lwip-1.4.1/src/core/pbuf.c ****     offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 511              		.loc 1 381 0
 512 0036 2223     		movs	r3, #34
 513 0038 FB81     		strh	r3, [r7, #14]	@ movhi
 382:../lwip-1.4.1/src/core/pbuf.c ****     break;
 514              		.loc 1 382 0
 515 003a 07E0     		b	.L39
 516              	.L37:
 383:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_LINK:
 384:../lwip-1.4.1/src/core/pbuf.c ****     /* add room for link layer header */
 385:../lwip-1.4.1/src/core/pbuf.c ****     offset = PBUF_LINK_HLEN;
 517              		.loc 1 385 0
 518 003c 0E23     		movs	r3, #14
 519 003e FB81     		strh	r3, [r7, #14]	@ movhi
 386:../lwip-1.4.1/src/core/pbuf.c ****     break;
 520              		.loc 1 386 0
 521 0040 04E0     		b	.L39
 522              	.L38:
 387:../lwip-1.4.1/src/core/pbuf.c ****   case PBUF_RAW:
 388:../lwip-1.4.1/src/core/pbuf.c ****     offset = 0;
 523              		.loc 1 388 0
 524 0042 0023     		movs	r3, #0
 525 0044 FB81     		strh	r3, [r7, #14]	@ movhi
 389:../lwip-1.4.1/src/core/pbuf.c ****     break;
 526              		.loc 1 389 0
 527 0046 01E0     		b	.L39
 528              	.L33:
 390:../lwip-1.4.1/src/core/pbuf.c ****   default:
 391:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
 392:../lwip-1.4.1/src/core/pbuf.c ****     return NULL;
 529              		.loc 1 392 0
 530 0048 0023     		movs	r3, #0
 531 004a 2DE0     		b	.L40
 532              	.L39:
 393:../lwip-1.4.1/src/core/pbuf.c ****   }
 394:../lwip-1.4.1/src/core/pbuf.c **** 
 395:../lwip-1.4.1/src/core/pbuf.c ****   if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 533              		.loc 1 395 0
 534 004c FB89     		ldrh	r3, [r7, #14]
 535 004e 0333     		adds	r3, r3, #3
 536 0050 23F00302 		bic	r2, r3, #3
 537 0054 BB88     		ldrh	r3, [r7, #4]
 538 0056 1A44     		add	r2, r2, r3
 539 0058 BB8B     		ldrh	r3, [r7, #28]
 540 005a 9A42     		cmp	r2, r3
 541 005c 01DD     		ble	.L41
 396:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer 
 397:../lwip-1.4.1/src/core/pbuf.c ****     return NULL;
 542              		.loc 1 397 0
 543 005e 0023     		movs	r3, #0
 544 0060 22E0     		b	.L40
 545              	.L41:
 398:../lwip-1.4.1/src/core/pbuf.c ****   }
 399:../lwip-1.4.1/src/core/pbuf.c **** 
 400:../lwip-1.4.1/src/core/pbuf.c ****   p->pbuf.next = NULL;
 546              		.loc 1 400 0
 547 0062 3B68     		ldr	r3, [r7]
 548 0064 0022     		movs	r2, #0
 549 0066 1A60     		str	r2, [r3]
 401:../lwip-1.4.1/src/core/pbuf.c ****   if (payload_mem != NULL) {
 550              		.loc 1 401 0
 551 0068 BB69     		ldr	r3, [r7, #24]
 552 006a 002B     		cmp	r3, #0
 553 006c 08D0     		beq	.L42
 402:../lwip-1.4.1/src/core/pbuf.c ****     p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 554              		.loc 1 402 0
 555 006e FB89     		ldrh	r3, [r7, #14]
 556 0070 0333     		adds	r3, r3, #3
 557 0072 23F00303 		bic	r3, r3, #3
 558 0076 BA69     		ldr	r2, [r7, #24]
 559 0078 1A44     		add	r2, r2, r3
 560 007a 3B68     		ldr	r3, [r7]
 561 007c 5A60     		str	r2, [r3, #4]
 562 007e 02E0     		b	.L43
 563              	.L42:
 403:../lwip-1.4.1/src/core/pbuf.c ****   } else {
 404:../lwip-1.4.1/src/core/pbuf.c ****     p->pbuf.payload = NULL;
 564              		.loc 1 404 0
 565 0080 3B68     		ldr	r3, [r7]
 566 0082 0022     		movs	r2, #0
 567 0084 5A60     		str	r2, [r3, #4]
 568              	.L43:
 405:../lwip-1.4.1/src/core/pbuf.c ****   }
 406:../lwip-1.4.1/src/core/pbuf.c ****   p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 569              		.loc 1 406 0
 570 0086 3B68     		ldr	r3, [r7]
 571 0088 0222     		movs	r2, #2
 572 008a 5A73     		strb	r2, [r3, #13]
 407:../lwip-1.4.1/src/core/pbuf.c ****   p->pbuf.len = p->pbuf.tot_len = length;
 573              		.loc 1 407 0
 574 008c 3B68     		ldr	r3, [r7]
 575 008e BA88     		ldrh	r2, [r7, #4]	@ movhi
 576 0090 1A81     		strh	r2, [r3, #8]	@ movhi
 577 0092 3B68     		ldr	r3, [r7]
 578 0094 1A89     		ldrh	r2, [r3, #8]
 579 0096 3B68     		ldr	r3, [r7]
 580 0098 5A81     		strh	r2, [r3, #10]	@ movhi
 408:../lwip-1.4.1/src/core/pbuf.c ****   p->pbuf.type = type;
 581              		.loc 1 408 0
 582 009a 3B68     		ldr	r3, [r7]
 583 009c BA79     		ldrb	r2, [r7, #6]
 584 009e 1A73     		strb	r2, [r3, #12]
 409:../lwip-1.4.1/src/core/pbuf.c ****   p->pbuf.ref = 1;
 585              		.loc 1 409 0
 586 00a0 3B68     		ldr	r3, [r7]
 587 00a2 0122     		movs	r2, #1
 588 00a4 DA81     		strh	r2, [r3, #14]	@ movhi
 410:../lwip-1.4.1/src/core/pbuf.c ****   return &p->pbuf;
 589              		.loc 1 410 0
 590 00a6 3B68     		ldr	r3, [r7]
 591              	.L40:
 411:../lwip-1.4.1/src/core/pbuf.c **** }
 592              		.loc 1 411 0
 593 00a8 1846     		mov	r0, r3
 594 00aa 1437     		adds	r7, r7, #20
 595              		.cfi_def_cfa_offset 4
 596 00ac BD46     		mov	sp, r7
 597              		.cfi_def_cfa_register 13
 598              		@ sp needed
 599 00ae 5DF8047B 		ldr	r7, [sp], #4
 600              		.cfi_restore 7
 601              		.cfi_def_cfa_offset 0
 602 00b2 7047     		bx	lr
 603              		.cfi_endproc
 604              	.LFE3:
 606              		.section	.text.pbuf_realloc,"ax",%progbits
 607              		.align	2
 608              		.global	pbuf_realloc
 609              		.thumb
 610              		.thumb_func
 612              	pbuf_realloc:
 613              	.LFB4:
 412:../lwip-1.4.1/src/core/pbuf.c **** #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
 413:../lwip-1.4.1/src/core/pbuf.c **** 
 414:../lwip-1.4.1/src/core/pbuf.c **** /**
 415:../lwip-1.4.1/src/core/pbuf.c ****  * Shrink a pbuf chain to a desired length.
 416:../lwip-1.4.1/src/core/pbuf.c ****  *
 417:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to shrink.
 418:../lwip-1.4.1/src/core/pbuf.c ****  * @param new_len desired new length of pbuf chain
 419:../lwip-1.4.1/src/core/pbuf.c ****  *
 420:../lwip-1.4.1/src/core/pbuf.c ****  * Depending on the desired length, the first few pbufs in a chain might
 421:../lwip-1.4.1/src/core/pbuf.c ****  * be skipped and left unchanged. The new last pbuf in the chain will be
 422:../lwip-1.4.1/src/core/pbuf.c ****  * resized, and any remaining pbufs will be freed.
 423:../lwip-1.4.1/src/core/pbuf.c ****  *
 424:../lwip-1.4.1/src/core/pbuf.c ****  * @note If the pbuf is ROM/REF, only the ->tot_len and ->len fields are adjusted.
 425:../lwip-1.4.1/src/core/pbuf.c ****  * @note May not be called on a packet queue.
 426:../lwip-1.4.1/src/core/pbuf.c ****  *
 427:../lwip-1.4.1/src/core/pbuf.c ****  * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 428:../lwip-1.4.1/src/core/pbuf.c ****  */
 429:../lwip-1.4.1/src/core/pbuf.c **** void
 430:../lwip-1.4.1/src/core/pbuf.c **** pbuf_realloc(struct pbuf *p, u16_t new_len)
 431:../lwip-1.4.1/src/core/pbuf.c **** {
 614              		.loc 1 431 0
 615              		.cfi_startproc
 616              		@ args = 0, pretend = 0, frame = 24
 617              		@ frame_needed = 1, uses_anonymous_args = 0
 618 0000 80B5     		push	{r7, lr}
 619              		.cfi_def_cfa_offset 8
 620              		.cfi_offset 7, -8
 621              		.cfi_offset 14, -4
 622 0002 86B0     		sub	sp, sp, #24
 623              		.cfi_def_cfa_offset 32
 624 0004 00AF     		add	r7, sp, #0
 625              		.cfi_def_cfa_register 7
 626 0006 7860     		str	r0, [r7, #4]
 627 0008 0B46     		mov	r3, r1
 628 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 432:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *q;
 433:../lwip-1.4.1/src/core/pbuf.c ****   u16_t rem_len; /* remaining length */
 434:../lwip-1.4.1/src/core/pbuf.c ****   s32_t grow;
 435:../lwip-1.4.1/src/core/pbuf.c **** 
 436:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 437:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 629              		.loc 1 437 0
 630 000c 7B68     		ldr	r3, [r7, #4]
 631 000e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 632 0010 032B     		cmp	r3, #3
 633 0012 06D0     		beq	.L45
 634              		.loc 1 437 0 is_stmt 0 discriminator 1
 635 0014 7B68     		ldr	r3, [r7, #4]
 636 0016 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 637 0018 012B     		cmp	r3, #1
 638 001a 02D0     		beq	.L45
 639              		.loc 1 437 0 discriminator 2
 640 001c 7B68     		ldr	r3, [r7, #4]
 641 001e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 642 0020 002B     		cmp	r3, #0
 643              	.L45:
 438:../lwip-1.4.1/src/core/pbuf.c ****               p->type == PBUF_ROM ||
 439:../lwip-1.4.1/src/core/pbuf.c ****               p->type == PBUF_RAM ||
 440:../lwip-1.4.1/src/core/pbuf.c ****               p->type == PBUF_REF);
 441:../lwip-1.4.1/src/core/pbuf.c **** 
 442:../lwip-1.4.1/src/core/pbuf.c ****   /* desired length larger than current length? */
 443:../lwip-1.4.1/src/core/pbuf.c ****   if (new_len >= p->tot_len) {
 644              		.loc 1 443 0 is_stmt 1
 645 0022 7B68     		ldr	r3, [r7, #4]
 646 0024 1B89     		ldrh	r3, [r3, #8]
 647 0026 7A88     		ldrh	r2, [r7, #2]
 648 0028 9A42     		cmp	r2, r3
 649 002a 00D3     		bcc	.L46
 444:../lwip-1.4.1/src/core/pbuf.c ****     /* enlarging not yet supported */
 445:../lwip-1.4.1/src/core/pbuf.c ****     return;
 650              		.loc 1 445 0
 651 002c 48E0     		b	.L44
 652              	.L46:
 446:../lwip-1.4.1/src/core/pbuf.c ****   }
 447:../lwip-1.4.1/src/core/pbuf.c **** 
 448:../lwip-1.4.1/src/core/pbuf.c ****   /* the pbuf chain grows by (new_len - p->tot_len) bytes
 449:../lwip-1.4.1/src/core/pbuf.c ****    * (which may be negative in case of shrinking) */
 450:../lwip-1.4.1/src/core/pbuf.c ****   grow = new_len - p->tot_len;
 653              		.loc 1 450 0
 654 002e 7B88     		ldrh	r3, [r7, #2]
 655 0030 7A68     		ldr	r2, [r7, #4]
 656 0032 1289     		ldrh	r2, [r2, #8]
 657 0034 9B1A     		subs	r3, r3, r2
 658 0036 FB60     		str	r3, [r7, #12]
 451:../lwip-1.4.1/src/core/pbuf.c **** 
 452:../lwip-1.4.1/src/core/pbuf.c ****   /* first, step over any pbufs that should remain in the chain */
 453:../lwip-1.4.1/src/core/pbuf.c ****   rem_len = new_len;
 659              		.loc 1 453 0
 660 0038 7B88     		ldrh	r3, [r7, #2]	@ movhi
 661 003a 7B82     		strh	r3, [r7, #18]	@ movhi
 454:../lwip-1.4.1/src/core/pbuf.c ****   q = p;
 662              		.loc 1 454 0
 663 003c 7B68     		ldr	r3, [r7, #4]
 664 003e 7B61     		str	r3, [r7, #20]
 455:../lwip-1.4.1/src/core/pbuf.c ****   /* should this pbuf be kept? */
 456:../lwip-1.4.1/src/core/pbuf.c ****   while (rem_len > q->len) {
 665              		.loc 1 456 0
 666 0040 0FE0     		b	.L48
 667              	.L49:
 457:../lwip-1.4.1/src/core/pbuf.c ****     /* decrease remaining length by pbuf length */
 458:../lwip-1.4.1/src/core/pbuf.c ****     rem_len -= q->len;
 668              		.loc 1 458 0
 669 0042 7B69     		ldr	r3, [r7, #20]
 670 0044 5B89     		ldrh	r3, [r3, #10]
 671 0046 7A8A     		ldrh	r2, [r7, #18]	@ movhi
 672 0048 D31A     		subs	r3, r2, r3
 673 004a 7B82     		strh	r3, [r7, #18]	@ movhi
 459:../lwip-1.4.1/src/core/pbuf.c ****     /* decrease total length indicator */
 460:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 461:../lwip-1.4.1/src/core/pbuf.c ****     q->tot_len += (u16_t)grow;
 674              		.loc 1 461 0
 675 004c 7B69     		ldr	r3, [r7, #20]
 676 004e 1A89     		ldrh	r2, [r3, #8]
 677 0050 FB68     		ldr	r3, [r7, #12]
 678 0052 9BB2     		uxth	r3, r3
 679 0054 1344     		add	r3, r3, r2
 680 0056 9AB2     		uxth	r2, r3
 681 0058 7B69     		ldr	r3, [r7, #20]
 682 005a 1A81     		strh	r2, [r3, #8]	@ movhi
 462:../lwip-1.4.1/src/core/pbuf.c ****     /* proceed to next pbuf in chain */
 463:../lwip-1.4.1/src/core/pbuf.c ****     q = q->next;
 683              		.loc 1 463 0
 684 005c 7B69     		ldr	r3, [r7, #20]
 685 005e 1B68     		ldr	r3, [r3]
 686 0060 7B61     		str	r3, [r7, #20]
 687              	.L48:
 456:../lwip-1.4.1/src/core/pbuf.c ****     /* decrease remaining length by pbuf length */
 688              		.loc 1 456 0
 689 0062 7B69     		ldr	r3, [r7, #20]
 690 0064 5B89     		ldrh	r3, [r3, #10]
 691 0066 7A8A     		ldrh	r2, [r7, #18]
 692 0068 9A42     		cmp	r2, r3
 693 006a EAD8     		bhi	.L49
 464:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 465:../lwip-1.4.1/src/core/pbuf.c ****   }
 466:../lwip-1.4.1/src/core/pbuf.c ****   /* we have now reached the new last pbuf (in q) */
 467:../lwip-1.4.1/src/core/pbuf.c ****   /* rem_len == desired length for pbuf q */
 468:../lwip-1.4.1/src/core/pbuf.c **** 
 469:../lwip-1.4.1/src/core/pbuf.c ****   /* shrink allocated memory for PBUF_RAM */
 470:../lwip-1.4.1/src/core/pbuf.c ****   /* (other types merely adjust their length fields */
 471:../lwip-1.4.1/src/core/pbuf.c ****   if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 694              		.loc 1 471 0
 695 006c 7B69     		ldr	r3, [r7, #20]
 696 006e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 697 0070 002B     		cmp	r3, #0
 698 0072 12D1     		bne	.L50
 699              		.loc 1 471 0 is_stmt 0 discriminator 1
 700 0074 7B69     		ldr	r3, [r7, #20]
 701 0076 5B89     		ldrh	r3, [r3, #10]
 702 0078 7A8A     		ldrh	r2, [r7, #18]
 703 007a 9A42     		cmp	r2, r3
 704 007c 0DD0     		beq	.L50
 472:../lwip-1.4.1/src/core/pbuf.c ****     /* reallocate and adjust the length of the pbuf that will be split */
 473:../lwip-1.4.1/src/core/pbuf.c ****     q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 705              		.loc 1 473 0 is_stmt 1
 706 007e 7B69     		ldr	r3, [r7, #20]
 707 0080 5B68     		ldr	r3, [r3, #4]
 708 0082 1A46     		mov	r2, r3
 709 0084 7B69     		ldr	r3, [r7, #20]
 710 0086 D31A     		subs	r3, r2, r3
 711 0088 9AB2     		uxth	r2, r3
 712 008a 7B8A     		ldrh	r3, [r7, #18]	@ movhi
 713 008c 1344     		add	r3, r3, r2
 714 008e 9BB2     		uxth	r3, r3
 715 0090 7869     		ldr	r0, [r7, #20]
 716 0092 1946     		mov	r1, r3
 717 0094 FFF7FEFF 		bl	mem_trim
 718 0098 7861     		str	r0, [r7, #20]
 719              	.L50:
 474:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 475:../lwip-1.4.1/src/core/pbuf.c ****   }
 476:../lwip-1.4.1/src/core/pbuf.c ****   /* adjust length fields for new last pbuf */
 477:../lwip-1.4.1/src/core/pbuf.c ****   q->len = rem_len;
 720              		.loc 1 477 0
 721 009a 7B69     		ldr	r3, [r7, #20]
 722 009c 7A8A     		ldrh	r2, [r7, #18]	@ movhi
 723 009e 5A81     		strh	r2, [r3, #10]	@ movhi
 478:../lwip-1.4.1/src/core/pbuf.c ****   q->tot_len = q->len;
 724              		.loc 1 478 0
 725 00a0 7B69     		ldr	r3, [r7, #20]
 726 00a2 5A89     		ldrh	r2, [r3, #10]
 727 00a4 7B69     		ldr	r3, [r7, #20]
 728 00a6 1A81     		strh	r2, [r3, #8]	@ movhi
 479:../lwip-1.4.1/src/core/pbuf.c **** 
 480:../lwip-1.4.1/src/core/pbuf.c ****   /* any remaining pbufs in chain? */
 481:../lwip-1.4.1/src/core/pbuf.c ****   if (q->next != NULL) {
 729              		.loc 1 481 0
 730 00a8 7B69     		ldr	r3, [r7, #20]
 731 00aa 1B68     		ldr	r3, [r3]
 732 00ac 002B     		cmp	r3, #0
 733 00ae 04D0     		beq	.L51
 482:../lwip-1.4.1/src/core/pbuf.c ****     /* free remaining pbufs in chain */
 483:../lwip-1.4.1/src/core/pbuf.c ****     pbuf_free(q->next);
 734              		.loc 1 483 0
 735 00b0 7B69     		ldr	r3, [r7, #20]
 736 00b2 1B68     		ldr	r3, [r3]
 737 00b4 1846     		mov	r0, r3
 738 00b6 FFF7FEFF 		bl	pbuf_free
 739              	.L51:
 484:../lwip-1.4.1/src/core/pbuf.c ****   }
 485:../lwip-1.4.1/src/core/pbuf.c ****   /* q is last packet in chain */
 486:../lwip-1.4.1/src/core/pbuf.c ****   q->next = NULL;
 740              		.loc 1 486 0
 741 00ba 7B69     		ldr	r3, [r7, #20]
 742 00bc 0022     		movs	r2, #0
 743 00be 1A60     		str	r2, [r3]
 744              	.L44:
 487:../lwip-1.4.1/src/core/pbuf.c **** 
 488:../lwip-1.4.1/src/core/pbuf.c **** }
 745              		.loc 1 488 0
 746 00c0 1837     		adds	r7, r7, #24
 747              		.cfi_def_cfa_offset 8
 748 00c2 BD46     		mov	sp, r7
 749              		.cfi_def_cfa_register 13
 750              		@ sp needed
 751 00c4 80BD     		pop	{r7, pc}
 752              		.cfi_endproc
 753              	.LFE4:
 755 00c6 00BF     		.section	.text.pbuf_header,"ax",%progbits
 756              		.align	2
 757              		.global	pbuf_header
 758              		.thumb
 759              		.thumb_func
 761              	pbuf_header:
 762              	.LFB5:
 489:../lwip-1.4.1/src/core/pbuf.c **** 
 490:../lwip-1.4.1/src/core/pbuf.c **** /**
 491:../lwip-1.4.1/src/core/pbuf.c ****  * Adjusts the payload pointer to hide or reveal headers in the payload.
 492:../lwip-1.4.1/src/core/pbuf.c ****  *
 493:../lwip-1.4.1/src/core/pbuf.c ****  * Adjusts the ->payload pointer so that space for a header
 494:../lwip-1.4.1/src/core/pbuf.c ****  * (dis)appears in the pbuf payload.
 495:../lwip-1.4.1/src/core/pbuf.c ****  *
 496:../lwip-1.4.1/src/core/pbuf.c ****  * The ->payload, ->tot_len and ->len fields are adjusted.
 497:../lwip-1.4.1/src/core/pbuf.c ****  *
 498:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to change the header size.
 499:../lwip-1.4.1/src/core/pbuf.c ****  * @param header_size_increment Number of bytes to increment header size which
 500:../lwip-1.4.1/src/core/pbuf.c ****  * increases the size of the pbuf. New space is on the front.
 501:../lwip-1.4.1/src/core/pbuf.c ****  * (Using a negative value decreases the header size.)
 502:../lwip-1.4.1/src/core/pbuf.c ****  * If hdr_size_inc is 0, this function does nothing and returns succesful.
 503:../lwip-1.4.1/src/core/pbuf.c ****  *
 504:../lwip-1.4.1/src/core/pbuf.c ****  * PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so
 505:../lwip-1.4.1/src/core/pbuf.c ****  * the call will fail. A check is made that the increase in header size does
 506:../lwip-1.4.1/src/core/pbuf.c ****  * not move the payload pointer in front of the start of the buffer.
 507:../lwip-1.4.1/src/core/pbuf.c ****  * @return non-zero on failure, zero on success.
 508:../lwip-1.4.1/src/core/pbuf.c ****  *
 509:../lwip-1.4.1/src/core/pbuf.c ****  */
 510:../lwip-1.4.1/src/core/pbuf.c **** u8_t
 511:../lwip-1.4.1/src/core/pbuf.c **** pbuf_header(struct pbuf *p, s16_t header_size_increment)
 512:../lwip-1.4.1/src/core/pbuf.c **** {
 763              		.loc 1 512 0
 764              		.cfi_startproc
 765              		@ args = 0, pretend = 0, frame = 16
 766              		@ frame_needed = 1, uses_anonymous_args = 0
 767              		@ link register save eliminated.
 768 0000 80B4     		push	{r7}
 769              		.cfi_def_cfa_offset 4
 770              		.cfi_offset 7, -4
 771 0002 85B0     		sub	sp, sp, #20
 772              		.cfi_def_cfa_offset 24
 773 0004 00AF     		add	r7, sp, #0
 774              		.cfi_def_cfa_register 7
 775 0006 7860     		str	r0, [r7, #4]
 776 0008 0B46     		mov	r3, r1
 777 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 513:../lwip-1.4.1/src/core/pbuf.c ****   u16_t type;
 514:../lwip-1.4.1/src/core/pbuf.c ****   void *payload;
 515:../lwip-1.4.1/src/core/pbuf.c ****   u16_t increment_magnitude;
 516:../lwip-1.4.1/src/core/pbuf.c **** 
 517:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("p != NULL", p != NULL);
 518:../lwip-1.4.1/src/core/pbuf.c ****   if ((header_size_increment == 0) || (p == NULL)) {
 778              		.loc 1 518 0
 779 000c B7F90230 		ldrsh	r3, [r7, #2]
 780 0010 002B     		cmp	r3, #0
 781 0012 02D0     		beq	.L53
 782              		.loc 1 518 0 is_stmt 0 discriminator 1
 783 0014 7B68     		ldr	r3, [r7, #4]
 784 0016 002B     		cmp	r3, #0
 785 0018 01D1     		bne	.L54
 786              	.L53:
 519:../lwip-1.4.1/src/core/pbuf.c ****     return 0;
 787              		.loc 1 519 0 is_stmt 1
 788 001a 0023     		movs	r3, #0
 789 001c 5AE0     		b	.L55
 790              	.L54:
 520:../lwip-1.4.1/src/core/pbuf.c ****   }
 521:../lwip-1.4.1/src/core/pbuf.c ****  
 522:../lwip-1.4.1/src/core/pbuf.c ****   if (header_size_increment < 0){
 791              		.loc 1 522 0
 792 001e B7F90230 		ldrsh	r3, [r7, #2]
 793 0022 002B     		cmp	r3, #0
 794 0024 09DA     		bge	.L56
 523:../lwip-1.4.1/src/core/pbuf.c ****     increment_magnitude = -header_size_increment;
 795              		.loc 1 523 0
 796 0026 7B88     		ldrh	r3, [r7, #2]
 797 0028 5B42     		negs	r3, r3
 798 002a FB81     		strh	r3, [r7, #14]	@ movhi
 524:../lwip-1.4.1/src/core/pbuf.c ****     /* Check that we aren't going to move off the end of the pbuf */
 525:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 799              		.loc 1 525 0
 800 002c 7B68     		ldr	r3, [r7, #4]
 801 002e 5B89     		ldrh	r3, [r3, #10]
 802 0030 FA89     		ldrh	r2, [r7, #14]
 803 0032 9A42     		cmp	r2, r3
 804 0034 03D9     		bls	.L57
 805              		.loc 1 525 0 is_stmt 0 discriminator 1
 806 0036 0123     		movs	r3, #1
 807 0038 4CE0     		b	.L55
 808              	.L56:
 526:../lwip-1.4.1/src/core/pbuf.c ****   } else {
 527:../lwip-1.4.1/src/core/pbuf.c ****     increment_magnitude = header_size_increment;
 809              		.loc 1 527 0 is_stmt 1
 810 003a 7B88     		ldrh	r3, [r7, #2]	@ movhi
 811 003c FB81     		strh	r3, [r7, #14]	@ movhi
 812              	.L57:
 528:../lwip-1.4.1/src/core/pbuf.c **** #if 0
 529:../lwip-1.4.1/src/core/pbuf.c ****     /* Can't assert these as some callers speculatively call
 530:../lwip-1.4.1/src/core/pbuf.c ****          pbuf_header() to see if it's OK.  Will return 1 below instead. */
 531:../lwip-1.4.1/src/core/pbuf.c ****     /* Check that we've got the correct type of pbuf to work with */
 532:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
 533:../lwip-1.4.1/src/core/pbuf.c ****                 p->type == PBUF_RAM || p->type == PBUF_POOL);
 534:../lwip-1.4.1/src/core/pbuf.c ****     /* Check that we aren't going to move off the beginning of the pbuf */
 535:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
 536:../lwip-1.4.1/src/core/pbuf.c ****                 (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
 537:../lwip-1.4.1/src/core/pbuf.c **** #endif
 538:../lwip-1.4.1/src/core/pbuf.c ****   }
 539:../lwip-1.4.1/src/core/pbuf.c **** 
 540:../lwip-1.4.1/src/core/pbuf.c ****   type = p->type;
 813              		.loc 1 540 0
 814 003e 7B68     		ldr	r3, [r7, #4]
 815 0040 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 816 0042 BB81     		strh	r3, [r7, #12]	@ movhi
 541:../lwip-1.4.1/src/core/pbuf.c ****   /* remember current payload pointer */
 542:../lwip-1.4.1/src/core/pbuf.c ****   payload = p->payload;
 817              		.loc 1 542 0
 818 0044 7B68     		ldr	r3, [r7, #4]
 819 0046 5B68     		ldr	r3, [r3, #4]
 820 0048 BB60     		str	r3, [r7, #8]
 543:../lwip-1.4.1/src/core/pbuf.c **** 
 544:../lwip-1.4.1/src/core/pbuf.c ****   /* pbuf types containing payloads? */
 545:../lwip-1.4.1/src/core/pbuf.c ****   if (type == PBUF_RAM || type == PBUF_POOL) {
 821              		.loc 1 545 0
 822 004a BB89     		ldrh	r3, [r7, #12]
 823 004c 002B     		cmp	r3, #0
 824 004e 02D0     		beq	.L58
 825              		.loc 1 545 0 is_stmt 0 discriminator 1
 826 0050 BB89     		ldrh	r3, [r7, #12]
 827 0052 032B     		cmp	r3, #3
 828 0054 13D1     		bne	.L59
 829              	.L58:
 546:../lwip-1.4.1/src/core/pbuf.c ****     /* set new payload pointer */
 547:../lwip-1.4.1/src/core/pbuf.c ****     p->payload = (u8_t *)p->payload - header_size_increment;
 830              		.loc 1 547 0 is_stmt 1
 831 0056 7B68     		ldr	r3, [r7, #4]
 832 0058 5A68     		ldr	r2, [r3, #4]
 833 005a B7F90230 		ldrsh	r3, [r7, #2]
 834 005e 5B42     		negs	r3, r3
 835 0060 1A44     		add	r2, r2, r3
 836 0062 7B68     		ldr	r3, [r7, #4]
 837 0064 5A60     		str	r2, [r3, #4]
 548:../lwip-1.4.1/src/core/pbuf.c ****     /* boundary check fails? */
 549:../lwip-1.4.1/src/core/pbuf.c ****     if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 838              		.loc 1 549 0
 839 0066 7B68     		ldr	r3, [r7, #4]
 840 0068 5A68     		ldr	r2, [r3, #4]
 841 006a 7B68     		ldr	r3, [r7, #4]
 842 006c 1033     		adds	r3, r3, #16
 843 006e 9A42     		cmp	r2, r3
 844 0070 04D2     		bcs	.L60
 550:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 551:../lwip-1.4.1/src/core/pbuf.c ****         ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
 552:../lwip-1.4.1/src/core/pbuf.c ****         (void *)p->payload, (void *)(p + 1)));
 553:../lwip-1.4.1/src/core/pbuf.c ****       /* restore old payload pointer */
 554:../lwip-1.4.1/src/core/pbuf.c ****       p->payload = payload;
 845              		.loc 1 554 0
 846 0072 7B68     		ldr	r3, [r7, #4]
 847 0074 BA68     		ldr	r2, [r7, #8]
 848 0076 5A60     		str	r2, [r3, #4]
 555:../lwip-1.4.1/src/core/pbuf.c ****       /* bail out unsuccesfully */
 556:../lwip-1.4.1/src/core/pbuf.c ****       return 1;
 849              		.loc 1 556 0
 850 0078 0123     		movs	r3, #1
 851 007a 2BE0     		b	.L55
 852              	.L60:
 549:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 853              		.loc 1 549 0
 854 007c 1BE0     		b	.L61
 855              	.L59:
 557:../lwip-1.4.1/src/core/pbuf.c ****     }
 558:../lwip-1.4.1/src/core/pbuf.c ****   /* pbuf types refering to external payloads? */
 559:../lwip-1.4.1/src/core/pbuf.c ****   } else if (type == PBUF_REF || type == PBUF_ROM) {
 856              		.loc 1 559 0
 857 007e BB89     		ldrh	r3, [r7, #12]
 858 0080 022B     		cmp	r3, #2
 859 0082 02D0     		beq	.L62
 860              		.loc 1 559 0 is_stmt 0 discriminator 1
 861 0084 BB89     		ldrh	r3, [r7, #12]
 862 0086 012B     		cmp	r3, #1
 863 0088 13D1     		bne	.L63
 864              	.L62:
 560:../lwip-1.4.1/src/core/pbuf.c ****     /* hide a header in the payload? */
 561:../lwip-1.4.1/src/core/pbuf.c ****     if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 865              		.loc 1 561 0 is_stmt 1
 866 008a B7F90230 		ldrsh	r3, [r7, #2]
 867 008e 002B     		cmp	r3, #0
 868 0090 0DDA     		bge	.L64
 869              		.loc 1 561 0 is_stmt 0 discriminator 1
 870 0092 7B68     		ldr	r3, [r7, #4]
 871 0094 5B89     		ldrh	r3, [r3, #10]
 872 0096 FA89     		ldrh	r2, [r7, #14]
 873 0098 9A42     		cmp	r2, r3
 874 009a 08D8     		bhi	.L64
 562:../lwip-1.4.1/src/core/pbuf.c ****       /* increase payload pointer */
 563:../lwip-1.4.1/src/core/pbuf.c ****       p->payload = (u8_t *)p->payload - header_size_increment;
 875              		.loc 1 563 0 is_stmt 1
 876 009c 7B68     		ldr	r3, [r7, #4]
 877 009e 5A68     		ldr	r2, [r3, #4]
 878 00a0 B7F90230 		ldrsh	r3, [r7, #2]
 879 00a4 5B42     		negs	r3, r3
 880 00a6 1A44     		add	r2, r2, r3
 881 00a8 7B68     		ldr	r3, [r7, #4]
 882 00aa 5A60     		str	r2, [r3, #4]
 561:../lwip-1.4.1/src/core/pbuf.c ****       /* increase payload pointer */
 883              		.loc 1 561 0
 884 00ac 03E0     		b	.L61
 885              	.L64:
 564:../lwip-1.4.1/src/core/pbuf.c ****     } else {
 565:../lwip-1.4.1/src/core/pbuf.c ****       /* cannot expand payload to front (yet!)
 566:../lwip-1.4.1/src/core/pbuf.c ****        * bail out unsuccesfully */
 567:../lwip-1.4.1/src/core/pbuf.c ****       return 1;
 886              		.loc 1 567 0
 887 00ae 0123     		movs	r3, #1
 888 00b0 10E0     		b	.L55
 889              	.L63:
 568:../lwip-1.4.1/src/core/pbuf.c ****     }
 569:../lwip-1.4.1/src/core/pbuf.c ****   } else {
 570:../lwip-1.4.1/src/core/pbuf.c ****     /* Unknown type */
 571:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("bad pbuf type", 0);
 572:../lwip-1.4.1/src/core/pbuf.c ****     return 1;
 890              		.loc 1 572 0
 891 00b2 0123     		movs	r3, #1
 892 00b4 0EE0     		b	.L55
 893              	.L61:
 573:../lwip-1.4.1/src/core/pbuf.c ****   }
 574:../lwip-1.4.1/src/core/pbuf.c ****   /* modify pbuf length fields */
 575:../lwip-1.4.1/src/core/pbuf.c ****   p->len += header_size_increment;
 894              		.loc 1 575 0
 895 00b6 7B68     		ldr	r3, [r7, #4]
 896 00b8 5A89     		ldrh	r2, [r3, #10]
 897 00ba 7B88     		ldrh	r3, [r7, #2]
 898 00bc 1344     		add	r3, r3, r2
 899 00be 9AB2     		uxth	r2, r3
 900 00c0 7B68     		ldr	r3, [r7, #4]
 901 00c2 5A81     		strh	r2, [r3, #10]	@ movhi
 576:../lwip-1.4.1/src/core/pbuf.c ****   p->tot_len += header_size_increment;
 902              		.loc 1 576 0
 903 00c4 7B68     		ldr	r3, [r7, #4]
 904 00c6 1A89     		ldrh	r2, [r3, #8]
 905 00c8 7B88     		ldrh	r3, [r7, #2]
 906 00ca 1344     		add	r3, r3, r2
 907 00cc 9AB2     		uxth	r2, r3
 908 00ce 7B68     		ldr	r3, [r7, #4]
 909 00d0 1A81     		strh	r2, [r3, #8]	@ movhi
 577:../lwip-1.4.1/src/core/pbuf.c **** 
 578:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
 579:../lwip-1.4.1/src/core/pbuf.c ****     (void *)payload, (void *)p->payload, header_size_increment));
 580:../lwip-1.4.1/src/core/pbuf.c **** 
 581:../lwip-1.4.1/src/core/pbuf.c ****   return 0;
 910              		.loc 1 581 0
 911 00d2 0023     		movs	r3, #0
 912              	.L55:
 582:../lwip-1.4.1/src/core/pbuf.c **** }
 913              		.loc 1 582 0
 914 00d4 1846     		mov	r0, r3
 915 00d6 1437     		adds	r7, r7, #20
 916              		.cfi_def_cfa_offset 4
 917 00d8 BD46     		mov	sp, r7
 918              		.cfi_def_cfa_register 13
 919              		@ sp needed
 920 00da 5DF8047B 		ldr	r7, [sp], #4
 921              		.cfi_restore 7
 922              		.cfi_def_cfa_offset 0
 923 00de 7047     		bx	lr
 924              		.cfi_endproc
 925              	.LFE5:
 927              		.section	.text.pbuf_free,"ax",%progbits
 928              		.align	2
 929              		.global	pbuf_free
 930              		.thumb
 931              		.thumb_func
 933              	pbuf_free:
 934              	.LFB6:
 583:../lwip-1.4.1/src/core/pbuf.c **** 
 584:../lwip-1.4.1/src/core/pbuf.c **** /**
 585:../lwip-1.4.1/src/core/pbuf.c ****  * Dereference a pbuf chain or queue and deallocate any no-longer-used
 586:../lwip-1.4.1/src/core/pbuf.c ****  * pbufs at the head of this chain or queue.
 587:../lwip-1.4.1/src/core/pbuf.c ****  *
 588:../lwip-1.4.1/src/core/pbuf.c ****  * Decrements the pbuf reference count. If it reaches zero, the pbuf is
 589:../lwip-1.4.1/src/core/pbuf.c ****  * deallocated.
 590:../lwip-1.4.1/src/core/pbuf.c ****  *
 591:../lwip-1.4.1/src/core/pbuf.c ****  * For a pbuf chain, this is repeated for each pbuf in the chain,
 592:../lwip-1.4.1/src/core/pbuf.c ****  * up to the first pbuf which has a non-zero reference count after
 593:../lwip-1.4.1/src/core/pbuf.c ****  * decrementing. So, when all reference counts are one, the whole
 594:../lwip-1.4.1/src/core/pbuf.c ****  * chain is free'd.
 595:../lwip-1.4.1/src/core/pbuf.c ****  *
 596:../lwip-1.4.1/src/core/pbuf.c ****  * @param p The pbuf (chain) to be dereferenced.
 597:../lwip-1.4.1/src/core/pbuf.c ****  *
 598:../lwip-1.4.1/src/core/pbuf.c ****  * @return the number of pbufs that were de-allocated
 599:../lwip-1.4.1/src/core/pbuf.c ****  * from the head of the chain.
 600:../lwip-1.4.1/src/core/pbuf.c ****  *
 601:../lwip-1.4.1/src/core/pbuf.c ****  * @note MUST NOT be called on a packet queue (Not verified to work yet).
 602:../lwip-1.4.1/src/core/pbuf.c ****  * @note the reference counter of a pbuf equals the number of pointers
 603:../lwip-1.4.1/src/core/pbuf.c ****  * that refer to the pbuf (or into the pbuf).
 604:../lwip-1.4.1/src/core/pbuf.c ****  *
 605:../lwip-1.4.1/src/core/pbuf.c ****  * @internal examples:
 606:../lwip-1.4.1/src/core/pbuf.c ****  *
 607:../lwip-1.4.1/src/core/pbuf.c ****  * Assuming existing chains a->b->c with the following reference
 608:../lwip-1.4.1/src/core/pbuf.c ****  * counts, calling pbuf_free(a) results in:
 609:../lwip-1.4.1/src/core/pbuf.c ****  * 
 610:../lwip-1.4.1/src/core/pbuf.c ****  * 1->2->3 becomes ...1->3
 611:../lwip-1.4.1/src/core/pbuf.c ****  * 3->3->3 becomes 2->3->3
 612:../lwip-1.4.1/src/core/pbuf.c ****  * 1->1->2 becomes ......1
 613:../lwip-1.4.1/src/core/pbuf.c ****  * 2->1->1 becomes 1->1->1
 614:../lwip-1.4.1/src/core/pbuf.c ****  * 1->1->1 becomes .......
 615:../lwip-1.4.1/src/core/pbuf.c ****  *
 616:../lwip-1.4.1/src/core/pbuf.c ****  */
 617:../lwip-1.4.1/src/core/pbuf.c **** u8_t
 618:../lwip-1.4.1/src/core/pbuf.c **** pbuf_free(struct pbuf *p)
 619:../lwip-1.4.1/src/core/pbuf.c **** {
 935              		.loc 1 619 0
 936              		.cfi_startproc
 937              		@ args = 0, pretend = 0, frame = 24
 938              		@ frame_needed = 1, uses_anonymous_args = 0
 939 0000 80B5     		push	{r7, lr}
 940              		.cfi_def_cfa_offset 8
 941              		.cfi_offset 7, -8
 942              		.cfi_offset 14, -4
 943 0002 86B0     		sub	sp, sp, #24
 944              		.cfi_def_cfa_offset 32
 945 0004 00AF     		add	r7, sp, #0
 946              		.cfi_def_cfa_register 7
 947 0006 7860     		str	r0, [r7, #4]
 620:../lwip-1.4.1/src/core/pbuf.c ****   u16_t type;
 621:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *q;
 622:../lwip-1.4.1/src/core/pbuf.c ****   u8_t count;
 623:../lwip-1.4.1/src/core/pbuf.c **** 
 624:../lwip-1.4.1/src/core/pbuf.c ****   if (p == NULL) {
 948              		.loc 1 624 0
 949 0008 7B68     		ldr	r3, [r7, #4]
 950 000a 002B     		cmp	r3, #0
 951 000c 01D1     		bne	.L66
 625:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("p != NULL", p != NULL);
 626:../lwip-1.4.1/src/core/pbuf.c ****     /* if assertions are disabled, proceed with debug output */
 627:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 628:../lwip-1.4.1/src/core/pbuf.c ****       ("pbuf_free(p == NULL) was called.\n"));
 629:../lwip-1.4.1/src/core/pbuf.c ****     return 0;
 952              		.loc 1 629 0
 953 000e 0023     		movs	r3, #0
 954 0010 4EE0     		b	.L67
 955              	.L66:
 630:../lwip-1.4.1/src/core/pbuf.c ****   }
 631:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
 632:../lwip-1.4.1/src/core/pbuf.c **** 
 633:../lwip-1.4.1/src/core/pbuf.c ****   PERF_START;
 634:../lwip-1.4.1/src/core/pbuf.c **** 
 635:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("pbuf_free: sane type",
 956              		.loc 1 635 0
 957 0012 7B68     		ldr	r3, [r7, #4]
 958 0014 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 959 0016 002B     		cmp	r3, #0
 960 0018 06D0     		beq	.L68
 961              		.loc 1 635 0 is_stmt 0 discriminator 1
 962 001a 7B68     		ldr	r3, [r7, #4]
 963 001c 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 964 001e 012B     		cmp	r3, #1
 965 0020 02D0     		beq	.L68
 966              		.loc 1 635 0 discriminator 2
 967 0022 7B68     		ldr	r3, [r7, #4]
 968 0024 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 969 0026 022B     		cmp	r3, #2
 970              	.L68:
 636:../lwip-1.4.1/src/core/pbuf.c ****     p->type == PBUF_RAM || p->type == PBUF_ROM ||
 637:../lwip-1.4.1/src/core/pbuf.c ****     p->type == PBUF_REF || p->type == PBUF_POOL);
 638:../lwip-1.4.1/src/core/pbuf.c **** 
 639:../lwip-1.4.1/src/core/pbuf.c ****   count = 0;
 971              		.loc 1 639 0 is_stmt 1
 972 0028 0023     		movs	r3, #0
 973 002a FB75     		strb	r3, [r7, #23]
 640:../lwip-1.4.1/src/core/pbuf.c ****   /* de-allocate all consecutive pbufs from the head of the chain that
 641:../lwip-1.4.1/src/core/pbuf.c ****    * obtain a zero reference count after decrementing*/
 642:../lwip-1.4.1/src/core/pbuf.c ****   while (p != NULL) {
 974              		.loc 1 642 0
 975 002c 3CE0     		b	.L69
 976              	.L76:
 977              	.LBB2:
 643:../lwip-1.4.1/src/core/pbuf.c ****     u16_t ref;
 644:../lwip-1.4.1/src/core/pbuf.c ****     SYS_ARCH_DECL_PROTECT(old_level);
 645:../lwip-1.4.1/src/core/pbuf.c ****     /* Since decrementing ref cannot be guaranteed to be a single machine operation
 646:../lwip-1.4.1/src/core/pbuf.c ****      * we must protect it. We put the new ref into a local variable to prevent
 647:../lwip-1.4.1/src/core/pbuf.c ****      * further protection. */
 648:../lwip-1.4.1/src/core/pbuf.c ****     SYS_ARCH_PROTECT(old_level);
 649:../lwip-1.4.1/src/core/pbuf.c ****     /* all pbufs in a chain are referenced at least once */
 650:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 651:../lwip-1.4.1/src/core/pbuf.c ****     /* decrease reference count (number of pointers to pbuf) */
 652:../lwip-1.4.1/src/core/pbuf.c ****     ref = --(p->ref);
 978              		.loc 1 652 0
 979 002e 7B68     		ldr	r3, [r7, #4]
 980 0030 DB89     		ldrh	r3, [r3, #14]
 981 0032 013B     		subs	r3, r3, #1
 982 0034 9AB2     		uxth	r2, r3
 983 0036 7B68     		ldr	r3, [r7, #4]
 984 0038 DA81     		strh	r2, [r3, #14]	@ movhi
 985 003a 7B68     		ldr	r3, [r7, #4]
 986 003c DB89     		ldrh	r3, [r3, #14]	@ movhi
 987 003e BB82     		strh	r3, [r7, #20]	@ movhi
 653:../lwip-1.4.1/src/core/pbuf.c ****     SYS_ARCH_UNPROTECT(old_level);
 654:../lwip-1.4.1/src/core/pbuf.c ****     /* this pbuf is no longer referenced to? */
 655:../lwip-1.4.1/src/core/pbuf.c ****     if (ref == 0) {
 988              		.loc 1 655 0
 989 0040 BB8A     		ldrh	r3, [r7, #20]
 990 0042 002B     		cmp	r3, #0
 991 0044 2ED1     		bne	.L70
 656:../lwip-1.4.1/src/core/pbuf.c ****       /* remember next pbuf in chain for next iteration */
 657:../lwip-1.4.1/src/core/pbuf.c ****       q = p->next;
 992              		.loc 1 657 0
 993 0046 7B68     		ldr	r3, [r7, #4]
 994 0048 1B68     		ldr	r3, [r3]
 995 004a 3B61     		str	r3, [r7, #16]
 658:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
 659:../lwip-1.4.1/src/core/pbuf.c ****       type = p->type;
 996              		.loc 1 659 0
 997 004c 7B68     		ldr	r3, [r7, #4]
 998 004e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 999 0050 FB81     		strh	r3, [r7, #14]	@ movhi
 660:../lwip-1.4.1/src/core/pbuf.c **** #if LWIP_SUPPORT_CUSTOM_PBUF
 661:../lwip-1.4.1/src/core/pbuf.c ****       /* is this a custom pbuf? */
 662:../lwip-1.4.1/src/core/pbuf.c ****       if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 1000              		.loc 1 662 0
 1001 0052 7B68     		ldr	r3, [r7, #4]
 1002 0054 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 1003 0056 03F00203 		and	r3, r3, #2
 1004 005a 002B     		cmp	r3, #0
 1005 005c 06D0     		beq	.L71
 1006              	.LBB3:
 663:../lwip-1.4.1/src/core/pbuf.c ****         struct pbuf_custom *pc = (struct pbuf_custom*)p;
 1007              		.loc 1 663 0
 1008 005e 7B68     		ldr	r3, [r7, #4]
 1009 0060 BB60     		str	r3, [r7, #8]
 664:../lwip-1.4.1/src/core/pbuf.c ****         LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 665:../lwip-1.4.1/src/core/pbuf.c ****         pc->custom_free_function(p);
 1010              		.loc 1 665 0
 1011 0062 BB68     		ldr	r3, [r7, #8]
 1012 0064 1B69     		ldr	r3, [r3, #16]
 1013 0066 7868     		ldr	r0, [r7, #4]
 1014 0068 9847     		blx	r3
 1015              	.LBE3:
 1016 006a 15E0     		b	.L72
 1017              	.L71:
 666:../lwip-1.4.1/src/core/pbuf.c ****       } else
 667:../lwip-1.4.1/src/core/pbuf.c **** #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
 668:../lwip-1.4.1/src/core/pbuf.c ****       {
 669:../lwip-1.4.1/src/core/pbuf.c ****         /* is this a pbuf from the pool? */
 670:../lwip-1.4.1/src/core/pbuf.c ****         if (type == PBUF_POOL) {
 1018              		.loc 1 670 0
 1019 006c FB89     		ldrh	r3, [r7, #14]
 1020 006e 032B     		cmp	r3, #3
 1021 0070 04D1     		bne	.L73
 671:../lwip-1.4.1/src/core/pbuf.c ****           memp_free(MEMP_PBUF_POOL, p);
 1022              		.loc 1 671 0
 1023 0072 0A20     		movs	r0, #10
 1024 0074 7968     		ldr	r1, [r7, #4]
 1025 0076 FFF7FEFF 		bl	memp_free
 1026 007a 0DE0     		b	.L72
 1027              	.L73:
 672:../lwip-1.4.1/src/core/pbuf.c ****         /* is this a ROM or RAM referencing pbuf? */
 673:../lwip-1.4.1/src/core/pbuf.c ****         } else if (type == PBUF_ROM || type == PBUF_REF) {
 1028              		.loc 1 673 0
 1029 007c FB89     		ldrh	r3, [r7, #14]
 1030 007e 012B     		cmp	r3, #1
 1031 0080 02D0     		beq	.L74
 1032              		.loc 1 673 0 is_stmt 0 discriminator 1
 1033 0082 FB89     		ldrh	r3, [r7, #14]
 1034 0084 022B     		cmp	r3, #2
 1035 0086 04D1     		bne	.L75
 1036              	.L74:
 674:../lwip-1.4.1/src/core/pbuf.c ****           memp_free(MEMP_PBUF, p);
 1037              		.loc 1 674 0 is_stmt 1
 1038 0088 0920     		movs	r0, #9
 1039 008a 7968     		ldr	r1, [r7, #4]
 1040 008c FFF7FEFF 		bl	memp_free
 1041 0090 02E0     		b	.L72
 1042              	.L75:
 675:../lwip-1.4.1/src/core/pbuf.c ****         /* type == PBUF_RAM */
 676:../lwip-1.4.1/src/core/pbuf.c ****         } else {
 677:../lwip-1.4.1/src/core/pbuf.c ****           mem_free(p);
 1043              		.loc 1 677 0
 1044 0092 7868     		ldr	r0, [r7, #4]
 1045 0094 FFF7FEFF 		bl	mem_free
 1046              	.L72:
 678:../lwip-1.4.1/src/core/pbuf.c ****         }
 679:../lwip-1.4.1/src/core/pbuf.c ****       }
 680:../lwip-1.4.1/src/core/pbuf.c ****       count++;
 1047              		.loc 1 680 0
 1048 0098 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1049 009a 0133     		adds	r3, r3, #1
 1050 009c FB75     		strb	r3, [r7, #23]
 681:../lwip-1.4.1/src/core/pbuf.c ****       /* proceed to next pbuf */
 682:../lwip-1.4.1/src/core/pbuf.c ****       p = q;
 1051              		.loc 1 682 0
 1052 009e 3B69     		ldr	r3, [r7, #16]
 1053 00a0 7B60     		str	r3, [r7, #4]
 1054 00a2 01E0     		b	.L69
 1055              	.L70:
 683:../lwip-1.4.1/src/core/pbuf.c ****     /* p->ref > 0, this pbuf is still referenced to */
 684:../lwip-1.4.1/src/core/pbuf.c ****     /* (and so the remaining pbufs in chain as well) */
 685:../lwip-1.4.1/src/core/pbuf.c ****     } else {
 686:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", 
 687:../lwip-1.4.1/src/core/pbuf.c ****       /* stop walking through the chain */
 688:../lwip-1.4.1/src/core/pbuf.c ****       p = NULL;
 1056              		.loc 1 688 0
 1057 00a4 0023     		movs	r3, #0
 1058 00a6 7B60     		str	r3, [r7, #4]
 1059              	.L69:
 1060              	.LBE2:
 642:../lwip-1.4.1/src/core/pbuf.c ****     u16_t ref;
 1061              		.loc 1 642 0
 1062 00a8 7B68     		ldr	r3, [r7, #4]
 1063 00aa 002B     		cmp	r3, #0
 1064 00ac BFD1     		bne	.L76
 689:../lwip-1.4.1/src/core/pbuf.c ****     }
 690:../lwip-1.4.1/src/core/pbuf.c ****   }
 691:../lwip-1.4.1/src/core/pbuf.c ****   PERF_STOP("pbuf_free");
 692:../lwip-1.4.1/src/core/pbuf.c ****   /* return number of de-allocated pbufs */
 693:../lwip-1.4.1/src/core/pbuf.c ****   return count;
 1065              		.loc 1 693 0
 1066 00ae FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1067              	.L67:
 694:../lwip-1.4.1/src/core/pbuf.c **** }
 1068              		.loc 1 694 0
 1069 00b0 1846     		mov	r0, r3
 1070 00b2 1837     		adds	r7, r7, #24
 1071              		.cfi_def_cfa_offset 8
 1072 00b4 BD46     		mov	sp, r7
 1073              		.cfi_def_cfa_register 13
 1074              		@ sp needed
 1075 00b6 80BD     		pop	{r7, pc}
 1076              		.cfi_endproc
 1077              	.LFE6:
 1079              		.section	.text.pbuf_clen,"ax",%progbits
 1080              		.align	2
 1081              		.global	pbuf_clen
 1082              		.thumb
 1083              		.thumb_func
 1085              	pbuf_clen:
 1086              	.LFB7:
 695:../lwip-1.4.1/src/core/pbuf.c **** 
 696:../lwip-1.4.1/src/core/pbuf.c **** /**
 697:../lwip-1.4.1/src/core/pbuf.c ****  * Count number of pbufs in a chain
 698:../lwip-1.4.1/src/core/pbuf.c ****  *
 699:../lwip-1.4.1/src/core/pbuf.c ****  * @param p first pbuf of chain
 700:../lwip-1.4.1/src/core/pbuf.c ****  * @return the number of pbufs in a chain
 701:../lwip-1.4.1/src/core/pbuf.c ****  */
 702:../lwip-1.4.1/src/core/pbuf.c **** 
 703:../lwip-1.4.1/src/core/pbuf.c **** u8_t
 704:../lwip-1.4.1/src/core/pbuf.c **** pbuf_clen(struct pbuf *p)
 705:../lwip-1.4.1/src/core/pbuf.c **** {
 1087              		.loc 1 705 0
 1088              		.cfi_startproc
 1089              		@ args = 0, pretend = 0, frame = 16
 1090              		@ frame_needed = 1, uses_anonymous_args = 0
 1091              		@ link register save eliminated.
 1092 0000 80B4     		push	{r7}
 1093              		.cfi_def_cfa_offset 4
 1094              		.cfi_offset 7, -4
 1095 0002 85B0     		sub	sp, sp, #20
 1096              		.cfi_def_cfa_offset 24
 1097 0004 00AF     		add	r7, sp, #0
 1098              		.cfi_def_cfa_register 7
 1099 0006 7860     		str	r0, [r7, #4]
 706:../lwip-1.4.1/src/core/pbuf.c ****   u8_t len;
 707:../lwip-1.4.1/src/core/pbuf.c **** 
 708:../lwip-1.4.1/src/core/pbuf.c ****   len = 0;
 1100              		.loc 1 708 0
 1101 0008 0023     		movs	r3, #0
 1102 000a FB73     		strb	r3, [r7, #15]
 709:../lwip-1.4.1/src/core/pbuf.c ****   while (p != NULL) {
 1103              		.loc 1 709 0
 1104 000c 05E0     		b	.L78
 1105              	.L79:
 710:../lwip-1.4.1/src/core/pbuf.c ****     ++len;
 1106              		.loc 1 710 0
 1107 000e FB7B     		ldrb	r3, [r7, #15]
 1108 0010 0133     		adds	r3, r3, #1
 1109 0012 FB73     		strb	r3, [r7, #15]
 711:../lwip-1.4.1/src/core/pbuf.c ****     p = p->next;
 1110              		.loc 1 711 0
 1111 0014 7B68     		ldr	r3, [r7, #4]
 1112 0016 1B68     		ldr	r3, [r3]
 1113 0018 7B60     		str	r3, [r7, #4]
 1114              	.L78:
 709:../lwip-1.4.1/src/core/pbuf.c ****   while (p != NULL) {
 1115              		.loc 1 709 0
 1116 001a 7B68     		ldr	r3, [r7, #4]
 1117 001c 002B     		cmp	r3, #0
 1118 001e F6D1     		bne	.L79
 712:../lwip-1.4.1/src/core/pbuf.c ****   }
 713:../lwip-1.4.1/src/core/pbuf.c ****   return len;
 1119              		.loc 1 713 0
 1120 0020 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 714:../lwip-1.4.1/src/core/pbuf.c **** }
 1121              		.loc 1 714 0
 1122 0022 1846     		mov	r0, r3
 1123 0024 1437     		adds	r7, r7, #20
 1124              		.cfi_def_cfa_offset 4
 1125 0026 BD46     		mov	sp, r7
 1126              		.cfi_def_cfa_register 13
 1127              		@ sp needed
 1128 0028 5DF8047B 		ldr	r7, [sp], #4
 1129              		.cfi_restore 7
 1130              		.cfi_def_cfa_offset 0
 1131 002c 7047     		bx	lr
 1132              		.cfi_endproc
 1133              	.LFE7:
 1135 002e 00BF     		.section	.text.pbuf_ref,"ax",%progbits
 1136              		.align	2
 1137              		.global	pbuf_ref
 1138              		.thumb
 1139              		.thumb_func
 1141              	pbuf_ref:
 1142              	.LFB8:
 715:../lwip-1.4.1/src/core/pbuf.c **** 
 716:../lwip-1.4.1/src/core/pbuf.c **** /**
 717:../lwip-1.4.1/src/core/pbuf.c ****  * Increment the reference count of the pbuf.
 718:../lwip-1.4.1/src/core/pbuf.c ****  *
 719:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to increase reference counter of
 720:../lwip-1.4.1/src/core/pbuf.c ****  *
 721:../lwip-1.4.1/src/core/pbuf.c ****  */
 722:../lwip-1.4.1/src/core/pbuf.c **** void
 723:../lwip-1.4.1/src/core/pbuf.c **** pbuf_ref(struct pbuf *p)
 724:../lwip-1.4.1/src/core/pbuf.c **** {
 1143              		.loc 1 724 0
 1144              		.cfi_startproc
 1145              		@ args = 0, pretend = 0, frame = 8
 1146              		@ frame_needed = 1, uses_anonymous_args = 0
 1147              		@ link register save eliminated.
 1148 0000 80B4     		push	{r7}
 1149              		.cfi_def_cfa_offset 4
 1150              		.cfi_offset 7, -4
 1151 0002 83B0     		sub	sp, sp, #12
 1152              		.cfi_def_cfa_offset 16
 1153 0004 00AF     		add	r7, sp, #0
 1154              		.cfi_def_cfa_register 7
 1155 0006 7860     		str	r0, [r7, #4]
 725:../lwip-1.4.1/src/core/pbuf.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 726:../lwip-1.4.1/src/core/pbuf.c ****   /* pbuf given? */
 727:../lwip-1.4.1/src/core/pbuf.c ****   if (p != NULL) {
 1156              		.loc 1 727 0
 1157 0008 7B68     		ldr	r3, [r7, #4]
 1158 000a 002B     		cmp	r3, #0
 1159 000c 05D0     		beq	.L81
 728:../lwip-1.4.1/src/core/pbuf.c ****     SYS_ARCH_PROTECT(old_level);
 729:../lwip-1.4.1/src/core/pbuf.c ****     ++(p->ref);
 1160              		.loc 1 729 0
 1161 000e 7B68     		ldr	r3, [r7, #4]
 1162 0010 DB89     		ldrh	r3, [r3, #14]
 1163 0012 0133     		adds	r3, r3, #1
 1164 0014 9AB2     		uxth	r2, r3
 1165 0016 7B68     		ldr	r3, [r7, #4]
 1166 0018 DA81     		strh	r2, [r3, #14]	@ movhi
 1167              	.L81:
 730:../lwip-1.4.1/src/core/pbuf.c ****     SYS_ARCH_UNPROTECT(old_level);
 731:../lwip-1.4.1/src/core/pbuf.c ****   }
 732:../lwip-1.4.1/src/core/pbuf.c **** }
 1168              		.loc 1 732 0
 1169 001a 0C37     		adds	r7, r7, #12
 1170              		.cfi_def_cfa_offset 4
 1171 001c BD46     		mov	sp, r7
 1172              		.cfi_def_cfa_register 13
 1173              		@ sp needed
 1174 001e 5DF8047B 		ldr	r7, [sp], #4
 1175              		.cfi_restore 7
 1176              		.cfi_def_cfa_offset 0
 1177 0022 7047     		bx	lr
 1178              		.cfi_endproc
 1179              	.LFE8:
 1181              		.section	.text.pbuf_cat,"ax",%progbits
 1182              		.align	2
 1183              		.global	pbuf_cat
 1184              		.thumb
 1185              		.thumb_func
 1187              	pbuf_cat:
 1188              	.LFB9:
 733:../lwip-1.4.1/src/core/pbuf.c **** 
 734:../lwip-1.4.1/src/core/pbuf.c **** /**
 735:../lwip-1.4.1/src/core/pbuf.c ****  * Concatenate two pbufs (each may be a pbuf chain) and take over
 736:../lwip-1.4.1/src/core/pbuf.c ****  * the caller's reference of the tail pbuf.
 737:../lwip-1.4.1/src/core/pbuf.c ****  * 
 738:../lwip-1.4.1/src/core/pbuf.c ****  * @note The caller MAY NOT reference the tail pbuf afterwards.
 739:../lwip-1.4.1/src/core/pbuf.c ****  * Use pbuf_chain() for that purpose.
 740:../lwip-1.4.1/src/core/pbuf.c ****  * 
 741:../lwip-1.4.1/src/core/pbuf.c ****  * @see pbuf_chain()
 742:../lwip-1.4.1/src/core/pbuf.c ****  */
 743:../lwip-1.4.1/src/core/pbuf.c **** 
 744:../lwip-1.4.1/src/core/pbuf.c **** void
 745:../lwip-1.4.1/src/core/pbuf.c **** pbuf_cat(struct pbuf *h, struct pbuf *t)
 746:../lwip-1.4.1/src/core/pbuf.c **** {
 1189              		.loc 1 746 0
 1190              		.cfi_startproc
 1191              		@ args = 0, pretend = 0, frame = 16
 1192              		@ frame_needed = 1, uses_anonymous_args = 0
 1193              		@ link register save eliminated.
 1194 0000 80B4     		push	{r7}
 1195              		.cfi_def_cfa_offset 4
 1196              		.cfi_offset 7, -4
 1197 0002 85B0     		sub	sp, sp, #20
 1198              		.cfi_def_cfa_offset 24
 1199 0004 00AF     		add	r7, sp, #0
 1200              		.cfi_def_cfa_register 7
 1201 0006 7860     		str	r0, [r7, #4]
 1202 0008 3960     		str	r1, [r7]
 747:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *p;
 748:../lwip-1.4.1/src/core/pbuf.c **** 
 749:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 1203              		.loc 1 749 0
 1204 000a 7B68     		ldr	r3, [r7, #4]
 1205 000c 002B     		cmp	r3, #0
 1206 000e 02D0     		beq	.L84
 1207              		.loc 1 749 0 is_stmt 0 discriminator 1
 1208 0010 3B68     		ldr	r3, [r7]
 1209 0012 002B     		cmp	r3, #0
 1210 0014 00D1     		bne	.L85
 1211              	.L84:
 1212              		.loc 1 749 0
 1213 0016 1CE0     		b	.L83
 1214              	.L85:
 750:../lwip-1.4.1/src/core/pbuf.c ****              ((h != NULL) && (t != NULL)), return;);
 751:../lwip-1.4.1/src/core/pbuf.c **** 
 752:../lwip-1.4.1/src/core/pbuf.c ****   /* proceed to last pbuf of chain */
 753:../lwip-1.4.1/src/core/pbuf.c ****   for (p = h; p->next != NULL; p = p->next) {
 1215              		.loc 1 753 0 is_stmt 1
 1216 0018 7B68     		ldr	r3, [r7, #4]
 1217 001a FB60     		str	r3, [r7, #12]
 1218 001c 0AE0     		b	.L87
 1219              	.L88:
 754:../lwip-1.4.1/src/core/pbuf.c ****     /* add total length of second chain to all totals of first chain */
 755:../lwip-1.4.1/src/core/pbuf.c ****     p->tot_len += t->tot_len;
 1220              		.loc 1 755 0 discriminator 3
 1221 001e FB68     		ldr	r3, [r7, #12]
 1222 0020 1A89     		ldrh	r2, [r3, #8]
 1223 0022 3B68     		ldr	r3, [r7]
 1224 0024 1B89     		ldrh	r3, [r3, #8]
 1225 0026 1344     		add	r3, r3, r2
 1226 0028 9AB2     		uxth	r2, r3
 1227 002a FB68     		ldr	r3, [r7, #12]
 1228 002c 1A81     		strh	r2, [r3, #8]	@ movhi
 753:../lwip-1.4.1/src/core/pbuf.c ****     /* add total length of second chain to all totals of first chain */
 1229              		.loc 1 753 0 discriminator 3
 1230 002e FB68     		ldr	r3, [r7, #12]
 1231 0030 1B68     		ldr	r3, [r3]
 1232 0032 FB60     		str	r3, [r7, #12]
 1233              	.L87:
 753:../lwip-1.4.1/src/core/pbuf.c ****     /* add total length of second chain to all totals of first chain */
 1234              		.loc 1 753 0 is_stmt 0 discriminator 1
 1235 0034 FB68     		ldr	r3, [r7, #12]
 1236 0036 1B68     		ldr	r3, [r3]
 1237 0038 002B     		cmp	r3, #0
 1238 003a F0D1     		bne	.L88
 756:../lwip-1.4.1/src/core/pbuf.c ****   }
 757:../lwip-1.4.1/src/core/pbuf.c ****   /* { p is last pbuf of first h chain, p->next == NULL } */
 758:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 759:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("p->next == NULL", p->next == NULL);
 760:../lwip-1.4.1/src/core/pbuf.c ****   /* add total length of second chain to last pbuf total of first chain */
 761:../lwip-1.4.1/src/core/pbuf.c ****   p->tot_len += t->tot_len;
 1239              		.loc 1 761 0 is_stmt 1
 1240 003c FB68     		ldr	r3, [r7, #12]
 1241 003e 1A89     		ldrh	r2, [r3, #8]
 1242 0040 3B68     		ldr	r3, [r7]
 1243 0042 1B89     		ldrh	r3, [r3, #8]
 1244 0044 1344     		add	r3, r3, r2
 1245 0046 9AB2     		uxth	r2, r3
 1246 0048 FB68     		ldr	r3, [r7, #12]
 1247 004a 1A81     		strh	r2, [r3, #8]	@ movhi
 762:../lwip-1.4.1/src/core/pbuf.c ****   /* chain last pbuf of head (p) with first of tail (t) */
 763:../lwip-1.4.1/src/core/pbuf.c ****   p->next = t;
 1248              		.loc 1 763 0
 1249 004c FB68     		ldr	r3, [r7, #12]
 1250 004e 3A68     		ldr	r2, [r7]
 1251 0050 1A60     		str	r2, [r3]
 1252              	.L83:
 764:../lwip-1.4.1/src/core/pbuf.c ****   /* p->next now references t, but the caller will drop its reference to t,
 765:../lwip-1.4.1/src/core/pbuf.c ****    * so netto there is no change to the reference count of t.
 766:../lwip-1.4.1/src/core/pbuf.c ****    */
 767:../lwip-1.4.1/src/core/pbuf.c **** }
 1253              		.loc 1 767 0
 1254 0052 1437     		adds	r7, r7, #20
 1255              		.cfi_def_cfa_offset 4
 1256 0054 BD46     		mov	sp, r7
 1257              		.cfi_def_cfa_register 13
 1258              		@ sp needed
 1259 0056 5DF8047B 		ldr	r7, [sp], #4
 1260              		.cfi_restore 7
 1261              		.cfi_def_cfa_offset 0
 1262 005a 7047     		bx	lr
 1263              		.cfi_endproc
 1264              	.LFE9:
 1266              		.section	.text.pbuf_chain,"ax",%progbits
 1267              		.align	2
 1268              		.global	pbuf_chain
 1269              		.thumb
 1270              		.thumb_func
 1272              	pbuf_chain:
 1273              	.LFB10:
 768:../lwip-1.4.1/src/core/pbuf.c **** 
 769:../lwip-1.4.1/src/core/pbuf.c **** /**
 770:../lwip-1.4.1/src/core/pbuf.c ****  * Chain two pbufs (or pbuf chains) together.
 771:../lwip-1.4.1/src/core/pbuf.c ****  * 
 772:../lwip-1.4.1/src/core/pbuf.c ****  * The caller MUST call pbuf_free(t) once it has stopped
 773:../lwip-1.4.1/src/core/pbuf.c ****  * using it. Use pbuf_cat() instead if you no longer use t.
 774:../lwip-1.4.1/src/core/pbuf.c ****  * 
 775:../lwip-1.4.1/src/core/pbuf.c ****  * @param h head pbuf (chain)
 776:../lwip-1.4.1/src/core/pbuf.c ****  * @param t tail pbuf (chain)
 777:../lwip-1.4.1/src/core/pbuf.c ****  * @note The pbufs MUST belong to the same packet.
 778:../lwip-1.4.1/src/core/pbuf.c ****  * @note MAY NOT be called on a packet queue.
 779:../lwip-1.4.1/src/core/pbuf.c ****  *
 780:../lwip-1.4.1/src/core/pbuf.c ****  * The ->tot_len fields of all pbufs of the head chain are adjusted.
 781:../lwip-1.4.1/src/core/pbuf.c ****  * The ->next field of the last pbuf of the head chain is adjusted.
 782:../lwip-1.4.1/src/core/pbuf.c ****  * The ->ref field of the first pbuf of the tail chain is adjusted.
 783:../lwip-1.4.1/src/core/pbuf.c ****  *
 784:../lwip-1.4.1/src/core/pbuf.c ****  */
 785:../lwip-1.4.1/src/core/pbuf.c **** void
 786:../lwip-1.4.1/src/core/pbuf.c **** pbuf_chain(struct pbuf *h, struct pbuf *t)
 787:../lwip-1.4.1/src/core/pbuf.c **** {
 1274              		.loc 1 787 0
 1275              		.cfi_startproc
 1276              		@ args = 0, pretend = 0, frame = 8
 1277              		@ frame_needed = 1, uses_anonymous_args = 0
 1278 0000 80B5     		push	{r7, lr}
 1279              		.cfi_def_cfa_offset 8
 1280              		.cfi_offset 7, -8
 1281              		.cfi_offset 14, -4
 1282 0002 82B0     		sub	sp, sp, #8
 1283              		.cfi_def_cfa_offset 16
 1284 0004 00AF     		add	r7, sp, #0
 1285              		.cfi_def_cfa_register 7
 1286 0006 7860     		str	r0, [r7, #4]
 1287 0008 3960     		str	r1, [r7]
 788:../lwip-1.4.1/src/core/pbuf.c ****   pbuf_cat(h, t);
 1288              		.loc 1 788 0
 1289 000a 7868     		ldr	r0, [r7, #4]
 1290 000c 3968     		ldr	r1, [r7]
 1291 000e FFF7FEFF 		bl	pbuf_cat
 789:../lwip-1.4.1/src/core/pbuf.c ****   /* t is now referenced by h */
 790:../lwip-1.4.1/src/core/pbuf.c ****   pbuf_ref(t);
 1292              		.loc 1 790 0
 1293 0012 3868     		ldr	r0, [r7]
 1294 0014 FFF7FEFF 		bl	pbuf_ref
 791:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t)
 792:../lwip-1.4.1/src/core/pbuf.c **** }
 1295              		.loc 1 792 0
 1296 0018 0837     		adds	r7, r7, #8
 1297              		.cfi_def_cfa_offset 8
 1298 001a BD46     		mov	sp, r7
 1299              		.cfi_def_cfa_register 13
 1300              		@ sp needed
 1301 001c 80BD     		pop	{r7, pc}
 1302              		.cfi_endproc
 1303              	.LFE10:
 1305 001e 00BF     		.section	.text.pbuf_dechain,"ax",%progbits
 1306              		.align	2
 1307              		.global	pbuf_dechain
 1308              		.thumb
 1309              		.thumb_func
 1311              	pbuf_dechain:
 1312              	.LFB11:
 793:../lwip-1.4.1/src/core/pbuf.c **** 
 794:../lwip-1.4.1/src/core/pbuf.c **** /**
 795:../lwip-1.4.1/src/core/pbuf.c ****  * Dechains the first pbuf from its succeeding pbufs in the chain.
 796:../lwip-1.4.1/src/core/pbuf.c ****  *
 797:../lwip-1.4.1/src/core/pbuf.c ****  * Makes p->tot_len field equal to p->len.
 798:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to dechain
 799:../lwip-1.4.1/src/core/pbuf.c ****  * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 800:../lwip-1.4.1/src/core/pbuf.c ****  * @note May not be called on a packet queue.
 801:../lwip-1.4.1/src/core/pbuf.c ****  */
 802:../lwip-1.4.1/src/core/pbuf.c **** struct pbuf *
 803:../lwip-1.4.1/src/core/pbuf.c **** pbuf_dechain(struct pbuf *p)
 804:../lwip-1.4.1/src/core/pbuf.c **** {
 1313              		.loc 1 804 0
 1314              		.cfi_startproc
 1315              		@ args = 0, pretend = 0, frame = 16
 1316              		@ frame_needed = 1, uses_anonymous_args = 0
 1317 0000 80B5     		push	{r7, lr}
 1318              		.cfi_def_cfa_offset 8
 1319              		.cfi_offset 7, -8
 1320              		.cfi_offset 14, -4
 1321 0002 84B0     		sub	sp, sp, #16
 1322              		.cfi_def_cfa_offset 24
 1323 0004 00AF     		add	r7, sp, #0
 1324              		.cfi_def_cfa_register 7
 1325 0006 7860     		str	r0, [r7, #4]
 805:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *q;
 806:../lwip-1.4.1/src/core/pbuf.c ****   u8_t tail_gone = 1;
 1326              		.loc 1 806 0
 1327 0008 0123     		movs	r3, #1
 1328 000a FB73     		strb	r3, [r7, #15]
 807:../lwip-1.4.1/src/core/pbuf.c ****   /* tail */
 808:../lwip-1.4.1/src/core/pbuf.c ****   q = p->next;
 1329              		.loc 1 808 0
 1330 000c 7B68     		ldr	r3, [r7, #4]
 1331 000e 1B68     		ldr	r3, [r3]
 1332 0010 BB60     		str	r3, [r7, #8]
 809:../lwip-1.4.1/src/core/pbuf.c ****   /* pbuf has successor in chain? */
 810:../lwip-1.4.1/src/core/pbuf.c ****   if (q != NULL) {
 1333              		.loc 1 810 0
 1334 0012 BB68     		ldr	r3, [r7, #8]
 1335 0014 002B     		cmp	r3, #0
 1336 0016 13D0     		beq	.L91
 811:../lwip-1.4.1/src/core/pbuf.c ****     /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
 812:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
 813:../lwip-1.4.1/src/core/pbuf.c ****     /* enforce invariant if assertion is disabled */
 814:../lwip-1.4.1/src/core/pbuf.c ****     q->tot_len = p->tot_len - p->len;
 1337              		.loc 1 814 0
 1338 0018 7B68     		ldr	r3, [r7, #4]
 1339 001a 1A89     		ldrh	r2, [r3, #8]
 1340 001c 7B68     		ldr	r3, [r7, #4]
 1341 001e 5B89     		ldrh	r3, [r3, #10]
 1342 0020 D31A     		subs	r3, r2, r3
 1343 0022 9AB2     		uxth	r2, r3
 1344 0024 BB68     		ldr	r3, [r7, #8]
 1345 0026 1A81     		strh	r2, [r3, #8]	@ movhi
 815:../lwip-1.4.1/src/core/pbuf.c ****     /* decouple pbuf from remainder */
 816:../lwip-1.4.1/src/core/pbuf.c ****     p->next = NULL;
 1346              		.loc 1 816 0
 1347 0028 7B68     		ldr	r3, [r7, #4]
 1348 002a 0022     		movs	r2, #0
 1349 002c 1A60     		str	r2, [r3]
 817:../lwip-1.4.1/src/core/pbuf.c ****     /* total length of pbuf p is its own length only */
 818:../lwip-1.4.1/src/core/pbuf.c ****     p->tot_len = p->len;
 1350              		.loc 1 818 0
 1351 002e 7B68     		ldr	r3, [r7, #4]
 1352 0030 5A89     		ldrh	r2, [r3, #10]
 1353 0032 7B68     		ldr	r3, [r7, #4]
 1354 0034 1A81     		strh	r2, [r3, #8]	@ movhi
 819:../lwip-1.4.1/src/core/pbuf.c ****     /* q is no longer referenced by p, free it */
 820:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
 821:../lwip-1.4.1/src/core/pbuf.c ****     tail_gone = pbuf_free(q);
 1355              		.loc 1 821 0
 1356 0036 B868     		ldr	r0, [r7, #8]
 1357 0038 FFF7FEFF 		bl	pbuf_free
 1358 003c 0346     		mov	r3, r0
 1359 003e FB73     		strb	r3, [r7, #15]
 1360              	.L91:
 822:../lwip-1.4.1/src/core/pbuf.c ****     if (tail_gone > 0) {
 823:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
 824:../lwip-1.4.1/src/core/pbuf.c ****                   ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
 825:../lwip-1.4.1/src/core/pbuf.c ****     }
 826:../lwip-1.4.1/src/core/pbuf.c ****     /* return remaining tail or NULL if deallocated */
 827:../lwip-1.4.1/src/core/pbuf.c ****   }
 828:../lwip-1.4.1/src/core/pbuf.c ****   /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
 829:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 830:../lwip-1.4.1/src/core/pbuf.c ****   return ((tail_gone > 0) ? NULL : q);
 1361              		.loc 1 830 0
 1362 0040 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1363 0042 002B     		cmp	r3, #0
 1364 0044 01D1     		bne	.L92
 1365              		.loc 1 830 0 is_stmt 0 discriminator 1
 1366 0046 BB68     		ldr	r3, [r7, #8]
 1367 0048 00E0     		b	.L93
 1368              	.L92:
 1369              		.loc 1 830 0 discriminator 2
 1370 004a 0023     		movs	r3, #0
 1371              	.L93:
 831:../lwip-1.4.1/src/core/pbuf.c **** }
 1372              		.loc 1 831 0 is_stmt 1 discriminator 4
 1373 004c 1846     		mov	r0, r3
 1374 004e 1037     		adds	r7, r7, #16
 1375              		.cfi_def_cfa_offset 8
 1376 0050 BD46     		mov	sp, r7
 1377              		.cfi_def_cfa_register 13
 1378              		@ sp needed
 1379 0052 80BD     		pop	{r7, pc}
 1380              		.cfi_endproc
 1381              	.LFE11:
 1383              		.section	.text.pbuf_copy,"ax",%progbits
 1384              		.align	2
 1385              		.global	pbuf_copy
 1386              		.thumb
 1387              		.thumb_func
 1389              	pbuf_copy:
 1390              	.LFB12:
 832:../lwip-1.4.1/src/core/pbuf.c **** 
 833:../lwip-1.4.1/src/core/pbuf.c **** /**
 834:../lwip-1.4.1/src/core/pbuf.c ****  *
 835:../lwip-1.4.1/src/core/pbuf.c ****  * Create PBUF_RAM copies of pbufs.
 836:../lwip-1.4.1/src/core/pbuf.c ****  *
 837:../lwip-1.4.1/src/core/pbuf.c ****  * Used to queue packets on behalf of the lwIP stack, such as
 838:../lwip-1.4.1/src/core/pbuf.c ****  * ARP based queueing.
 839:../lwip-1.4.1/src/core/pbuf.c ****  *
 840:../lwip-1.4.1/src/core/pbuf.c ****  * @note You MUST explicitly use p = pbuf_take(p);
 841:../lwip-1.4.1/src/core/pbuf.c ****  *
 842:../lwip-1.4.1/src/core/pbuf.c ****  * @note Only one packet is copied, no packet queue!
 843:../lwip-1.4.1/src/core/pbuf.c ****  *
 844:../lwip-1.4.1/src/core/pbuf.c ****  * @param p_to pbuf destination of the copy
 845:../lwip-1.4.1/src/core/pbuf.c ****  * @param p_from pbuf source of the copy
 846:../lwip-1.4.1/src/core/pbuf.c ****  *
 847:../lwip-1.4.1/src/core/pbuf.c ****  * @return ERR_OK if pbuf was copied
 848:../lwip-1.4.1/src/core/pbuf.c ****  *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 849:../lwip-1.4.1/src/core/pbuf.c ****  *                 enough to hold p_from
 850:../lwip-1.4.1/src/core/pbuf.c ****  */
 851:../lwip-1.4.1/src/core/pbuf.c **** err_t
 852:../lwip-1.4.1/src/core/pbuf.c **** pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
 853:../lwip-1.4.1/src/core/pbuf.c **** {
 1391              		.loc 1 853 0
 1392              		.cfi_startproc
 1393              		@ args = 0, pretend = 0, frame = 16
 1394              		@ frame_needed = 1, uses_anonymous_args = 0
 1395 0000 80B5     		push	{r7, lr}
 1396              		.cfi_def_cfa_offset 8
 1397              		.cfi_offset 7, -8
 1398              		.cfi_offset 14, -4
 1399 0002 84B0     		sub	sp, sp, #16
 1400              		.cfi_def_cfa_offset 24
 1401 0004 00AF     		add	r7, sp, #0
 1402              		.cfi_def_cfa_register 7
 1403 0006 7860     		str	r0, [r7, #4]
 1404 0008 3960     		str	r1, [r7]
 854:../lwip-1.4.1/src/core/pbuf.c ****   u16_t offset_to=0, offset_from=0, len;
 1405              		.loc 1 854 0
 1406 000a 0023     		movs	r3, #0
 1407 000c FB81     		strh	r3, [r7, #14]	@ movhi
 1408 000e 0023     		movs	r3, #0
 1409 0010 BB81     		strh	r3, [r7, #12]	@ movhi
 855:../lwip-1.4.1/src/core/pbuf.c **** 
 856:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
 857:../lwip-1.4.1/src/core/pbuf.c ****     (void*)p_to, (void*)p_from));
 858:../lwip-1.4.1/src/core/pbuf.c **** 
 859:../lwip-1.4.1/src/core/pbuf.c ****   /* is the target big enough to hold the source? */
 860:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 1410              		.loc 1 860 0
 1411 0012 7B68     		ldr	r3, [r7, #4]
 1412 0014 002B     		cmp	r3, #0
 1413 0016 08D0     		beq	.L96
 1414              		.loc 1 860 0 is_stmt 0 discriminator 2
 1415 0018 3B68     		ldr	r3, [r7]
 1416 001a 002B     		cmp	r3, #0
 1417 001c 05D0     		beq	.L96
 1418              		.loc 1 860 0 discriminator 4
 1419 001e 7B68     		ldr	r3, [r7, #4]
 1420 0020 1A89     		ldrh	r2, [r3, #8]
 1421 0022 3B68     		ldr	r3, [r7]
 1422 0024 1B89     		ldrh	r3, [r3, #8]
 1423 0026 9A42     		cmp	r2, r3
 1424 0028 01D2     		bcs	.L97
 1425              	.L96:
 1426              		.loc 1 860 0 discriminator 5
 1427 002a F223     		movs	r3, #242
 1428 002c 6AE0     		b	.L98
 1429              	.L97:
 861:../lwip-1.4.1/src/core/pbuf.c ****              (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
 862:../lwip-1.4.1/src/core/pbuf.c **** 
 863:../lwip-1.4.1/src/core/pbuf.c ****   /* iterate through pbuf chain */
 864:../lwip-1.4.1/src/core/pbuf.c ****   do
 865:../lwip-1.4.1/src/core/pbuf.c ****   {
 866:../lwip-1.4.1/src/core/pbuf.c ****     /* copy one part of the original chain */
 867:../lwip-1.4.1/src/core/pbuf.c ****     if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 1430              		.loc 1 867 0 is_stmt 1
 1431 002e 7B68     		ldr	r3, [r7, #4]
 1432 0030 5B89     		ldrh	r3, [r3, #10]
 1433 0032 1A46     		mov	r2, r3
 1434 0034 FB89     		ldrh	r3, [r7, #14]
 1435 0036 D21A     		subs	r2, r2, r3
 1436 0038 3B68     		ldr	r3, [r7]
 1437 003a 5B89     		ldrh	r3, [r3, #10]
 1438 003c 1946     		mov	r1, r3
 1439 003e BB89     		ldrh	r3, [r7, #12]
 1440 0040 CB1A     		subs	r3, r1, r3
 1441 0042 9A42     		cmp	r2, r3
 1442 0044 05DB     		blt	.L99
 868:../lwip-1.4.1/src/core/pbuf.c ****       /* complete current p_from fits into current p_to */
 869:../lwip-1.4.1/src/core/pbuf.c ****       len = p_from->len - offset_from;
 1443              		.loc 1 869 0
 1444 0046 3B68     		ldr	r3, [r7]
 1445 0048 5A89     		ldrh	r2, [r3, #10]
 1446 004a BB89     		ldrh	r3, [r7, #12]	@ movhi
 1447 004c D31A     		subs	r3, r2, r3
 1448 004e 7B81     		strh	r3, [r7, #10]	@ movhi
 1449 0050 04E0     		b	.L100
 1450              	.L99:
 870:../lwip-1.4.1/src/core/pbuf.c ****     } else {
 871:../lwip-1.4.1/src/core/pbuf.c ****       /* current p_from does not fit into current p_to */
 872:../lwip-1.4.1/src/core/pbuf.c ****       len = p_to->len - offset_to;
 1451              		.loc 1 872 0
 1452 0052 7B68     		ldr	r3, [r7, #4]
 1453 0054 5A89     		ldrh	r2, [r3, #10]
 1454 0056 FB89     		ldrh	r3, [r7, #14]	@ movhi
 1455 0058 D31A     		subs	r3, r2, r3
 1456 005a 7B81     		strh	r3, [r7, #10]	@ movhi
 1457              	.L100:
 873:../lwip-1.4.1/src/core/pbuf.c ****     }
 874:../lwip-1.4.1/src/core/pbuf.c ****     MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 1458              		.loc 1 874 0
 1459 005c 7B68     		ldr	r3, [r7, #4]
 1460 005e 5A68     		ldr	r2, [r3, #4]
 1461 0060 FB89     		ldrh	r3, [r7, #14]
 1462 0062 D118     		adds	r1, r2, r3
 1463 0064 3B68     		ldr	r3, [r7]
 1464 0066 5A68     		ldr	r2, [r3, #4]
 1465 0068 BB89     		ldrh	r3, [r7, #12]
 1466 006a 1A44     		add	r2, r2, r3
 1467 006c 7B89     		ldrh	r3, [r7, #10]
 1468 006e 0846     		mov	r0, r1
 1469 0070 1146     		mov	r1, r2
 1470 0072 1A46     		mov	r2, r3
 1471 0074 FFF7FEFF 		bl	memcpy
 875:../lwip-1.4.1/src/core/pbuf.c ****     offset_to += len;
 1472              		.loc 1 875 0
 1473 0078 FA89     		ldrh	r2, [r7, #14]	@ movhi
 1474 007a 7B89     		ldrh	r3, [r7, #10]	@ movhi
 1475 007c 1344     		add	r3, r3, r2
 1476 007e FB81     		strh	r3, [r7, #14]	@ movhi
 876:../lwip-1.4.1/src/core/pbuf.c ****     offset_from += len;
 1477              		.loc 1 876 0
 1478 0080 BA89     		ldrh	r2, [r7, #12]	@ movhi
 1479 0082 7B89     		ldrh	r3, [r7, #10]	@ movhi
 1480 0084 1344     		add	r3, r3, r2
 1481 0086 BB81     		strh	r3, [r7, #12]	@ movhi
 877:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 878:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 879:../lwip-1.4.1/src/core/pbuf.c ****     if (offset_from >= p_from->len) {
 1482              		.loc 1 879 0
 1483 0088 3B68     		ldr	r3, [r7]
 1484 008a 5B89     		ldrh	r3, [r3, #10]
 1485 008c BA89     		ldrh	r2, [r7, #12]
 1486 008e 9A42     		cmp	r2, r3
 1487 0090 04D3     		bcc	.L101
 880:../lwip-1.4.1/src/core/pbuf.c ****       /* on to next p_from (if any) */
 881:../lwip-1.4.1/src/core/pbuf.c ****       offset_from = 0;
 1488              		.loc 1 881 0
 1489 0092 0023     		movs	r3, #0
 1490 0094 BB81     		strh	r3, [r7, #12]	@ movhi
 882:../lwip-1.4.1/src/core/pbuf.c ****       p_from = p_from->next;
 1491              		.loc 1 882 0
 1492 0096 3B68     		ldr	r3, [r7]
 1493 0098 1B68     		ldr	r3, [r3]
 1494 009a 3B60     		str	r3, [r7]
 1495              	.L101:
 883:../lwip-1.4.1/src/core/pbuf.c ****     }
 884:../lwip-1.4.1/src/core/pbuf.c ****     if (offset_to == p_to->len) {
 1496              		.loc 1 884 0
 1497 009c 7B68     		ldr	r3, [r7, #4]
 1498 009e 5B89     		ldrh	r3, [r3, #10]
 1499 00a0 FA89     		ldrh	r2, [r7, #14]
 1500 00a2 9A42     		cmp	r2, r3
 1501 00a4 0CD1     		bne	.L102
 885:../lwip-1.4.1/src/core/pbuf.c ****       /* on to next p_to (if any) */
 886:../lwip-1.4.1/src/core/pbuf.c ****       offset_to = 0;
 1502              		.loc 1 886 0
 1503 00a6 0023     		movs	r3, #0
 1504 00a8 FB81     		strh	r3, [r7, #14]	@ movhi
 887:../lwip-1.4.1/src/core/pbuf.c ****       p_to = p_to->next;
 1505              		.loc 1 887 0
 1506 00aa 7B68     		ldr	r3, [r7, #4]
 1507 00ac 1B68     		ldr	r3, [r3]
 1508 00ae 7B60     		str	r3, [r7, #4]
 888:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 1509              		.loc 1 888 0
 1510 00b0 7B68     		ldr	r3, [r7, #4]
 1511 00b2 002B     		cmp	r3, #0
 1512 00b4 04D1     		bne	.L102
 1513              		.loc 1 888 0 is_stmt 0 discriminator 1
 1514 00b6 3B68     		ldr	r3, [r7]
 1515 00b8 002B     		cmp	r3, #0
 1516 00ba 01D0     		beq	.L102
 1517              		.loc 1 888 0 discriminator 2
 1518 00bc F223     		movs	r3, #242
 1519 00be 21E0     		b	.L98
 1520              	.L102:
 889:../lwip-1.4.1/src/core/pbuf.c ****     }
 890:../lwip-1.4.1/src/core/pbuf.c **** 
 891:../lwip-1.4.1/src/core/pbuf.c ****     if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 1521              		.loc 1 891 0 is_stmt 1
 1522 00c0 3B68     		ldr	r3, [r7]
 1523 00c2 002B     		cmp	r3, #0
 1524 00c4 0BD0     		beq	.L103
 1525              		.loc 1 891 0 is_stmt 0 discriminator 1
 1526 00c6 3B68     		ldr	r3, [r7]
 1527 00c8 5A89     		ldrh	r2, [r3, #10]
 1528 00ca 3B68     		ldr	r3, [r7]
 1529 00cc 1B89     		ldrh	r3, [r3, #8]
 1530 00ce 9A42     		cmp	r2, r3
 1531 00d0 05D1     		bne	.L103
 892:../lwip-1.4.1/src/core/pbuf.c ****       /* don't copy more than one packet! */
 893:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 1532              		.loc 1 893 0 is_stmt 1
 1533 00d2 3B68     		ldr	r3, [r7]
 1534 00d4 1B68     		ldr	r3, [r3]
 1535 00d6 002B     		cmp	r3, #0
 1536 00d8 01D0     		beq	.L103
 1537              		.loc 1 893 0 is_stmt 0 discriminator 1
 1538 00da FA23     		movs	r3, #250
 1539 00dc 12E0     		b	.L98
 1540              	.L103:
 894:../lwip-1.4.1/src/core/pbuf.c ****                  (p_from->next == NULL), return ERR_VAL;);
 895:../lwip-1.4.1/src/core/pbuf.c ****     }
 896:../lwip-1.4.1/src/core/pbuf.c ****     if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 1541              		.loc 1 896 0 is_stmt 1
 1542 00de 7B68     		ldr	r3, [r7, #4]
 1543 00e0 002B     		cmp	r3, #0
 1544 00e2 0BD0     		beq	.L104
 1545              		.loc 1 896 0 is_stmt 0 discriminator 1
 1546 00e4 7B68     		ldr	r3, [r7, #4]
 1547 00e6 5A89     		ldrh	r2, [r3, #10]
 1548 00e8 7B68     		ldr	r3, [r7, #4]
 1549 00ea 1B89     		ldrh	r3, [r3, #8]
 1550 00ec 9A42     		cmp	r2, r3
 1551 00ee 05D1     		bne	.L104
 897:../lwip-1.4.1/src/core/pbuf.c ****       /* don't copy more than one packet! */
 898:../lwip-1.4.1/src/core/pbuf.c ****       LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 1552              		.loc 1 898 0 is_stmt 1
 1553 00f0 7B68     		ldr	r3, [r7, #4]
 1554 00f2 1B68     		ldr	r3, [r3]
 1555 00f4 002B     		cmp	r3, #0
 1556 00f6 01D0     		beq	.L104
 1557              		.loc 1 898 0 is_stmt 0 discriminator 1
 1558 00f8 FA23     		movs	r3, #250
 1559 00fa 03E0     		b	.L98
 1560              	.L104:
 899:../lwip-1.4.1/src/core/pbuf.c ****                   (p_to->next == NULL), return ERR_VAL;);
 900:../lwip-1.4.1/src/core/pbuf.c ****     }
 901:../lwip-1.4.1/src/core/pbuf.c ****   } while (p_from);
 1561              		.loc 1 901 0 is_stmt 1
 1562 00fc 3B68     		ldr	r3, [r7]
 1563 00fe 002B     		cmp	r3, #0
 1564 0100 95D1     		bne	.L97
 902:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
 903:../lwip-1.4.1/src/core/pbuf.c ****   return ERR_OK;
 1565              		.loc 1 903 0
 1566 0102 0023     		movs	r3, #0
 1567              	.L98:
 1568 0104 5BB2     		sxtb	r3, r3
 904:../lwip-1.4.1/src/core/pbuf.c **** }
 1569              		.loc 1 904 0
 1570 0106 1846     		mov	r0, r3
 1571 0108 1037     		adds	r7, r7, #16
 1572              		.cfi_def_cfa_offset 8
 1573 010a BD46     		mov	sp, r7
 1574              		.cfi_def_cfa_register 13
 1575              		@ sp needed
 1576 010c 80BD     		pop	{r7, pc}
 1577              		.cfi_endproc
 1578              	.LFE12:
 1580 010e 00BF     		.section	.text.pbuf_copy_partial,"ax",%progbits
 1581              		.align	2
 1582              		.global	pbuf_copy_partial
 1583              		.thumb
 1584              		.thumb_func
 1586              	pbuf_copy_partial:
 1587              	.LFB13:
 905:../lwip-1.4.1/src/core/pbuf.c **** 
 906:../lwip-1.4.1/src/core/pbuf.c **** /**
 907:../lwip-1.4.1/src/core/pbuf.c ****  * Copy (part of) the contents of a packet buffer
 908:../lwip-1.4.1/src/core/pbuf.c ****  * to an application supplied buffer.
 909:../lwip-1.4.1/src/core/pbuf.c ****  *
 910:../lwip-1.4.1/src/core/pbuf.c ****  * @param buf the pbuf from which to copy data
 911:../lwip-1.4.1/src/core/pbuf.c ****  * @param dataptr the application supplied buffer
 912:../lwip-1.4.1/src/core/pbuf.c ****  * @param len length of data to copy (dataptr must be big enough). No more 
 913:../lwip-1.4.1/src/core/pbuf.c ****  * than buf->tot_len will be copied, irrespective of len
 914:../lwip-1.4.1/src/core/pbuf.c ****  * @param offset offset into the packet buffer from where to begin copying len bytes
 915:../lwip-1.4.1/src/core/pbuf.c ****  * @return the number of bytes copied, or 0 on failure
 916:../lwip-1.4.1/src/core/pbuf.c ****  */
 917:../lwip-1.4.1/src/core/pbuf.c **** u16_t
 918:../lwip-1.4.1/src/core/pbuf.c **** pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
 919:../lwip-1.4.1/src/core/pbuf.c **** {
 1588              		.loc 1 919 0
 1589              		.cfi_startproc
 1590              		@ args = 0, pretend = 0, frame = 32
 1591              		@ frame_needed = 1, uses_anonymous_args = 0
 1592 0000 80B5     		push	{r7, lr}
 1593              		.cfi_def_cfa_offset 8
 1594              		.cfi_offset 7, -8
 1595              		.cfi_offset 14, -4
 1596 0002 88B0     		sub	sp, sp, #32
 1597              		.cfi_def_cfa_offset 40
 1598 0004 00AF     		add	r7, sp, #0
 1599              		.cfi_def_cfa_register 7
 1600 0006 F860     		str	r0, [r7, #12]
 1601 0008 B960     		str	r1, [r7, #8]
 1602 000a 1146     		mov	r1, r2
 1603 000c 1A46     		mov	r2, r3
 1604 000e 0B46     		mov	r3, r1	@ movhi
 1605 0010 FB80     		strh	r3, [r7, #6]	@ movhi
 1606 0012 1346     		mov	r3, r2	@ movhi
 1607 0014 BB80     		strh	r3, [r7, #4]	@ movhi
 920:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *p;
 921:../lwip-1.4.1/src/core/pbuf.c ****   u16_t left;
 922:../lwip-1.4.1/src/core/pbuf.c ****   u16_t buf_copy_len;
 923:../lwip-1.4.1/src/core/pbuf.c ****   u16_t copied_total = 0;
 1608              		.loc 1 923 0
 1609 0016 0023     		movs	r3, #0
 1610 0018 FB82     		strh	r3, [r7, #22]	@ movhi
 924:../lwip-1.4.1/src/core/pbuf.c **** 
 925:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 1611              		.loc 1 925 0
 1612 001a FB68     		ldr	r3, [r7, #12]
 1613 001c 002B     		cmp	r3, #0
 1614 001e 01D1     		bne	.L106
 1615              		.loc 1 925 0 is_stmt 0 discriminator 1
 1616 0020 0023     		movs	r3, #0
 1617 0022 4FE0     		b	.L107
 1618              	.L106:
 926:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 1619              		.loc 1 926 0 is_stmt 1
 1620 0024 BB68     		ldr	r3, [r7, #8]
 1621 0026 002B     		cmp	r3, #0
 1622 0028 01D1     		bne	.L108
 1623              		.loc 1 926 0 is_stmt 0 discriminator 1
 1624 002a 0023     		movs	r3, #0
 1625 002c 4AE0     		b	.L107
 1626              	.L108:
 927:../lwip-1.4.1/src/core/pbuf.c **** 
 928:../lwip-1.4.1/src/core/pbuf.c ****   left = 0;
 1627              		.loc 1 928 0 is_stmt 1
 1628 002e 0023     		movs	r3, #0
 1629 0030 7B83     		strh	r3, [r7, #26]	@ movhi
 929:../lwip-1.4.1/src/core/pbuf.c **** 
 930:../lwip-1.4.1/src/core/pbuf.c ****   if((buf == NULL) || (dataptr == NULL)) {
 1630              		.loc 1 930 0
 1631 0032 FB68     		ldr	r3, [r7, #12]
 1632 0034 002B     		cmp	r3, #0
 1633 0036 02D0     		beq	.L109
 1634              		.loc 1 930 0 is_stmt 0 discriminator 1
 1635 0038 BB68     		ldr	r3, [r7, #8]
 1636 003a 002B     		cmp	r3, #0
 1637 003c 01D1     		bne	.L110
 1638              	.L109:
 931:../lwip-1.4.1/src/core/pbuf.c ****     return 0;
 1639              		.loc 1 931 0 is_stmt 1
 1640 003e 0023     		movs	r3, #0
 1641 0040 40E0     		b	.L107
 1642              	.L110:
 932:../lwip-1.4.1/src/core/pbuf.c ****   }
 933:../lwip-1.4.1/src/core/pbuf.c **** 
 934:../lwip-1.4.1/src/core/pbuf.c ****   /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. 
 935:../lwip-1.4.1/src/core/pbuf.c ****   for(p = buf; len != 0 && p != NULL; p = p->next) {
 1643              		.loc 1 935 0
 1644 0042 FB68     		ldr	r3, [r7, #12]
 1645 0044 FB61     		str	r3, [r7, #28]
 1646 0046 36E0     		b	.L111
 1647              	.L116:
 936:../lwip-1.4.1/src/core/pbuf.c ****     if ((offset != 0) && (offset >= p->len)) {
 1648              		.loc 1 936 0
 1649 0048 BB88     		ldrh	r3, [r7, #4]
 1650 004a 002B     		cmp	r3, #0
 1651 004c 0AD0     		beq	.L112
 1652              		.loc 1 936 0 is_stmt 0 discriminator 1
 1653 004e FB69     		ldr	r3, [r7, #28]
 1654 0050 5B89     		ldrh	r3, [r3, #10]
 1655 0052 BA88     		ldrh	r2, [r7, #4]
 1656 0054 9A42     		cmp	r2, r3
 1657 0056 05D3     		bcc	.L112
 937:../lwip-1.4.1/src/core/pbuf.c ****       /* don't copy from this buffer -> on to the next */
 938:../lwip-1.4.1/src/core/pbuf.c ****       offset -= p->len;
 1658              		.loc 1 938 0 is_stmt 1
 1659 0058 FB69     		ldr	r3, [r7, #28]
 1660 005a 5B89     		ldrh	r3, [r3, #10]
 1661 005c BA88     		ldrh	r2, [r7, #4]	@ movhi
 1662 005e D31A     		subs	r3, r2, r3
 1663 0060 BB80     		strh	r3, [r7, #4]	@ movhi
 1664 0062 25E0     		b	.L113
 1665              	.L112:
 939:../lwip-1.4.1/src/core/pbuf.c ****     } else {
 940:../lwip-1.4.1/src/core/pbuf.c ****       /* copy from this buffer. maybe only partially. */
 941:../lwip-1.4.1/src/core/pbuf.c ****       buf_copy_len = p->len - offset;
 1666              		.loc 1 941 0
 1667 0064 FB69     		ldr	r3, [r7, #28]
 1668 0066 5A89     		ldrh	r2, [r3, #10]
 1669 0068 BB88     		ldrh	r3, [r7, #4]	@ movhi
 1670 006a D31A     		subs	r3, r2, r3
 1671 006c 3B83     		strh	r3, [r7, #24]	@ movhi
 942:../lwip-1.4.1/src/core/pbuf.c ****       if (buf_copy_len > len)
 1672              		.loc 1 942 0
 1673 006e 3A8B     		ldrh	r2, [r7, #24]
 1674 0070 FB88     		ldrh	r3, [r7, #6]
 1675 0072 9A42     		cmp	r2, r3
 1676 0074 01D9     		bls	.L114
 943:../lwip-1.4.1/src/core/pbuf.c ****           buf_copy_len = len;
 1677              		.loc 1 943 0
 1678 0076 FB88     		ldrh	r3, [r7, #6]	@ movhi
 1679 0078 3B83     		strh	r3, [r7, #24]	@ movhi
 1680              	.L114:
 944:../lwip-1.4.1/src/core/pbuf.c ****       /* copy the necessary parts of the buffer */
 945:../lwip-1.4.1/src/core/pbuf.c ****       MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 1681              		.loc 1 945 0
 1682 007a 7B8B     		ldrh	r3, [r7, #26]
 1683 007c BA68     		ldr	r2, [r7, #8]
 1684 007e D118     		adds	r1, r2, r3
 1685 0080 FB69     		ldr	r3, [r7, #28]
 1686 0082 5A68     		ldr	r2, [r3, #4]
 1687 0084 BB88     		ldrh	r3, [r7, #4]
 1688 0086 1A44     		add	r2, r2, r3
 1689 0088 3B8B     		ldrh	r3, [r7, #24]
 1690 008a 0846     		mov	r0, r1
 1691 008c 1146     		mov	r1, r2
 1692 008e 1A46     		mov	r2, r3
 1693 0090 FFF7FEFF 		bl	memcpy
 946:../lwip-1.4.1/src/core/pbuf.c ****       copied_total += buf_copy_len;
 1694              		.loc 1 946 0
 1695 0094 FA8A     		ldrh	r2, [r7, #22]	@ movhi
 1696 0096 3B8B     		ldrh	r3, [r7, #24]	@ movhi
 1697 0098 1344     		add	r3, r3, r2
 1698 009a FB82     		strh	r3, [r7, #22]	@ movhi
 947:../lwip-1.4.1/src/core/pbuf.c ****       left += buf_copy_len;
 1699              		.loc 1 947 0
 1700 009c 7A8B     		ldrh	r2, [r7, #26]	@ movhi
 1701 009e 3B8B     		ldrh	r3, [r7, #24]	@ movhi
 1702 00a0 1344     		add	r3, r3, r2
 1703 00a2 7B83     		strh	r3, [r7, #26]	@ movhi
 948:../lwip-1.4.1/src/core/pbuf.c ****       len -= buf_copy_len;
 1704              		.loc 1 948 0
 1705 00a4 FA88     		ldrh	r2, [r7, #6]	@ movhi
 1706 00a6 3B8B     		ldrh	r3, [r7, #24]	@ movhi
 1707 00a8 D31A     		subs	r3, r2, r3
 1708 00aa FB80     		strh	r3, [r7, #6]	@ movhi
 949:../lwip-1.4.1/src/core/pbuf.c ****       offset = 0;
 1709              		.loc 1 949 0
 1710 00ac 0023     		movs	r3, #0
 1711 00ae BB80     		strh	r3, [r7, #4]	@ movhi
 1712              	.L113:
 935:../lwip-1.4.1/src/core/pbuf.c ****     if ((offset != 0) && (offset >= p->len)) {
 1713              		.loc 1 935 0 discriminator 2
 1714 00b0 FB69     		ldr	r3, [r7, #28]
 1715 00b2 1B68     		ldr	r3, [r3]
 1716 00b4 FB61     		str	r3, [r7, #28]
 1717              	.L111:
 935:../lwip-1.4.1/src/core/pbuf.c ****     if ((offset != 0) && (offset >= p->len)) {
 1718              		.loc 1 935 0 is_stmt 0 discriminator 1
 1719 00b6 FB88     		ldrh	r3, [r7, #6]
 1720 00b8 002B     		cmp	r3, #0
 1721 00ba 02D0     		beq	.L115
 935:../lwip-1.4.1/src/core/pbuf.c ****     if ((offset != 0) && (offset >= p->len)) {
 1722              		.loc 1 935 0 discriminator 3
 1723 00bc FB69     		ldr	r3, [r7, #28]
 1724 00be 002B     		cmp	r3, #0
 1725 00c0 C2D1     		bne	.L116
 1726              	.L115:
 950:../lwip-1.4.1/src/core/pbuf.c ****     }
 951:../lwip-1.4.1/src/core/pbuf.c ****   }
 952:../lwip-1.4.1/src/core/pbuf.c ****   return copied_total;
 1727              		.loc 1 952 0 is_stmt 1
 1728 00c2 FB8A     		ldrh	r3, [r7, #22]
 1729              	.L107:
 953:../lwip-1.4.1/src/core/pbuf.c **** }
 1730              		.loc 1 953 0
 1731 00c4 1846     		mov	r0, r3
 1732 00c6 2037     		adds	r7, r7, #32
 1733              		.cfi_def_cfa_offset 8
 1734 00c8 BD46     		mov	sp, r7
 1735              		.cfi_def_cfa_register 13
 1736              		@ sp needed
 1737 00ca 80BD     		pop	{r7, pc}
 1738              		.cfi_endproc
 1739              	.LFE13:
 1741              		.section	.text.pbuf_take,"ax",%progbits
 1742              		.align	2
 1743              		.global	pbuf_take
 1744              		.thumb
 1745              		.thumb_func
 1747              	pbuf_take:
 1748              	.LFB14:
 954:../lwip-1.4.1/src/core/pbuf.c **** 
 955:../lwip-1.4.1/src/core/pbuf.c **** /**
 956:../lwip-1.4.1/src/core/pbuf.c ****  * Copy application supplied data into a pbuf.
 957:../lwip-1.4.1/src/core/pbuf.c ****  * This function can only be used to copy the equivalent of buf->tot_len data.
 958:../lwip-1.4.1/src/core/pbuf.c ****  *
 959:../lwip-1.4.1/src/core/pbuf.c ****  * @param buf pbuf to fill with data
 960:../lwip-1.4.1/src/core/pbuf.c ****  * @param dataptr application supplied data buffer
 961:../lwip-1.4.1/src/core/pbuf.c ****  * @param len length of the application supplied data buffer
 962:../lwip-1.4.1/src/core/pbuf.c ****  *
 963:../lwip-1.4.1/src/core/pbuf.c ****  * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 964:../lwip-1.4.1/src/core/pbuf.c ****  */
 965:../lwip-1.4.1/src/core/pbuf.c **** err_t
 966:../lwip-1.4.1/src/core/pbuf.c **** pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
 967:../lwip-1.4.1/src/core/pbuf.c **** {
 1749              		.loc 1 967 0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 32
 1752              		@ frame_needed = 1, uses_anonymous_args = 0
 1753 0000 80B5     		push	{r7, lr}
 1754              		.cfi_def_cfa_offset 8
 1755              		.cfi_offset 7, -8
 1756              		.cfi_offset 14, -4
 1757 0002 88B0     		sub	sp, sp, #32
 1758              		.cfi_def_cfa_offset 40
 1759 0004 00AF     		add	r7, sp, #0
 1760              		.cfi_def_cfa_register 7
 1761 0006 F860     		str	r0, [r7, #12]
 1762 0008 B960     		str	r1, [r7, #8]
 1763 000a 1346     		mov	r3, r2
 1764 000c FB80     		strh	r3, [r7, #6]	@ movhi
 968:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *p;
 969:../lwip-1.4.1/src/core/pbuf.c ****   u16_t buf_copy_len;
 970:../lwip-1.4.1/src/core/pbuf.c ****   u16_t total_copy_len = len;
 1765              		.loc 1 970 0
 1766 000e FB88     		ldrh	r3, [r7, #6]	@ movhi
 1767 0010 3B83     		strh	r3, [r7, #24]	@ movhi
 971:../lwip-1.4.1/src/core/pbuf.c ****   u16_t copied_total = 0;
 1768              		.loc 1 971 0
 1769 0012 0023     		movs	r3, #0
 1770 0014 FB82     		strh	r3, [r7, #22]	@ movhi
 972:../lwip-1.4.1/src/core/pbuf.c **** 
 973:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 1771              		.loc 1 973 0
 1772 0016 FB68     		ldr	r3, [r7, #12]
 1773 0018 002B     		cmp	r3, #0
 1774 001a 01D1     		bne	.L118
 1775              		.loc 1 973 0 is_stmt 0 discriminator 1
 1776 001c 0023     		movs	r3, #0
 1777 001e 38E0     		b	.L119
 1778              	.L118:
 974:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 1779              		.loc 1 974 0 is_stmt 1
 1780 0020 BB68     		ldr	r3, [r7, #8]
 1781 0022 002B     		cmp	r3, #0
 1782 0024 01D1     		bne	.L120
 1783              		.loc 1 974 0 is_stmt 0 discriminator 1
 1784 0026 0023     		movs	r3, #0
 1785 0028 33E0     		b	.L119
 1786              	.L120:
 975:../lwip-1.4.1/src/core/pbuf.c **** 
 976:../lwip-1.4.1/src/core/pbuf.c ****   if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 1787              		.loc 1 976 0 is_stmt 1
 1788 002a FB68     		ldr	r3, [r7, #12]
 1789 002c 002B     		cmp	r3, #0
 1790 002e 07D0     		beq	.L121
 1791              		.loc 1 976 0 is_stmt 0 discriminator 1
 1792 0030 BB68     		ldr	r3, [r7, #8]
 1793 0032 002B     		cmp	r3, #0
 1794 0034 04D0     		beq	.L121
 1795              		.loc 1 976 0 discriminator 2
 1796 0036 FB68     		ldr	r3, [r7, #12]
 1797 0038 1B89     		ldrh	r3, [r3, #8]
 1798 003a FA88     		ldrh	r2, [r7, #6]
 1799 003c 9A42     		cmp	r2, r3
 1800 003e 01D9     		bls	.L122
 1801              	.L121:
 977:../lwip-1.4.1/src/core/pbuf.c ****     return ERR_ARG;
 1802              		.loc 1 977 0 is_stmt 1
 1803 0040 F223     		movs	r3, #242
 1804 0042 26E0     		b	.L119
 1805              	.L122:
 978:../lwip-1.4.1/src/core/pbuf.c ****   }
 979:../lwip-1.4.1/src/core/pbuf.c **** 
 980:../lwip-1.4.1/src/core/pbuf.c ****   /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. 
 981:../lwip-1.4.1/src/core/pbuf.c ****   for(p = buf; total_copy_len != 0; p = p->next) {
 1806              		.loc 1 981 0
 1807 0044 FB68     		ldr	r3, [r7, #12]
 1808 0046 FB61     		str	r3, [r7, #28]
 1809 0048 1FE0     		b	.L123
 1810              	.L125:
 982:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 983:../lwip-1.4.1/src/core/pbuf.c ****     buf_copy_len = total_copy_len;
 1811              		.loc 1 983 0
 1812 004a 3B8B     		ldrh	r3, [r7, #24]	@ movhi
 1813 004c 7B83     		strh	r3, [r7, #26]	@ movhi
 984:../lwip-1.4.1/src/core/pbuf.c ****     if (buf_copy_len > p->len) {
 1814              		.loc 1 984 0
 1815 004e FB69     		ldr	r3, [r7, #28]
 1816 0050 5B89     		ldrh	r3, [r3, #10]
 1817 0052 7A8B     		ldrh	r2, [r7, #26]
 1818 0054 9A42     		cmp	r2, r3
 1819 0056 02D9     		bls	.L124
 985:../lwip-1.4.1/src/core/pbuf.c ****       /* this pbuf cannot hold all remaining data */
 986:../lwip-1.4.1/src/core/pbuf.c ****       buf_copy_len = p->len;
 1820              		.loc 1 986 0
 1821 0058 FB69     		ldr	r3, [r7, #28]
 1822 005a 5B89     		ldrh	r3, [r3, #10]	@ movhi
 1823 005c 7B83     		strh	r3, [r7, #26]	@ movhi
 1824              	.L124:
 987:../lwip-1.4.1/src/core/pbuf.c ****     }
 988:../lwip-1.4.1/src/core/pbuf.c ****     /* copy the necessary parts of the buffer */
 989:../lwip-1.4.1/src/core/pbuf.c ****     MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 1825              		.loc 1 989 0 discriminator 2
 1826 005e FB69     		ldr	r3, [r7, #28]
 1827 0060 5968     		ldr	r1, [r3, #4]
 1828 0062 FB8A     		ldrh	r3, [r7, #22]
 1829 0064 BA68     		ldr	r2, [r7, #8]
 1830 0066 1A44     		add	r2, r2, r3
 1831 0068 7B8B     		ldrh	r3, [r7, #26]
 1832 006a 0846     		mov	r0, r1
 1833 006c 1146     		mov	r1, r2
 1834 006e 1A46     		mov	r2, r3
 1835 0070 FFF7FEFF 		bl	memcpy
 990:../lwip-1.4.1/src/core/pbuf.c ****     total_copy_len -= buf_copy_len;
 1836              		.loc 1 990 0 discriminator 2
 1837 0074 3A8B     		ldrh	r2, [r7, #24]	@ movhi
 1838 0076 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 1839 0078 D31A     		subs	r3, r2, r3
 1840 007a 3B83     		strh	r3, [r7, #24]	@ movhi
 991:../lwip-1.4.1/src/core/pbuf.c ****     copied_total += buf_copy_len;
 1841              		.loc 1 991 0 discriminator 2
 1842 007c FA8A     		ldrh	r2, [r7, #22]	@ movhi
 1843 007e 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 1844 0080 1344     		add	r3, r3, r2
 1845 0082 FB82     		strh	r3, [r7, #22]	@ movhi
 981:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 1846              		.loc 1 981 0 discriminator 2
 1847 0084 FB69     		ldr	r3, [r7, #28]
 1848 0086 1B68     		ldr	r3, [r3]
 1849 0088 FB61     		str	r3, [r7, #28]
 1850              	.L123:
 981:../lwip-1.4.1/src/core/pbuf.c ****     LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 1851              		.loc 1 981 0 is_stmt 0 discriminator 1
 1852 008a 3B8B     		ldrh	r3, [r7, #24]
 1853 008c 002B     		cmp	r3, #0
 1854 008e DCD1     		bne	.L125
 992:../lwip-1.4.1/src/core/pbuf.c ****   }
 993:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 994:../lwip-1.4.1/src/core/pbuf.c ****   return ERR_OK;
 1855              		.loc 1 994 0 is_stmt 1
 1856 0090 0023     		movs	r3, #0
 1857              	.L119:
 1858 0092 5BB2     		sxtb	r3, r3
 995:../lwip-1.4.1/src/core/pbuf.c **** }
 1859              		.loc 1 995 0
 1860 0094 1846     		mov	r0, r3
 1861 0096 2037     		adds	r7, r7, #32
 1862              		.cfi_def_cfa_offset 8
 1863 0098 BD46     		mov	sp, r7
 1864              		.cfi_def_cfa_register 13
 1865              		@ sp needed
 1866 009a 80BD     		pop	{r7, pc}
 1867              		.cfi_endproc
 1868              	.LFE14:
 1870              		.section	.text.pbuf_coalesce,"ax",%progbits
 1871              		.align	2
 1872              		.global	pbuf_coalesce
 1873              		.thumb
 1874              		.thumb_func
 1876              	pbuf_coalesce:
 1877              	.LFB15:
 996:../lwip-1.4.1/src/core/pbuf.c **** 
 997:../lwip-1.4.1/src/core/pbuf.c **** /**
 998:../lwip-1.4.1/src/core/pbuf.c ****  * Creates a single pbuf out of a queue of pbufs.
 999:../lwip-1.4.1/src/core/pbuf.c ****  *
1000:../lwip-1.4.1/src/core/pbuf.c ****  * @remark: Either the source pbuf 'p' is freed by this function or the original
1001:../lwip-1.4.1/src/core/pbuf.c ****  *          pbuf 'p' is returned, therefore the caller has to check the result!
1002:../lwip-1.4.1/src/core/pbuf.c ****  *
1003:../lwip-1.4.1/src/core/pbuf.c ****  * @param p the source pbuf
1004:../lwip-1.4.1/src/core/pbuf.c ****  * @param layer pbuf_layer of the new pbuf
1005:../lwip-1.4.1/src/core/pbuf.c ****  *
1006:../lwip-1.4.1/src/core/pbuf.c ****  * @return a new, single pbuf (p->next is NULL)
1007:../lwip-1.4.1/src/core/pbuf.c ****  *         or the old pbuf if allocation fails
1008:../lwip-1.4.1/src/core/pbuf.c ****  */
1009:../lwip-1.4.1/src/core/pbuf.c **** struct pbuf*
1010:../lwip-1.4.1/src/core/pbuf.c **** pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
1011:../lwip-1.4.1/src/core/pbuf.c **** {
 1878              		.loc 1 1011 0
 1879              		.cfi_startproc
 1880              		@ args = 0, pretend = 0, frame = 16
 1881              		@ frame_needed = 1, uses_anonymous_args = 0
 1882 0000 80B5     		push	{r7, lr}
 1883              		.cfi_def_cfa_offset 8
 1884              		.cfi_offset 7, -8
 1885              		.cfi_offset 14, -4
 1886 0002 84B0     		sub	sp, sp, #16
 1887              		.cfi_def_cfa_offset 24
 1888 0004 00AF     		add	r7, sp, #0
 1889              		.cfi_def_cfa_register 7
 1890 0006 7860     		str	r0, [r7, #4]
 1891 0008 0B46     		mov	r3, r1
 1892 000a FB70     		strb	r3, [r7, #3]
1012:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf *q;
1013:../lwip-1.4.1/src/core/pbuf.c ****   err_t err;
1014:../lwip-1.4.1/src/core/pbuf.c ****   if (p->next == NULL) {
 1893              		.loc 1 1014 0
 1894 000c 7B68     		ldr	r3, [r7, #4]
 1895 000e 1B68     		ldr	r3, [r3]
 1896 0010 002B     		cmp	r3, #0
 1897 0012 01D1     		bne	.L127
1015:../lwip-1.4.1/src/core/pbuf.c ****     return p;
 1898              		.loc 1 1015 0
 1899 0014 7B68     		ldr	r3, [r7, #4]
 1900 0016 17E0     		b	.L128
 1901              	.L127:
1016:../lwip-1.4.1/src/core/pbuf.c ****   }
1017:../lwip-1.4.1/src/core/pbuf.c ****   q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
 1902              		.loc 1 1017 0
 1903 0018 7B68     		ldr	r3, [r7, #4]
 1904 001a 1B89     		ldrh	r3, [r3, #8]
 1905 001c FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1906 001e 1046     		mov	r0, r2
 1907 0020 1946     		mov	r1, r3
 1908 0022 0022     		movs	r2, #0
 1909 0024 FFF7FEFF 		bl	pbuf_alloc
 1910 0028 F860     		str	r0, [r7, #12]
1018:../lwip-1.4.1/src/core/pbuf.c ****   if (q == NULL) {
 1911              		.loc 1 1018 0
 1912 002a FB68     		ldr	r3, [r7, #12]
 1913 002c 002B     		cmp	r3, #0
 1914 002e 01D1     		bne	.L129
1019:../lwip-1.4.1/src/core/pbuf.c ****     /* @todo: what do we do now? */
1020:../lwip-1.4.1/src/core/pbuf.c ****     return p;
 1915              		.loc 1 1020 0
 1916 0030 7B68     		ldr	r3, [r7, #4]
 1917 0032 09E0     		b	.L128
 1918              	.L129:
1021:../lwip-1.4.1/src/core/pbuf.c ****   }
1022:../lwip-1.4.1/src/core/pbuf.c ****   err = pbuf_copy(q, p);
 1919              		.loc 1 1022 0
 1920 0034 F868     		ldr	r0, [r7, #12]
 1921 0036 7968     		ldr	r1, [r7, #4]
 1922 0038 FFF7FEFF 		bl	pbuf_copy
 1923 003c 0346     		mov	r3, r0
 1924 003e FB72     		strb	r3, [r7, #11]
1023:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
1024:../lwip-1.4.1/src/core/pbuf.c ****   pbuf_free(p);
 1925              		.loc 1 1024 0
 1926 0040 7868     		ldr	r0, [r7, #4]
 1927 0042 FFF7FEFF 		bl	pbuf_free
1025:../lwip-1.4.1/src/core/pbuf.c ****   return q;
 1928              		.loc 1 1025 0
 1929 0046 FB68     		ldr	r3, [r7, #12]
 1930              	.L128:
1026:../lwip-1.4.1/src/core/pbuf.c **** }
 1931              		.loc 1 1026 0
 1932 0048 1846     		mov	r0, r3
 1933 004a 1037     		adds	r7, r7, #16
 1934              		.cfi_def_cfa_offset 8
 1935 004c BD46     		mov	sp, r7
 1936              		.cfi_def_cfa_register 13
 1937              		@ sp needed
 1938 004e 80BD     		pop	{r7, pc}
 1939              		.cfi_endproc
 1940              	.LFE15:
 1942              		.section	.text.pbuf_get_at,"ax",%progbits
 1943              		.align	2
 1944              		.global	pbuf_get_at
 1945              		.thumb
 1946              		.thumb_func
 1948              	pbuf_get_at:
 1949              	.LFB16:
1027:../lwip-1.4.1/src/core/pbuf.c **** 
1028:../lwip-1.4.1/src/core/pbuf.c **** #if LWIP_CHECKSUM_ON_COPY
1029:../lwip-1.4.1/src/core/pbuf.c **** /**
1030:../lwip-1.4.1/src/core/pbuf.c ****  * Copies data into a single pbuf (*not* into a pbuf queue!) and updates
1031:../lwip-1.4.1/src/core/pbuf.c ****  * the checksum while copying
1032:../lwip-1.4.1/src/core/pbuf.c ****  *
1033:../lwip-1.4.1/src/core/pbuf.c ****  * @param p the pbuf to copy data into
1034:../lwip-1.4.1/src/core/pbuf.c ****  * @param start_offset offset of p->payload where to copy the data to
1035:../lwip-1.4.1/src/core/pbuf.c ****  * @param dataptr data to copy into the pbuf
1036:../lwip-1.4.1/src/core/pbuf.c ****  * @param len length of data to copy into the pbuf
1037:../lwip-1.4.1/src/core/pbuf.c ****  * @param chksum pointer to the checksum which is updated
1038:../lwip-1.4.1/src/core/pbuf.c ****  * @return ERR_OK if successful, another error if the data does not fit
1039:../lwip-1.4.1/src/core/pbuf.c ****  *         within the (first) pbuf (no pbuf queues!)
1040:../lwip-1.4.1/src/core/pbuf.c ****  */
1041:../lwip-1.4.1/src/core/pbuf.c **** err_t
1042:../lwip-1.4.1/src/core/pbuf.c **** pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
1043:../lwip-1.4.1/src/core/pbuf.c ****                  u16_t len, u16_t *chksum)
1044:../lwip-1.4.1/src/core/pbuf.c **** {
1045:../lwip-1.4.1/src/core/pbuf.c ****   u32_t acc;
1046:../lwip-1.4.1/src/core/pbuf.c ****   u16_t copy_chksum;
1047:../lwip-1.4.1/src/core/pbuf.c ****   char *dst_ptr;
1048:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("p != NULL", p != NULL);
1049:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("dataptr != NULL", dataptr != NULL);
1050:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("chksum != NULL", chksum != NULL);
1051:../lwip-1.4.1/src/core/pbuf.c ****   LWIP_ASSERT("len != 0", len != 0);
1052:../lwip-1.4.1/src/core/pbuf.c **** 
1053:../lwip-1.4.1/src/core/pbuf.c ****   if ((start_offset >= p->len) || (start_offset + len > p->len)) {
1054:../lwip-1.4.1/src/core/pbuf.c ****     return ERR_ARG;
1055:../lwip-1.4.1/src/core/pbuf.c ****   }
1056:../lwip-1.4.1/src/core/pbuf.c **** 
1057:../lwip-1.4.1/src/core/pbuf.c ****   dst_ptr = ((char*)p->payload) + start_offset;
1058:../lwip-1.4.1/src/core/pbuf.c ****   copy_chksum = LWIP_CHKSUM_COPY(dst_ptr, dataptr, len);
1059:../lwip-1.4.1/src/core/pbuf.c ****   if ((start_offset & 1) != 0) {
1060:../lwip-1.4.1/src/core/pbuf.c ****     copy_chksum = SWAP_BYTES_IN_WORD(copy_chksum);
1061:../lwip-1.4.1/src/core/pbuf.c ****   }
1062:../lwip-1.4.1/src/core/pbuf.c ****   acc = *chksum;
1063:../lwip-1.4.1/src/core/pbuf.c ****   acc += copy_chksum;
1064:../lwip-1.4.1/src/core/pbuf.c ****   *chksum = FOLD_U32T(acc);
1065:../lwip-1.4.1/src/core/pbuf.c ****   return ERR_OK;
1066:../lwip-1.4.1/src/core/pbuf.c **** }
1067:../lwip-1.4.1/src/core/pbuf.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
1068:../lwip-1.4.1/src/core/pbuf.c **** 
1069:../lwip-1.4.1/src/core/pbuf.c ****  /** Get one byte from the specified position in a pbuf
1070:../lwip-1.4.1/src/core/pbuf.c ****  * WARNING: returns zero for offset >= p->tot_len
1071:../lwip-1.4.1/src/core/pbuf.c ****  *
1072:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to parse
1073:../lwip-1.4.1/src/core/pbuf.c ****  * @param offset offset into p of the byte to return
1074:../lwip-1.4.1/src/core/pbuf.c ****  * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
1075:../lwip-1.4.1/src/core/pbuf.c ****  */
1076:../lwip-1.4.1/src/core/pbuf.c **** u8_t
1077:../lwip-1.4.1/src/core/pbuf.c **** pbuf_get_at(struct pbuf* p, u16_t offset)
1078:../lwip-1.4.1/src/core/pbuf.c **** {
 1950              		.loc 1 1078 0
 1951              		.cfi_startproc
 1952              		@ args = 0, pretend = 0, frame = 16
 1953              		@ frame_needed = 1, uses_anonymous_args = 0
 1954              		@ link register save eliminated.
 1955 0000 80B4     		push	{r7}
 1956              		.cfi_def_cfa_offset 4
 1957              		.cfi_offset 7, -4
 1958 0002 85B0     		sub	sp, sp, #20
 1959              		.cfi_def_cfa_offset 24
 1960 0004 00AF     		add	r7, sp, #0
 1961              		.cfi_def_cfa_register 7
 1962 0006 7860     		str	r0, [r7, #4]
 1963 0008 0B46     		mov	r3, r1
 1964 000a 7B80     		strh	r3, [r7, #2]	@ movhi
1079:../lwip-1.4.1/src/core/pbuf.c ****   u16_t copy_from = offset;
 1965              		.loc 1 1079 0
 1966 000c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1967 000e FB81     		strh	r3, [r7, #14]	@ movhi
1080:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf* q = p;
 1968              		.loc 1 1080 0
 1969 0010 7B68     		ldr	r3, [r7, #4]
 1970 0012 BB60     		str	r3, [r7, #8]
1081:../lwip-1.4.1/src/core/pbuf.c **** 
1082:../lwip-1.4.1/src/core/pbuf.c ****   /* get the correct pbuf */
1083:../lwip-1.4.1/src/core/pbuf.c ****   while ((q != NULL) && (q->len <= copy_from)) {
 1971              		.loc 1 1083 0
 1972 0014 07E0     		b	.L131
 1973              	.L133:
1084:../lwip-1.4.1/src/core/pbuf.c ****     copy_from -= q->len;
 1974              		.loc 1 1084 0
 1975 0016 BB68     		ldr	r3, [r7, #8]
 1976 0018 5B89     		ldrh	r3, [r3, #10]
 1977 001a FA89     		ldrh	r2, [r7, #14]	@ movhi
 1978 001c D31A     		subs	r3, r2, r3
 1979 001e FB81     		strh	r3, [r7, #14]	@ movhi
1085:../lwip-1.4.1/src/core/pbuf.c ****     q = q->next;
 1980              		.loc 1 1085 0
 1981 0020 BB68     		ldr	r3, [r7, #8]
 1982 0022 1B68     		ldr	r3, [r3]
 1983 0024 BB60     		str	r3, [r7, #8]
 1984              	.L131:
1083:../lwip-1.4.1/src/core/pbuf.c ****     copy_from -= q->len;
 1985              		.loc 1 1083 0
 1986 0026 BB68     		ldr	r3, [r7, #8]
 1987 0028 002B     		cmp	r3, #0
 1988 002a 04D0     		beq	.L132
1083:../lwip-1.4.1/src/core/pbuf.c ****     copy_from -= q->len;
 1989              		.loc 1 1083 0 is_stmt 0 discriminator 1
 1990 002c BB68     		ldr	r3, [r7, #8]
 1991 002e 5B89     		ldrh	r3, [r3, #10]
 1992 0030 FA89     		ldrh	r2, [r7, #14]
 1993 0032 9A42     		cmp	r2, r3
 1994 0034 EFD2     		bcs	.L133
 1995              	.L132:
1086:../lwip-1.4.1/src/core/pbuf.c ****   }
1087:../lwip-1.4.1/src/core/pbuf.c ****   /* return requested data if pbuf is OK */
1088:../lwip-1.4.1/src/core/pbuf.c ****   if ((q != NULL) && (q->len > copy_from)) {
 1996              		.loc 1 1088 0 is_stmt 1
 1997 0036 BB68     		ldr	r3, [r7, #8]
 1998 0038 002B     		cmp	r3, #0
 1999 003a 0AD0     		beq	.L134
 2000              		.loc 1 1088 0 is_stmt 0 discriminator 1
 2001 003c BB68     		ldr	r3, [r7, #8]
 2002 003e 5B89     		ldrh	r3, [r3, #10]
 2003 0040 FA89     		ldrh	r2, [r7, #14]
 2004 0042 9A42     		cmp	r2, r3
 2005 0044 05D2     		bcs	.L134
1089:../lwip-1.4.1/src/core/pbuf.c ****     return ((u8_t*)q->payload)[copy_from];
 2006              		.loc 1 1089 0 is_stmt 1
 2007 0046 BB68     		ldr	r3, [r7, #8]
 2008 0048 5A68     		ldr	r2, [r3, #4]
 2009 004a FB89     		ldrh	r3, [r7, #14]
 2010 004c 1344     		add	r3, r3, r2
 2011 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2012 0050 00E0     		b	.L135
 2013              	.L134:
1090:../lwip-1.4.1/src/core/pbuf.c ****   }
1091:../lwip-1.4.1/src/core/pbuf.c ****   return 0;
 2014              		.loc 1 1091 0
 2015 0052 0023     		movs	r3, #0
 2016              	.L135:
1092:../lwip-1.4.1/src/core/pbuf.c **** }
 2017              		.loc 1 1092 0
 2018 0054 1846     		mov	r0, r3
 2019 0056 1437     		adds	r7, r7, #20
 2020              		.cfi_def_cfa_offset 4
 2021 0058 BD46     		mov	sp, r7
 2022              		.cfi_def_cfa_register 13
 2023              		@ sp needed
 2024 005a 5DF8047B 		ldr	r7, [sp], #4
 2025              		.cfi_restore 7
 2026              		.cfi_def_cfa_offset 0
 2027 005e 7047     		bx	lr
 2028              		.cfi_endproc
 2029              	.LFE16:
 2031              		.section	.text.pbuf_memcmp,"ax",%progbits
 2032              		.align	2
 2033              		.global	pbuf_memcmp
 2034              		.thumb
 2035              		.thumb_func
 2037              	pbuf_memcmp:
 2038              	.LFB17:
1093:../lwip-1.4.1/src/core/pbuf.c **** 
1094:../lwip-1.4.1/src/core/pbuf.c **** /** Compare pbuf contents at specified offset with memory s2, both of length n
1095:../lwip-1.4.1/src/core/pbuf.c ****  *
1096:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to compare
1097:../lwip-1.4.1/src/core/pbuf.c ****  * @param offset offset into p at wich to start comparing
1098:../lwip-1.4.1/src/core/pbuf.c ****  * @param s2 buffer to compare
1099:../lwip-1.4.1/src/core/pbuf.c ****  * @param n length of buffer to compare
1100:../lwip-1.4.1/src/core/pbuf.c ****  * @return zero if equal, nonzero otherwise
1101:../lwip-1.4.1/src/core/pbuf.c ****  *         (0xffff if p is too short, diffoffset+1 otherwise)
1102:../lwip-1.4.1/src/core/pbuf.c ****  */
1103:../lwip-1.4.1/src/core/pbuf.c **** u16_t
1104:../lwip-1.4.1/src/core/pbuf.c **** pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
1105:../lwip-1.4.1/src/core/pbuf.c **** {
 2039              		.loc 1 1105 0
 2040              		.cfi_startproc
 2041              		@ args = 0, pretend = 0, frame = 32
 2042              		@ frame_needed = 1, uses_anonymous_args = 0
 2043 0000 80B5     		push	{r7, lr}
 2044              		.cfi_def_cfa_offset 8
 2045              		.cfi_offset 7, -8
 2046              		.cfi_offset 14, -4
 2047 0002 88B0     		sub	sp, sp, #32
 2048              		.cfi_def_cfa_offset 40
 2049 0004 00AF     		add	r7, sp, #0
 2050              		.cfi_def_cfa_register 7
 2051 0006 F860     		str	r0, [r7, #12]
 2052 0008 7A60     		str	r2, [r7, #4]
 2053 000a 1A46     		mov	r2, r3
 2054 000c 0B46     		mov	r3, r1	@ movhi
 2055 000e 7B81     		strh	r3, [r7, #10]	@ movhi
 2056 0010 1346     		mov	r3, r2	@ movhi
 2057 0012 3B81     		strh	r3, [r7, #8]	@ movhi
1106:../lwip-1.4.1/src/core/pbuf.c ****   u16_t start = offset;
 2058              		.loc 1 1106 0
 2059 0014 7B89     		ldrh	r3, [r7, #10]	@ movhi
 2060 0016 FB83     		strh	r3, [r7, #30]	@ movhi
1107:../lwip-1.4.1/src/core/pbuf.c ****   struct pbuf* q = p;
 2061              		.loc 1 1107 0
 2062 0018 FB68     		ldr	r3, [r7, #12]
 2063 001a BB61     		str	r3, [r7, #24]
1108:../lwip-1.4.1/src/core/pbuf.c **** 
1109:../lwip-1.4.1/src/core/pbuf.c ****   /* get the correct pbuf */
1110:../lwip-1.4.1/src/core/pbuf.c ****   while ((q != NULL) && (q->len <= start)) {
 2064              		.loc 1 1110 0
 2065 001c 07E0     		b	.L137
 2066              	.L139:
1111:../lwip-1.4.1/src/core/pbuf.c ****     start -= q->len;
 2067              		.loc 1 1111 0
 2068 001e BB69     		ldr	r3, [r7, #24]
 2069 0020 5B89     		ldrh	r3, [r3, #10]
 2070 0022 FA8B     		ldrh	r2, [r7, #30]	@ movhi
 2071 0024 D31A     		subs	r3, r2, r3
 2072 0026 FB83     		strh	r3, [r7, #30]	@ movhi
1112:../lwip-1.4.1/src/core/pbuf.c ****     q = q->next;
 2073              		.loc 1 1112 0
 2074 0028 BB69     		ldr	r3, [r7, #24]
 2075 002a 1B68     		ldr	r3, [r3]
 2076 002c BB61     		str	r3, [r7, #24]
 2077              	.L137:
1110:../lwip-1.4.1/src/core/pbuf.c ****     start -= q->len;
 2078              		.loc 1 1110 0
 2079 002e BB69     		ldr	r3, [r7, #24]
 2080 0030 002B     		cmp	r3, #0
 2081 0032 04D0     		beq	.L138
1110:../lwip-1.4.1/src/core/pbuf.c ****     start -= q->len;
 2082              		.loc 1 1110 0 is_stmt 0 discriminator 1
 2083 0034 BB69     		ldr	r3, [r7, #24]
 2084 0036 5B89     		ldrh	r3, [r3, #10]
 2085 0038 FA8B     		ldrh	r2, [r7, #30]
 2086 003a 9A42     		cmp	r2, r3
 2087 003c EFD2     		bcs	.L139
 2088              	.L138:
1113:../lwip-1.4.1/src/core/pbuf.c ****   }
1114:../lwip-1.4.1/src/core/pbuf.c ****   /* return requested data if pbuf is OK */
1115:../lwip-1.4.1/src/core/pbuf.c ****   if ((q != NULL) && (q->len > start)) {
 2089              		.loc 1 1115 0 is_stmt 1
 2090 003e BB69     		ldr	r3, [r7, #24]
 2091 0040 002B     		cmp	r3, #0
 2092 0042 27D0     		beq	.L140
 2093              		.loc 1 1115 0 is_stmt 0 discriminator 1
 2094 0044 BB69     		ldr	r3, [r7, #24]
 2095 0046 5B89     		ldrh	r3, [r3, #10]
 2096 0048 FA8B     		ldrh	r2, [r7, #30]
 2097 004a 9A42     		cmp	r2, r3
 2098 004c 22D2     		bcs	.L140
 2099              	.LBB4:
1116:../lwip-1.4.1/src/core/pbuf.c ****     u16_t i;
1117:../lwip-1.4.1/src/core/pbuf.c ****     for(i = 0; i < n; i++) {
 2100              		.loc 1 1117 0 is_stmt 1
 2101 004e 0023     		movs	r3, #0
 2102 0050 FB82     		strh	r3, [r7, #22]	@ movhi
 2103 0052 19E0     		b	.L141
 2104              	.L144:
 2105              	.LBB5:
1118:../lwip-1.4.1/src/core/pbuf.c ****       u8_t a = pbuf_get_at(q, start + i);
 2106              		.loc 1 1118 0
 2107 0054 FA8B     		ldrh	r2, [r7, #30]	@ movhi
 2108 0056 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 2109 0058 1344     		add	r3, r3, r2
 2110 005a 9BB2     		uxth	r3, r3
 2111 005c B869     		ldr	r0, [r7, #24]
 2112 005e 1946     		mov	r1, r3
 2113 0060 FFF7FEFF 		bl	pbuf_get_at
 2114 0064 0346     		mov	r3, r0
 2115 0066 7B75     		strb	r3, [r7, #21]
1119:../lwip-1.4.1/src/core/pbuf.c ****       u8_t b = ((u8_t*)s2)[i];
 2116              		.loc 1 1119 0
 2117 0068 FB8A     		ldrh	r3, [r7, #22]
 2118 006a 7A68     		ldr	r2, [r7, #4]
 2119 006c 1344     		add	r3, r3, r2
 2120 006e 1B78     		ldrb	r3, [r3]
 2121 0070 3B75     		strb	r3, [r7, #20]
1120:../lwip-1.4.1/src/core/pbuf.c ****       if (a != b) {
 2122              		.loc 1 1120 0
 2123 0072 7A7D     		ldrb	r2, [r7, #21]	@ zero_extendqisi2
 2124 0074 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 2125 0076 9A42     		cmp	r2, r3
 2126 0078 03D0     		beq	.L142
1121:../lwip-1.4.1/src/core/pbuf.c ****         return i+1;
 2127              		.loc 1 1121 0
 2128 007a FB8A     		ldrh	r3, [r7, #22]	@ movhi
 2129 007c 0133     		adds	r3, r3, #1
 2130 007e 9BB2     		uxth	r3, r3
 2131 0080 0AE0     		b	.L143
 2132              	.L142:
 2133              	.LBE5:
1117:../lwip-1.4.1/src/core/pbuf.c ****       u8_t a = pbuf_get_at(q, start + i);
 2134              		.loc 1 1117 0 discriminator 2
 2135 0082 FB8A     		ldrh	r3, [r7, #22]
 2136 0084 0133     		adds	r3, r3, #1
 2137 0086 FB82     		strh	r3, [r7, #22]	@ movhi
 2138              	.L141:
1117:../lwip-1.4.1/src/core/pbuf.c ****       u8_t a = pbuf_get_at(q, start + i);
 2139              		.loc 1 1117 0 is_stmt 0 discriminator 1
 2140 0088 FA8A     		ldrh	r2, [r7, #22]
 2141 008a 3B89     		ldrh	r3, [r7, #8]
 2142 008c 9A42     		cmp	r2, r3
 2143 008e E1D3     		bcc	.L144
1122:../lwip-1.4.1/src/core/pbuf.c ****       }
1123:../lwip-1.4.1/src/core/pbuf.c ****     }
1124:../lwip-1.4.1/src/core/pbuf.c ****     return 0;
 2144              		.loc 1 1124 0 is_stmt 1
 2145 0090 0023     		movs	r3, #0
 2146 0092 01E0     		b	.L143
 2147              	.L140:
 2148              	.LBE4:
1125:../lwip-1.4.1/src/core/pbuf.c ****   }
1126:../lwip-1.4.1/src/core/pbuf.c ****   return 0xffff;
 2149              		.loc 1 1126 0
 2150 0094 4FF6FF73 		movw	r3, #65535
 2151              	.L143:
1127:../lwip-1.4.1/src/core/pbuf.c **** }
 2152              		.loc 1 1127 0
 2153 0098 1846     		mov	r0, r3
 2154 009a 2037     		adds	r7, r7, #32
 2155              		.cfi_def_cfa_offset 8
 2156 009c BD46     		mov	sp, r7
 2157              		.cfi_def_cfa_register 13
 2158              		@ sp needed
 2159 009e 80BD     		pop	{r7, pc}
 2160              		.cfi_endproc
 2161              	.LFE17:
 2163              		.section	.text.pbuf_memfind,"ax",%progbits
 2164              		.align	2
 2165              		.global	pbuf_memfind
 2166              		.thumb
 2167              		.thumb_func
 2169              	pbuf_memfind:
 2170              	.LFB18:
1128:../lwip-1.4.1/src/core/pbuf.c **** 
1129:../lwip-1.4.1/src/core/pbuf.c **** /** Find occurrence of mem (with length mem_len) in pbuf p, starting at offset
1130:../lwip-1.4.1/src/core/pbuf.c ****  * start_offset.
1131:../lwip-1.4.1/src/core/pbuf.c ****  *
1132:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to search, maximum length is 0xFFFE since 0xFFFF is used as
1133:../lwip-1.4.1/src/core/pbuf.c ****  *        return value 'not found'
1134:../lwip-1.4.1/src/core/pbuf.c ****  * @param mem search for the contents of this buffer
1135:../lwip-1.4.1/src/core/pbuf.c ****  * @param mem_len length of 'mem'
1136:../lwip-1.4.1/src/core/pbuf.c ****  * @param start_offset offset into p at which to start searching
1137:../lwip-1.4.1/src/core/pbuf.c ****  * @return 0xFFFF if substr was not found in p or the index where it was found
1138:../lwip-1.4.1/src/core/pbuf.c ****  */
1139:../lwip-1.4.1/src/core/pbuf.c **** u16_t
1140:../lwip-1.4.1/src/core/pbuf.c **** pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
1141:../lwip-1.4.1/src/core/pbuf.c **** {
 2171              		.loc 1 1141 0
 2172              		.cfi_startproc
 2173              		@ args = 0, pretend = 0, frame = 24
 2174              		@ frame_needed = 1, uses_anonymous_args = 0
 2175 0000 80B5     		push	{r7, lr}
 2176              		.cfi_def_cfa_offset 8
 2177              		.cfi_offset 7, -8
 2178              		.cfi_offset 14, -4
 2179 0002 86B0     		sub	sp, sp, #24
 2180              		.cfi_def_cfa_offset 32
 2181 0004 00AF     		add	r7, sp, #0
 2182              		.cfi_def_cfa_register 7
 2183 0006 F860     		str	r0, [r7, #12]
 2184 0008 B960     		str	r1, [r7, #8]
 2185 000a 1146     		mov	r1, r2
 2186 000c 1A46     		mov	r2, r3
 2187 000e 0B46     		mov	r3, r1	@ movhi
 2188 0010 FB80     		strh	r3, [r7, #6]	@ movhi
 2189 0012 1346     		mov	r3, r2	@ movhi
 2190 0014 BB80     		strh	r3, [r7, #4]	@ movhi
1142:../lwip-1.4.1/src/core/pbuf.c ****   u16_t i;
1143:../lwip-1.4.1/src/core/pbuf.c ****   u16_t max = p->tot_len - mem_len;
 2191              		.loc 1 1143 0
 2192 0016 FB68     		ldr	r3, [r7, #12]
 2193 0018 1A89     		ldrh	r2, [r3, #8]
 2194 001a FB88     		ldrh	r3, [r7, #6]	@ movhi
 2195 001c D31A     		subs	r3, r2, r3
 2196 001e BB82     		strh	r3, [r7, #20]	@ movhi
1144:../lwip-1.4.1/src/core/pbuf.c ****   if (p->tot_len >= mem_len + start_offset) {
 2197              		.loc 1 1144 0
 2198 0020 FB68     		ldr	r3, [r7, #12]
 2199 0022 1B89     		ldrh	r3, [r3, #8]
 2200 0024 1946     		mov	r1, r3
 2201 0026 FA88     		ldrh	r2, [r7, #6]
 2202 0028 BB88     		ldrh	r3, [r7, #4]
 2203 002a 1344     		add	r3, r3, r2
 2204 002c 9942     		cmp	r1, r3
 2205 002e 18DB     		blt	.L146
1145:../lwip-1.4.1/src/core/pbuf.c ****     for(i = start_offset; i <= max; ) {
 2206              		.loc 1 1145 0
 2207 0030 BB88     		ldrh	r3, [r7, #4]	@ movhi
 2208 0032 FB82     		strh	r3, [r7, #22]	@ movhi
 2209 0034 11E0     		b	.L147
 2210              	.L150:
 2211              	.LBB6:
1146:../lwip-1.4.1/src/core/pbuf.c ****       u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 2212              		.loc 1 1146 0
 2213 0036 FA8A     		ldrh	r2, [r7, #22]
 2214 0038 FB88     		ldrh	r3, [r7, #6]
 2215 003a F868     		ldr	r0, [r7, #12]
 2216 003c 1146     		mov	r1, r2
 2217 003e BA68     		ldr	r2, [r7, #8]
 2218 0040 FFF7FEFF 		bl	pbuf_memcmp
 2219 0044 0346     		mov	r3, r0
 2220 0046 7B82     		strh	r3, [r7, #18]	@ movhi
1147:../lwip-1.4.1/src/core/pbuf.c ****       if (plus == 0) {
 2221              		.loc 1 1147 0
 2222 0048 7B8A     		ldrh	r3, [r7, #18]
 2223 004a 002B     		cmp	r3, #0
 2224 004c 01D1     		bne	.L148
1148:../lwip-1.4.1/src/core/pbuf.c ****         return i;
 2225              		.loc 1 1148 0
 2226 004e FB8A     		ldrh	r3, [r7, #22]
 2227 0050 09E0     		b	.L149
 2228              	.L148:
1149:../lwip-1.4.1/src/core/pbuf.c ****       } else {
1150:../lwip-1.4.1/src/core/pbuf.c ****         i += plus;
 2229              		.loc 1 1150 0
 2230 0052 FA8A     		ldrh	r2, [r7, #22]	@ movhi
 2231 0054 7B8A     		ldrh	r3, [r7, #18]	@ movhi
 2232 0056 1344     		add	r3, r3, r2
 2233 0058 FB82     		strh	r3, [r7, #22]	@ movhi
 2234              	.L147:
 2235              	.LBE6:
1145:../lwip-1.4.1/src/core/pbuf.c ****       u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 2236              		.loc 1 1145 0 discriminator 1
 2237 005a FA8A     		ldrh	r2, [r7, #22]
 2238 005c BB8A     		ldrh	r3, [r7, #20]
 2239 005e 9A42     		cmp	r2, r3
 2240 0060 E9D9     		bls	.L150
 2241              	.L146:
1151:../lwip-1.4.1/src/core/pbuf.c ****       }
1152:../lwip-1.4.1/src/core/pbuf.c ****     }
1153:../lwip-1.4.1/src/core/pbuf.c ****   }
1154:../lwip-1.4.1/src/core/pbuf.c ****   return 0xFFFF;
 2242              		.loc 1 1154 0
 2243 0062 4FF6FF73 		movw	r3, #65535
 2244              	.L149:
1155:../lwip-1.4.1/src/core/pbuf.c **** }
 2245              		.loc 1 1155 0
 2246 0066 1846     		mov	r0, r3
 2247 0068 1837     		adds	r7, r7, #24
 2248              		.cfi_def_cfa_offset 8
 2249 006a BD46     		mov	sp, r7
 2250              		.cfi_def_cfa_register 13
 2251              		@ sp needed
 2252 006c 80BD     		pop	{r7, pc}
 2253              		.cfi_endproc
 2254              	.LFE18:
 2256 006e 00BF     		.section	.text.pbuf_strstr,"ax",%progbits
 2257              		.align	2
 2258              		.global	pbuf_strstr
 2259              		.thumb
 2260              		.thumb_func
 2262              	pbuf_strstr:
 2263              	.LFB19:
1156:../lwip-1.4.1/src/core/pbuf.c **** 
1157:../lwip-1.4.1/src/core/pbuf.c **** /** Find occurrence of substr with length substr_len in pbuf p, start at offset
1158:../lwip-1.4.1/src/core/pbuf.c ****  * start_offset
1159:../lwip-1.4.1/src/core/pbuf.c ****  * WARNING: in contrast to strstr(), this one does not stop at the first \0 in
1160:../lwip-1.4.1/src/core/pbuf.c ****  * the pbuf/source string!
1161:../lwip-1.4.1/src/core/pbuf.c ****  *
1162:../lwip-1.4.1/src/core/pbuf.c ****  * @param p pbuf to search, maximum length is 0xFFFE since 0xFFFF is used as
1163:../lwip-1.4.1/src/core/pbuf.c ****  *        return value 'not found'
1164:../lwip-1.4.1/src/core/pbuf.c ****  * @param substr string to search for in p, maximum length is 0xFFFE
1165:../lwip-1.4.1/src/core/pbuf.c ****  * @return 0xFFFF if substr was not found in p or the index where it was found
1166:../lwip-1.4.1/src/core/pbuf.c ****  */
1167:../lwip-1.4.1/src/core/pbuf.c **** u16_t
1168:../lwip-1.4.1/src/core/pbuf.c **** pbuf_strstr(struct pbuf* p, const char* substr)
1169:../lwip-1.4.1/src/core/pbuf.c **** {
 2264              		.loc 1 1169 0
 2265              		.cfi_startproc
 2266              		@ args = 0, pretend = 0, frame = 16
 2267              		@ frame_needed = 1, uses_anonymous_args = 0
 2268 0000 80B5     		push	{r7, lr}
 2269              		.cfi_def_cfa_offset 8
 2270              		.cfi_offset 7, -8
 2271              		.cfi_offset 14, -4
 2272 0002 84B0     		sub	sp, sp, #16
 2273              		.cfi_def_cfa_offset 24
 2274 0004 00AF     		add	r7, sp, #0
 2275              		.cfi_def_cfa_register 7
 2276 0006 7860     		str	r0, [r7, #4]
 2277 0008 3960     		str	r1, [r7]
1170:../lwip-1.4.1/src/core/pbuf.c ****   size_t substr_len;
1171:../lwip-1.4.1/src/core/pbuf.c ****   if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
 2278              		.loc 1 1171 0
 2279 000a 3B68     		ldr	r3, [r7]
 2280 000c 002B     		cmp	r3, #0
 2281 000e 09D0     		beq	.L152
 2282              		.loc 1 1171 0 is_stmt 0 discriminator 1
 2283 0010 3B68     		ldr	r3, [r7]
 2284 0012 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2285 0014 002B     		cmp	r3, #0
 2286 0016 05D0     		beq	.L152
 2287              		.loc 1 1171 0 discriminator 2
 2288 0018 7B68     		ldr	r3, [r7, #4]
 2289 001a 1B89     		ldrh	r3, [r3, #8]
 2290 001c 4FF6FF72 		movw	r2, #65535
 2291 0020 9342     		cmp	r3, r2
 2292 0022 02D1     		bne	.L153
 2293              	.L152:
1172:../lwip-1.4.1/src/core/pbuf.c ****     return 0xFFFF;
 2294              		.loc 1 1172 0 is_stmt 1
 2295 0024 4FF6FF73 		movw	r3, #65535
 2296 0028 14E0     		b	.L154
 2297              	.L153:
1173:../lwip-1.4.1/src/core/pbuf.c ****   }
1174:../lwip-1.4.1/src/core/pbuf.c ****   substr_len = strlen(substr);
 2298              		.loc 1 1174 0
 2299 002a 3868     		ldr	r0, [r7]
 2300 002c FFF7FEFF 		bl	strlen
 2301 0030 F860     		str	r0, [r7, #12]
1175:../lwip-1.4.1/src/core/pbuf.c ****   if (substr_len >= 0xFFFF) {
 2302              		.loc 1 1175 0
 2303 0032 FB68     		ldr	r3, [r7, #12]
 2304 0034 4FF6FE72 		movw	r2, #65534
 2305 0038 9342     		cmp	r3, r2
 2306 003a 02D9     		bls	.L155
1176:../lwip-1.4.1/src/core/pbuf.c ****     return 0xFFFF;
 2307              		.loc 1 1176 0
 2308 003c 4FF6FF73 		movw	r3, #65535
 2309 0040 08E0     		b	.L154
 2310              	.L155:
1177:../lwip-1.4.1/src/core/pbuf.c ****   }
1178:../lwip-1.4.1/src/core/pbuf.c ****   return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 2311              		.loc 1 1178 0
 2312 0042 FB68     		ldr	r3, [r7, #12]
 2313 0044 9BB2     		uxth	r3, r3
 2314 0046 7868     		ldr	r0, [r7, #4]
 2315 0048 3968     		ldr	r1, [r7]
 2316 004a 1A46     		mov	r2, r3
 2317 004c 0023     		movs	r3, #0
 2318 004e FFF7FEFF 		bl	pbuf_memfind
 2319 0052 0346     		mov	r3, r0
 2320              	.L154:
1179:../lwip-1.4.1/src/core/pbuf.c **** }
 2321              		.loc 1 1179 0
 2322 0054 1846     		mov	r0, r3
 2323 0056 1037     		adds	r7, r7, #16
 2324              		.cfi_def_cfa_offset 8
 2325 0058 BD46     		mov	sp, r7
 2326              		.cfi_def_cfa_register 13
 2327              		@ sp needed
 2328 005a 80BD     		pop	{r7, pc}
 2329              		.cfi_endproc
 2330              	.LFE19:
 2332              		.text
 2333              	.Letext0:
 2334              		.file 2 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\port/arch/cc.h"
 2335              		.file 3 "f:\\eclipse\\gcc\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 2336              		.file 4 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/err.h"
 2337              		.file 5 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/memp.h
 2338              		.file 6 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/pbuf.h
 2339              		.file 7 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include\\ipv4/lwip/
 2340              		.file 8 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/tcp.h"
 2341              		.file 9 "F:\\ARM\\STM32 Eclipse Firmware\\STM32F107_Template\\lwip-1.4.1\\src\\include/lwip/tcp_im
DEFINED SYMBOLS
                            *ABS*:00000000 pbuf.c
                            *COM*:00000001 pbuf_free_ooseq_pending
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:20     .text.pbuf_free_ooseq:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:25     .text.pbuf_free_ooseq:00000000 pbuf_free_ooseq
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:87     .text.pbuf_free_ooseq:00000040 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:93     .text.pbuf_pool_is_empty:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:97     .text.pbuf_pool_is_empty:00000000 pbuf_pool_is_empty
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:124    .text.pbuf_pool_is_empty:00000014 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:129    .text.pbuf_alloc:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:134    .text.pbuf_alloc:00000000 pbuf_alloc
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:162    .text.pbuf_alloc:00000020 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:166    .text.pbuf_alloc:00000030 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:204    .text.pbuf_alloc:0000005c $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:208    .text.pbuf_alloc:0000006c $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:933    .text.pbuf_free:00000000 pbuf_free
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:465    .text.pbuf_alloced_custom:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:470    .text.pbuf_alloced_custom:00000000 pbuf_alloced_custom
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:499    .text.pbuf_alloced_custom:00000020 $d
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:503    .text.pbuf_alloced_custom:00000030 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:607    .text.pbuf_realloc:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:612    .text.pbuf_realloc:00000000 pbuf_realloc
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:756    .text.pbuf_header:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:761    .text.pbuf_header:00000000 pbuf_header
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:928    .text.pbuf_free:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1080   .text.pbuf_clen:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1085   .text.pbuf_clen:00000000 pbuf_clen
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1136   .text.pbuf_ref:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1141   .text.pbuf_ref:00000000 pbuf_ref
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1182   .text.pbuf_cat:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1187   .text.pbuf_cat:00000000 pbuf_cat
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1267   .text.pbuf_chain:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1272   .text.pbuf_chain:00000000 pbuf_chain
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1306   .text.pbuf_dechain:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1311   .text.pbuf_dechain:00000000 pbuf_dechain
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1384   .text.pbuf_copy:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1389   .text.pbuf_copy:00000000 pbuf_copy
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1581   .text.pbuf_copy_partial:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1586   .text.pbuf_copy_partial:00000000 pbuf_copy_partial
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1742   .text.pbuf_take:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1747   .text.pbuf_take:00000000 pbuf_take
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1871   .text.pbuf_coalesce:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1876   .text.pbuf_coalesce:00000000 pbuf_coalesce
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1943   .text.pbuf_get_at:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:1948   .text.pbuf_get_at:00000000 pbuf_get_at
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:2032   .text.pbuf_memcmp:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:2037   .text.pbuf_memcmp:00000000 pbuf_memcmp
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:2164   .text.pbuf_memfind:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:2169   .text.pbuf_memfind:00000000 pbuf_memfind
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:2257   .text.pbuf_strstr:00000000 $t
C:\Users\MISAKA~1.MIS\AppData\Local\Temp\ccyXQ34i.s:2262   .text.pbuf_strstr:00000000 pbuf_strstr
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.2d80f1b5ce3c69d13e258577ddf29668
                           .group:00000000 wm4.lwipopts.h.25.76e03deb318fbe54d896a83c1b611e55
                           .group:00000000 wm4.arch.h.33.6fa4aa86d33d1490ae882caef7316405
                           .group:00000000 wm4.cpu.h.33.0ec64ad8cd52614da6479c7936fa3efa
                           .group:00000000 wm4.cc.h.49.217a0c46a6dd8448cb36cccbf00f897f
                           .group:00000000 wm4.arch.h.52.2e97dbd839a1aa815d8c47878a7f8e2b
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.types.h.24.b2be5f53932a9c9d07787288b29b6d75
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.82.82b71f3f44c70e3a459d0f66642b05eb
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.68.ff6d7571d3ad75c55f15e26dbaa81e35
                           .group:00000000 wm4.debug.h.45.223028a5c052c9f879ffd43dd519f3f1
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.opt.h.76.0e16bb9c23144e1f631b5b5afa9a69f6
                           .group:00000000 wm4.mem.h.33.ae21028c0b1f3dc3305003fc71edaf5a
                           .group:00000000 wm4.memp.h.34.a409f52ec6d44b5681de26eb10b0c08b
                           .group:00000000 wm4.memp_std.h.15.637bb4287b70e9d70dbd8dd3c6f62f3b
                           .group:00000000 wm4.stats.h.51.0db2d210618aedce9edea4fb7e0fbaf1
                           .group:00000000 wm4.def.h.33.d4208c3cd3e0fc64e20a8b9f95a681f3
                           .group:00000000 wm4.err.h.33.909ff4b35439192d64931f0a04fc8fdb
                           .group:00000000 wm4.pbuf.h.45.444f43edbf93d1b2ead9ba1554355b0e
                           .group:00000000 wm4.sys.h.33.9424e51cd78278e60066cd7d6333ec27
                           .group:00000000 wm4.perf.h.33.85c55671e1b7570634f49777a207ad9f
                           .group:00000000 wm4.ip_addr.h.33.906726af218ee6749c0aa25e08c3a1fe
                           .group:00000000 wm4.netif.h.33.f0b62f0135b4c001826f0908df525042
                           .group:00000000 wm4.ip.h.48.c2e3a3e3a9e009c03a30eff6a88b0a33
                           .group:00000000 wm4.icmp.h.33.9c8da59f6edf08fae1a2f37336a6e965
                           .group:00000000 wm4.tcp.h.148.20c69d62fcb119a5d6bfd32bc982e4fb
                           .group:00000000 wm4.tcp_impl.h.84.6e9c66479f429d69332d497d793a73a6

UNDEFINED SYMBOLS
tcp_segs_free
tcp_active_pcbs
memp_malloc
mem_malloc
mem_trim
memp_free
mem_free
memcpy
strlen
